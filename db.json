{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/README.md","path":"README.md","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512832354884},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1512826473379},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1512826473379},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1512826473380},{"_id":"themes/next/.gitignore","hash":"ee0b13c268cc8695d3883a5da84930af02d4ed08","modified":1512826473383},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1512826473384},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1512826473384},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1512826473385},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1512826473385},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1512826473386},{"_id":"themes/next/README.md","hash":"19d57d39580c798dfdd119024d8c3342431b4ab4","modified":1512826473388},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1512826473387},{"_id":"themes/next/bower.json","hash":"47471a8f13528dc4052b746db5b4be2375682173","modified":1512826473389},{"_id":"themes/next/README.cn.md","hash":"b764aae78ffa561a9a68fdee4c6f21c3ce260fbb","modified":1512826473387},{"_id":"themes/next/_config.yml","hash":"f5af228bc3b596528574811e168c51c5b0758463","modified":1512840165345},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1512826473390},{"_id":"themes/next/package.json","hash":"39370e2aadf1f9a7c105edff064c6e47682b3932","modified":1512826473469},{"_id":"source/CNAME","hash":"e5e076f44e8516aa88546fa8413403111b493881","modified":1512904655581},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1512826473343},{"_id":"themes/next/.git/config","hash":"8e94cc015a498d35202e9fd57e44b3c51e1e5634","modified":1512826473354},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1512826324261},{"_id":"themes/next/.git/index","hash":"18f75f71fa5e8d6fdce860e79db23a47063df549","modified":1512826473724},{"_id":"themes/next/.git/packed-refs","hash":"f4d7e4a6f59a2abdcdcdd1733b89d4d72e9136d6","modified":1512826473332},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1512826473381},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"b1ec000babd42bb7ffd26f5ad8aac9b5bec79ae5","modified":1512826473381},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1512826473382},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1512826473383},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1512826473391},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1512826473391},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1512826473392},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1512826473393},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1512826473392},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1512826473393},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1512826473394},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1512826473395},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1512826473395},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1512826473396},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1512826473397},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1512826473397},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1512826473396},{"_id":"themes/next/languages/zh-Hans.yml","hash":"b38cefff5c0efb912a50dc5ad93ccfce383c6476","modified":1512832194395},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1512826473398},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1512826473399},{"_id":"themes/next/layout/_layout.swig","hash":"2164570bb05db11ee4bcfbbb5d183a759afe9d07","modified":1512833899440},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1512826473464},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1512826473465},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1512826473466},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1512826473467},{"_id":"themes/next/scripts/merge-configs.js","hash":"5758f8f3f12d17bc80da65bb808a20b3a8aae186","modified":1512826473470},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1512826473471},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1512826473468},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1512826473468},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1512826473466},{"_id":"themes/next/source/404.html","hash":"9eb955271b03c72a4bb23a06b60e4ecb4070a880","modified":1512829966759},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1512826473720},{"_id":"source/_drafts/C-标准库-顺序容器.md","hash":"3175a66879b65919d1debfa3b95e7d9937a97784","modified":1512839210798},{"_id":"source/_drafts/软件工程-复习.md","hash":"b4ac529503ae83530b90d82914b38f6af14751b0","modified":1512839210797},{"_id":"source/about/index.md","hash":"f7e2f182d7990f83095213fad0894f912fe97bd6","modified":1512999712580},{"_id":"source/_posts/anaconda-environment-notes.md","hash":"1db35844fac02735d76f301155c353675a68c145","modified":1512839210796},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1512826473722},{"_id":"source/_posts/c++-dynamic-memory-and-shared_ptr.md","hash":"0a6c2f4f3c4d1ec1aef99634120e681995a970bf","modified":1512839210794},{"_id":"source/_posts/c++-unique_ptr-and-weak_ptr.md","hash":"648406f9b1ed742385c64133698258510424613b","modified":1514384283443},{"_id":"source/_posts/c++-primary-variables.md","hash":"37e16aba30e798b0c2b5535ea081b6ee6315f601","modified":1512839210794},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1512826473721},{"_id":"source/_drafts/别人口中的真理，在你这可能不成立.md","hash":"02ce926b36bfb927c473ddfb466d3e18f80b7e05","modified":1512839210798},{"_id":"source/_posts/c-e5-9f-ba-e7-a1-80-e5-ad-97-e7-ac-a6-e4-b8-b2-e3-80-81-e5-90-91-e9-87-8f-e5-92-8c-e6-95-b0-e7-bb-84.md","hash":"0c5e3eac1703eb1cb248da0b32a975400446b19d","modified":1512839210794},{"_id":"source/_posts/c++andc Sleep.md","hash":"310bd454f20603ee1f77069f7a6da5974dd6ae80","modified":1512839857273},{"_id":"source/_posts/c-e5-9f-ba-e7-a1-80-e5-87-bd-e6-95-b0.md","hash":"e9ec93e7bcdb4ae1919124dc660f5a33341f0393","modified":1512839210794},{"_id":"source/_posts/c-e5-9f-ba-e7-a1-80-e7-b1-bb.md","hash":"9f5f76298f0b08376312990e914ffac37410869f","modified":1512839210794},{"_id":"source/_posts/c-e5-9f-ba-e7-a1-80-e8-a1-a8-e8-be-be-e5-bc-8f.md","hash":"39cd47da2694f42a8669af0fb804746bd1e53e43","modified":1512839210794},{"_id":"source/_posts/c-e6-a0-87-e5-87-86-e5-ba-93-e6-b3-9b-e5-9e-8b-e7-ae-97-e6-b3-95.md","hash":"84f1bbeb0cd1b7cdc2d0f15fcb55259cbb6b4f13","modified":1512839210794},{"_id":"source/_posts/c-e6-97-a0-e5-ba-8f-e5-ae-b9-e5-99-a8-e7-9a-84-e6-a1-b6-e7-ae-a1-e7-90-86.md","hash":"f5b05e92af43afa4deb0558c46694af4afc91615","modified":1512839210796},{"_id":"source/_posts/c-e8-be-a8-e6-9e-90-e4-b9-8bdecltype-e5-92-8cauto-e7-9a-84-e4-bd-bf-e7-94-a8.md","hash":"de8fb7091205d830173867db15d737de8ae93238","modified":1512839210794},{"_id":"source/_posts/e5-89-8d-e7-ab-af-e7-ac-94-e8-ae-b0.md","hash":"e86ff673af6503f1ac6d05b6bead6504a075a023","modified":1512839210795},{"_id":"source/_posts/e6-88-91-e8-ae-b0-e4-b8-8d-e4-bd-8f-e7-9a-84-e5-8d-95-e8-af-8d-e4-bb-ac-fck.md","hash":"416b87368ae029d385ad43858920f390cab0873c","modified":1512839210786},{"_id":"source/_posts/e5-89-8d-e7-ab-af-e7-ac-94-e8-ae-b0-e4-b9-8b-e7-bd-91-e9-a1-b5-e5-b8-83-e5-b1-80.md","hash":"33f3901a6aef86e33444d00d5aac5a80c1a832ac","modified":1512839210795},{"_id":"source/_posts/e5-9b-be-e5-bd-a2-e5-ad-a6-e5-a4-8d-e4-b9-a0-e6-96-87-e6-a1-a3.md","hash":"b4985a48753fdce2b1ecd469a86bb3aaa1bd6a68","modified":1512839210784},{"_id":"source/_posts/e6-ac-b2-e6-9c-9b-e5-92-8c-e6-97-b6-e9-97-b4.md","hash":"aa93ea336f7387b7f310ae3c491470129af857ca","modified":1512839210784},{"_id":"source/_posts/e6-93-8d-e4-bd-9c-e7-b3-bb-e7-bb-9f-e8-80-83-e7-82-b9-e5-a4-8d-e4-b9-a0.md","hash":"cc552ab7c67e2d86c3aae22c892576699d22bb5c","modified":1512839210785},{"_id":"source/_posts/e6-95-b0-e7-bb-84-e5-be-aa-e7-8e-af-e5-8f-b3-e7-a7-bb-e7-9a-84o1-e8-a7-a3-e6-b3-95.md","hash":"d036101a79351d07d47d125afa58c15ba6482879","modified":1512839210795},{"_id":"source/_posts/e6-9c-8d-e5-8a-a1-e5-99-a8-e8-bf-9c-e7-a8-8b-e8-ae-bf-e9-97-ae-e7-9b-b8-e5-85-b3.md","hash":"8550df2fb46c9658f2abd365df592ea1a85a19b1","modified":1512839210797},{"_id":"source/_posts/e7-ae-97-e6-b3-95-e5-85-a5-e9-97-a8-e6-b7-b1-e6-90-9c-ef-bc-88depth-first-search-ef-bc-89-e5-b0-8f-e7-bb-93.md","hash":"9726d7e1be8dd95118842aae265a8c685db50141","modified":1512839210785},{"_id":"source/_posts/git-e7-ac-94-e8-ae-b0.md","hash":"5d3599af694af757ff151ed407ece5c3a98b209d","modified":1512839210786},{"_id":"source/_posts/e7-bb-b4-e5-9f-ba-e7-99-be-e7-a7-91-e5-85-ad-e5-ba-a6-e5-88-86-e9-9a-94-e7-90-86-e8-ae-ba.md","hash":"3ef2b89adc3728d956a03e306ac332db4a5a67c0","modified":1512839210785},{"_id":"source/_posts/e8-b0-b7-e6-ad-8c-e5-bc-80-e6-ba-90-e7-9a-84tensorflow-object-detection-api-e7-9a-84-e4-bd-bf-e7-94-a8.md","hash":"323eb84e3961232cafd21e4d9ffa1f62253b34b0","modified":1512839210795},{"_id":"source/_posts/gold ages.md","hash":"a175eee89045a67dce91eab110081effd4b806e2","modified":1512839210785},{"_id":"source/_posts/how to login when forget mysql passwd.md","hash":"5d011dc7e7e009809f3ac7dad7149c14a0d4be0c","modified":1512839210798},{"_id":"source/_posts/lanqiao B2.md","hash":"87f5ecaa709b9a8c0c495e49312e7bd326f7444f","modified":1512839210784},{"_id":"source/_posts/liunx-e7-94-9f-e6-88-90ssh-e5-9c-a8github-e4-b8-ad-e9-85-8d-e7-bd-ae.md","hash":"19e48f39495a96f7e768673528dc25b31e262835","modified":1512839210795},{"_id":"source/_posts/opencv3.3 ssd.md","hash":"1032300416949f6435cf9105c4ef06f66f1c8224","modified":1512839210796},{"_id":"source/_posts/python regular problems.md","hash":"11b5c40b64c084794f7009bfaae65240a88ef233","modified":1512839210786},{"_id":"source/_posts/python spider wiki.md","hash":"13997cb68752bf0dfb979f228c79d137a1f79998","modified":1512839210785},{"_id":"source/_posts/python-e5-9f-ba-e7-a1-80-e5-b0-8f-e7-bb-93.md","hash":"e52565d3f3901fd5921b0e18b4cf9d67c316bb91","modified":1512839210785},{"_id":"source/_posts/session-e5-92-8ccookie-e7-9a-84-e5-8c-ba-e5-88-ab.md","hash":"bea264fc393fe897e0c64b4fd99e715457846198","modified":1512839210784},{"_id":"source/_posts/python-libraries.md","hash":"838a8fb9fa2fdae2a93d2ac0d96513f86b99bc87","modified":1512839210785},{"_id":"source/_posts/why-vector-cannot-store-reference.md","hash":"c0ebe623fed63558652c4b8e08118a94a5cf3b0f","modified":1512839210795},{"_id":"source/_posts/resolve ubuntu cannot get lock.md","hash":"bdae627d10c45b487efcd3aac6013d775ea2b9f0","modified":1512839210786},{"_id":"source/_posts/ubuntu-e4-b8-8b-e5-b8-b8-e7-94-a8-e7-9a-84-e5-91-bd-e4-bb-a4-e8-ae-b0-e5-bd-95.md","hash":"ea3cc5e4570ab7b30bdd77a8d6107e2476880158","modified":1512839210794},{"_id":"source/categories/index.md","hash":"62c65737e18cecde837a4e32db1ac8328ed8eda6","modified":1512828920264},{"_id":"source/_posts/ubuntu-e7-94-a8shadowsocks-e7-a7-91-e5-ad-a6-e4-b8-8a-e7-bd-91-e5-ae-8c-e5-85-a8-e6-95-99-e7-a8-8b.md","hash":"f80d88f1baed9e02c6db2146e7bc1847c55b396e","modified":1512839210792},{"_id":"source/record/index.md","hash":"e36144271c7cd6b71516dfb54cc6ebff039b1e25","modified":1512839210797},{"_id":"source/tags/index.md","hash":"461f89cbeba6162f984ec5d5917c71ceae5d3399","modified":1512828515218},{"_id":"source/_posts/web-development-1.md","hash":"c226f91c736ad0e2ced437277b9d5b196f9402da","modified":1514385308158},{"_id":"source/dairy/index.md","hash":"0e06449c2c6e3ee6ccff927214d2785c1f88c11f","modified":1512839210797},{"_id":"source/_posts/windows-e5-ba-94-e7-94-a8-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e6-9c-9f-e6-9c-ab-e5-a4-8d-e4-b9-a0.md","hash":"b7a702392b90bd9c05b3a4f1dffbf66f08247f24","modified":1512839210786},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512826473583},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1512826324262},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1512826324264},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1512826324265},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1512826324263},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1512826324269},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1512826324266},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1512826324267},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1512826324268},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1512826324270},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1512826324272},{"_id":"themes/next/.git/logs/HEAD","hash":"86be15d94fc40e09913d34c7fb3beb46a5cfb79b","modified":1512826473348},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1512826324271},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1512826473402},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1512826473402},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1512826473400},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1512826473412},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1512826473400},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1512826473406},{"_id":"themes/next/layout/_macro/post.swig","hash":"0efa1d7c5bb067753261d5063352356f8d53e6b9","modified":1512832143734},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b9f9959225876fb56fb3fba96306d19396e704d4","modified":1512826473411},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1512826473414},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1512826473415},{"_id":"themes/next/layout/_partials/footer.swig","hash":"1b40db19b800331510f2e3a43e78f4b9536346e0","modified":1512838723004},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1512826473418},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1512826473418},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1512826473419},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1512826473417},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1512826473430},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1512826473426},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1512826473445},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1512826473445},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1512826473446},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1512826473457},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1512826473448},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1512826473425},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1512826473455},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1512826473452},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1512826473472},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1512826473472},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1512826473473},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1512826473474},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1512826473475},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1512826473475},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1512826473476},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1512826473476},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1512826473477},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1512826473582},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1512826473584},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1512826473585},{"_id":"themes/next/source/images/alipay.jpg","hash":"0d8d35f69d14cb43f36db5b48cbc04adeef2eb0a","modified":1512813164269},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1512826473585},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1512826473586},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1512826473587},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1512826473588},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1512826473589},{"_id":"themes/next/source/images/favicon.png","hash":"b76d64ddd0a9f735e4040f5f7005c3373b279e92","modified":1512832437439},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1512826473593},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1512826473592},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1512826473590},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1512826473591},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1512826473591},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1512826473594},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1512826473592},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1512826473596},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1512826473593},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1512826473595},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1512826473595},{"_id":"themes/next/source/images/wechatpay.jpg","hash":"adb47f1d0828ae77f6cadd2ae34c3e951568f961","modified":1512813150246},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512826473428},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512826473428},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512826473579},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512826473581},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512826473550},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512826473550},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512826473553},{"_id":"themes/next/.git/refs/heads/master","hash":"d022a9d44457f7717004a8c765a92e0305245725","modified":1512826473347},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1512826473416},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1512826473421},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1512826473417},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1512826473424},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1512826473422},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1512826473420},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1512826473424},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1512826473420},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1512826473419},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1512826473428},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1512826473429},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1512826473427},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1512826473432},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1512826473431},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1512826473431},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1512826473434},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1512826473436},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1512826473436},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1512826473433},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1512826473434},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1512826473435},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1512826473438},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1512826473437},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1512826473438},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1512826473439},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1512826473440},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1512826473440},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1512826473441},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1512826473443},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1512826473442},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1512826473441},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1512826473444},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1512826473443},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1512826473461},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1512826473464},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1512826473462},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1512826473462},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1512826473444},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1512826473579},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1512826473575},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1512826473551},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1512826473580},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1512826473550},{"_id":"themes/next/source/css/_variables/base.styl","hash":"e0726d6544d9aad0ef40973fe1b4d48d0e0c06ea","modified":1512832904211},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1512826473552},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1512826473548},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1512826473628},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1512826473632},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1512826473631},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1512826473630},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1512826473622},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1512826473650},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1512826473650},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1512826473651},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1512826473649},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1512826473684},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1512826473686},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1512826473651},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1512826473647},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1512826473645},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1512826473646},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1512826473685},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1512826473646},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1512826473688},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1512826473687},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1512826473687},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1512826473689},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1512826473690},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1512826473692},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1512826473690},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1512826473691},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1512826473689},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1512826473692},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1512826473693},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1512826473692},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1512826473693},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1512826473694},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1512826473695},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1512826473699},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1512826473704},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1512826473714},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1512826473714},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1512826473718},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1512826473717},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1512826473680},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1512826473681},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1512826473719},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1512826473680},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1512826473683},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1512826473683},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1512826473682},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1512826473598},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1512826473598},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1512826473599},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1512826473600},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1512826473601},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1512826473600},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1512826473601},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1512826473602},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1512826473604},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1512826473604},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1512826473677},{"_id":"themes/next/source/js/src/utils.js","hash":"b7ddc240208d57596a67c78a04a11b0f0bdecc97","modified":1512826473605},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"86be15d94fc40e09913d34c7fb3beb46a5cfb79b","modified":1512826473349},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1512826473340},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1512826473678},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1512826473460},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1512826473459},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1512826473557},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1512826473555},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1512826473558},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1512826473557},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1512826473558},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1512826473556},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1512826473559},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1512826473562},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1512826473563},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"a98ad885ee4f48d85b2578a0b9c2bbf166e96733","modified":1512826473564},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1512826473554},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1512826473564},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1512826473565},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1512826473567},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1512826473569},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1512826473568},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1512826473570},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1512826473568},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"30561ed60fc64f3e4ce85143bdb55faa814743a6","modified":1512826473569},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1512826473481},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1512826473480},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1512826473480},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1512826473481},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1512826473482},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1512826473502},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1512826473520},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1512826473543},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1512826473545},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1512826473546},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1512826473544},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1512826473547},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1512826473542},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1512826473544},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1512826473633},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1512826473619},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1512826473611},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1512826473613},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1512826473636},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1512826473635},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1512826473634},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1512826473636},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1512826473643},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1512826473637},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1512826473644},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1512826473652},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1512826473644},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1512826473654},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1512826473653},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1512826473648},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1512826473648},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1512826473712},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1512826473712},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1512826473603},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1512826473612},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1512826473675},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1512826473676},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1512826473717},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"86be15d94fc40e09913d34c7fb3beb46a5cfb79b","modified":1512826473339},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1512826473561},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1512826473560},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1512826473566},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1512826473484},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1512826473487},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1512826473499},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1512826473499},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1512826473485},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1512826473486},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1512826473485},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1512826473500},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1512826473501},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1512826473491},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1512826473503},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1512826473505},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1512826473495},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1512826473497},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1512826473506},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1512826473501},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1512826473508},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1512826473507},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1512826473510},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1512826473508},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1512826473510},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1512826473509},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"65965001dcc9f3638af284b60796b9d3ece325d6","modified":1512832968590},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1512826473512},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1512826473512},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1512826473514},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1512826473513},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1512826473504},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1512826473515},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1512826473516},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1512826473511},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1512826473516},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1512826473514},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1512826473517},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1512826473518},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1512826473519},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"28a8737c090fbffd188d73a00b42e90b9ee57df2","modified":1512826473518},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1512837790798},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1512826473522},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"3159b55f35c40bd08e55b00148c523760a708c51","modified":1512826473523},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1512826473521},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1512826473524},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1512826473520},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1512826473524},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1512826473525},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1512826473528},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1512826473529},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1512826473525},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1512826473527},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1512826473531},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1512826473526},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1512826473539},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1512826473535},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1512826473529},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1512826473526},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1512826473538},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1512826473541},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1512826473538},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1512826473607},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1512826473608},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1512826473608},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1512826473610},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1512826473609},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1512826473638},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1512826473639},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1512826473642},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1512826473641},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1512826473640},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1512826473641},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1512826473660},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1512826473666},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1512826473674},{"_id":"themes/next/.git/objects/pack/pack-0397cb728d27b3c243f83b3278eebcfbe0714328.idx","hash":"18f6edca8946aa1246f6c94b3bc19f496798250f","modified":1512826473185},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1512826473627},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1512826473709},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1512826473670},{"_id":"themes/next/source/images/avatar.jpg","hash":"a1b6b702dadfcf16d7e55b29db3f8cd15f2ab874","modified":1512827275909},{"_id":"themes/next/.git/objects/pack/pack-0397cb728d27b3c243f83b3278eebcfbe0714328.pack","hash":"86cc297909cdaec12ac8859f2773c1fe23456e0a","modified":1512826473189},{"_id":"public/sitemap.xml","hash":"7f494decee8d5d050ba31c9c9e20e729bb0bb7a6","modified":1514385364484},{"_id":"public/about/index.html","hash":"d6de0623e3a8c08aa498e17a4f434df7cd760d91","modified":1514384454073},{"_id":"public/categories/index.html","hash":"0259b4ab4c7640173feb32146cd1fa18459a6efa","modified":1514385364509},{"_id":"public/record/index.html","hash":"e8869f95538a795ef58a8b141b4819ca1a393d76","modified":1514384454083},{"_id":"public/tags/index.html","hash":"469d6a6cab157d218a2deb89f17a39b0dcb5486e","modified":1514385364509},{"_id":"public/dairy/index.html","hash":"3da41d2af6c2a4c529ca736f6afa339af6f8a987","modified":1514384454083},{"_id":"public/2017/12/27/web-development-1/index.html","hash":"f04930f9498a7b7c4df75caa87f37d9f7b586825","modified":1514385364510},{"_id":"public/2017/11/02/how to login when forget mysql passwd/index.html","hash":"10ef57d638e25318f1a22164297b1a5042ad3d1b","modified":1514385364510},{"_id":"public/2017/10/19/anaconda-environment-notes/index.html","hash":"f518cde386319db202235d7b47464673133c80fd","modified":1514384454083},{"_id":"public/2017/10/12/opencv3.3 ssd/index.html","hash":"dc116c73dc79360e053e652323ba65a71b907a53","modified":1514384454083},{"_id":"public/2017/09/02/e6-95-b0-e7-bb-84-e5-be-aa-e7-8e-af-e5-8f-b3-e7-a7-bb-e7-9a-84o1-e8-a7-a3-e6-b3-95/index.html","hash":"92fca7a9024e48c12fcdc53705d5e4be154bb18f","modified":1514384454083},{"_id":"public/2017/10/19/e6-9c-8d-e5-8a-a1-e5-99-a8-e8-bf-9c-e7-a8-8b-e8-ae-bf-e9-97-ae-e7-9b-b8-e5-85-b3/index.html","hash":"0a08f1a43f8046822853af862a34ae8e59534516","modified":1514384454083},{"_id":"public/2017/10/10/e8-b0-b7-e6-ad-8c-e5-bc-80-e6-ba-90-e7-9a-84tensorflow-object-detection-api-e7-9a-84-e4-bd-bf-e7-94-a8/index.html","hash":"a5abba7cfe492d8a0408390acd09255ed13370b3","modified":1514384454093},{"_id":"public/2017/09/01/c-e6-97-a0-e5-ba-8f-e5-ae-b9-e5-99-a8-e7-9a-84-e6-a1-b6-e7-ae-a1-e7-90-86/index.html","hash":"a5cb5fe0629c6ce258d62fe741edf6dfaa909d6c","modified":1514384454093},{"_id":"public/2017/09/01/c++andc Sleep/index.html","hash":"25fbab16b2a89212d5de2fe7d2d311fd9e927807","modified":1514384454093},{"_id":"public/2017/08/31/liunx-e7-94-9f-e6-88-90ssh-e5-9c-a8github-e4-b8-ad-e9-85-8d-e7-bd-ae/index.html","hash":"48937c95e971a94a16a8c751749bc98337dfd443","modified":1514384454093},{"_id":"public/2017/08/23/why-vector-cannot-store-reference/index.html","hash":"25bb80f97ccef9981de83fb94ba169e4b3c4c07b","modified":1514384454093},{"_id":"public/2017/08/11/e5-89-8d-e7-ab-af-e7-ac-94-e8-ae-b0-e4-b9-8b-e7-bd-91-e9-a1-b5-e5-b8-83-e5-b1-80/index.html","hash":"8894b28b699f6474c5fd5f1c34afa8f604e058e2","modified":1514384454093},{"_id":"public/2017/08/11/e5-89-8d-e7-ab-af-e7-ac-94-e8-ae-b0/index.html","hash":"9b774d7f41423834437cfca7f3c6d5ca03decce6","modified":1514384454093},{"_id":"public/2017/08/07/ubuntu-e4-b8-8b-e5-b8-b8-e7-94-a8-e7-9a-84-e5-91-bd-e4-bb-a4-e8-ae-b0-e5-bd-95/index.html","hash":"55bee61d85cce497c429646f8aba4cf72a8fffa9","modified":1514384454093},{"_id":"public/2017/08/04/c++-unique_ptr-and-weak_ptr/index.html","hash":"2b9c4beab9a588ce907cade40c49859c25b7d0c5","modified":1514384454093},{"_id":"public/2017/08/03/c++-dynamic-memory-and-shared_ptr/index.html","hash":"7b7fae559f23e7afb573523146538b0c8a964982","modified":1514384454093},{"_id":"public/2017/07/31/c-e6-a0-87-e5-87-86-e5-ba-93-e6-b3-9b-e5-9e-8b-e7-ae-97-e6-b3-95/index.html","hash":"8fb43321866053b5214e5ac4ab8dc9ea3fb0638a","modified":1514384454093},{"_id":"public/2017/07/22/c-e5-9f-ba-e7-a1-80-e7-b1-bb/index.html","hash":"64857c2e35dc9aec3ae681dac6eff82c506c68f3","modified":1514384454093},{"_id":"public/2017/07/15/c-e5-9f-ba-e7-a1-80-e8-a1-a8-e8-be-be-e5-bc-8f/index.html","hash":"0b5d237380bd9df61dabe57667986f4e5f985db8","modified":1514384454093},{"_id":"public/2017/07/18/c-e5-9f-ba-e7-a1-80-e5-87-bd-e6-95-b0/index.html","hash":"9a78f9c4602560931b01bd051593ea2797910335","modified":1514384454093},{"_id":"public/2017/07/15/c-e8-be-a8-e6-9e-90-e4-b9-8bdecltype-e5-92-8cauto-e7-9a-84-e4-bd-bf-e7-94-a8/index.html","hash":"7d33beb414fb4b910e8054fd1bd57dbd0b2a2ce6","modified":1514384454093},{"_id":"public/2017/07/13/c-e5-9f-ba-e7-a1-80-e5-ad-97-e7-ac-a6-e4-b8-b2-e3-80-81-e5-90-91-e9-87-8f-e5-92-8c-e6-95-b0-e7-bb-84/index.html","hash":"48a0b55dfce23f6fe147de812003b385469c5fca","modified":1514384454093},{"_id":"public/2017/07/11/resolve ubuntu cannot get lock/index.html","hash":"323989f1e1f11d111109724222953cbc63583d1b","modified":1514384454093},{"_id":"public/2017/07/11/ubuntu-e7-94-a8shadowsocks-e7-a7-91-e5-ad-a6-e4-b8-8a-e7-bd-91-e5-ae-8c-e5-85-a8-e6-95-99-e7-a8-8b/index.html","hash":"e8daf3d89a2fc3625d864bf815501e64d2dee6ec","modified":1514384454093},{"_id":"public/2017/06/30/python regular problems/index.html","hash":"9330da65c450f55e4dcdfd36219664a2a890b032","modified":1514384454093},{"_id":"public/2017/07/03/c++-primary-variables/index.html","hash":"298b50d8aade9c441ac61e0b47d84ceb6dc46512","modified":1514384454093},{"_id":"public/2017/07/10/git-e7-ac-94-e8-ae-b0/index.html","hash":"19c92c055fe8338677ea72d5bac82884823aed21","modified":1514384454093},{"_id":"public/2017/06/26/e6-88-91-e8-ae-b0-e4-b8-8d-e4-bd-8f-e7-9a-84-e5-8d-95-e8-af-8d-e4-bb-ac-fck/index.html","hash":"6af51e8f7c1756a93a1f49920ddb459e401eaa55","modified":1514384454093},{"_id":"public/2017/06/18/e6-93-8d-e4-bd-9c-e7-b3-bb-e7-bb-9f-e8-80-83-e7-82-b9-e5-a4-8d-e4-b9-a0/index.html","hash":"e26349e0be3260c52547471e3189d2db95925d04","modified":1514384454093},{"_id":"public/2017/06/08/python spider wiki/index.html","hash":"2ca642821c5873df4de1619212d21c0772d25646","modified":1514384454093},{"_id":"public/2017/06/09/python-e5-9f-ba-e7-a1-80-e5-b0-8f-e7-bb-93/index.html","hash":"1529fdc65477f0ecb6e02ff0b50b527be5b01938","modified":1514384454093},{"_id":"public/2017/06/23/windows-e5-ba-94-e7-94-a8-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e6-9c-9f-e6-9c-ab-e5-a4-8d-e4-b9-a0/index.html","hash":"51ab5e17883b084365af48caee04a10799108684","modified":1514384454093},{"_id":"public/2017/06/08/python-libraries/index.html","hash":"df34642d9952d856001bc2fdb34c757b7594427c","modified":1514384454093},{"_id":"public/2017/05/04/e6-ac-b2-e6-9c-9b-e5-92-8c-e6-97-b6-e9-97-b4/index.html","hash":"23ba9b277d669ea27427b5076493c0f5409e301f","modified":1514384454093},{"_id":"public/2017/05/09/gold ages/index.html","hash":"5c6779782c737501a267ff4006f236df6a6b4a44","modified":1514384454093},{"_id":"public/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1514384454093},{"_id":"public/categories/c-学习/page/2/index.html","hash":"8ea3d5d68fa8827305649405db6aab5afe0686eb","modified":1514384454103},{"_id":"public/categories/python学习/工具们/index.html","hash":"e78b4b8a5b98fa4bf14d315ca04d90c4efcdb040","modified":1514384454103},{"_id":"public/categories/语言/index.html","hash":"c9969082e2a54b99824f4c0adae3f8266475d51c","modified":1514384454103},{"_id":"public/categories/操作系统/index.html","hash":"6642b82170bb20f470f45f2df05abd0164a0679e","modified":1514384454103},{"_id":"public/categories/工具们/index.html","hash":"43cad5a592db10c653b45b1edc1e1cbdf61b2495","modified":1514384454103},{"_id":"public/categories/git/index.html","hash":"f4596382646a89e05004f5aaaaebf4e12b953c54","modified":1514384454103},{"_id":"public/categories/python学习/机器学习/index.html","hash":"99d9e2df534a41df93f4974cc2c34bbeea51f6af","modified":1514384454103},{"_id":"public/categories/工具们/操作系统/index.html","hash":"38b5fe0f941610cc8498f31deb2901ae972da8e9","modified":1514384454103},{"_id":"public/categories/机器学习/index.html","hash":"8f1a6bc591b0e9f39b101d64c671da964289b5c6","modified":1514384454103},{"_id":"public/categories/git/工具们/index.html","hash":"be3f19a5fb90b779ed3ac2504a8ea217ac642b53","modified":1514384454103},{"_id":"public/categories/课程小结/index.html","hash":"0981ada1f986379e12fcc6bd1ca2d36550c0818b","modified":1514384454103},{"_id":"public/archives/2017/05/index.html","hash":"1c7fe9551d40720c66cb629396e89b1036038d24","modified":1514384454103},{"_id":"public/archives/2017/04/index.html","hash":"5159780d94cdb2ca2fe9614ab3105b6ef2ddcd9f","modified":1514384454103},{"_id":"public/archives/2017/09/index.html","hash":"589efa96ec858d3c25eff5360aaec898495322a2","modified":1514384454103},{"_id":"public/archives/2017/10/index.html","hash":"ce996c3afc01d1a21036e8296e38f1ef8ca5fad3","modified":1514384454103},{"_id":"public/archives/2017/11/index.html","hash":"07ca1de23d6fdb6c57278f95c0d243b5659a0483","modified":1514384454103},{"_id":"public/archives/2017/12/index.html","hash":"fceb1aafdac7b34b82e2692ecf5af9938199e24b","modified":1514385364509},{"_id":"public/tags/生活记录/index.html","hash":"9f052c21472827f177ae263e316964ff8436a59b","modified":1514384454103},{"_id":"public/tags/前端/index.html","hash":"53b931b8aab5a23801a1c421c0ba0ab6dd23f4e4","modified":1514384454103},{"_id":"public/tags/图形学/index.html","hash":"843966c76da13e6030a76f787af65f4e30243591","modified":1514384454103},{"_id":"public/tags/操作系统/index.html","hash":"2818e2c136a36479f2804d11f61775bd78e31c0c","modified":1514384454103},{"_id":"public/tags/瞎想/index.html","hash":"9e13c41c5af3aadb96cb9dd95c53afb686e756f5","modified":1514384454103},{"_id":"public/tags/算法/index.html","hash":"5304ec326dfa73160ec79984237d46d0dd89bd66","modified":1514384454103},{"_id":"public/tags/git/index.html","hash":"efbed99186f3396ff9606f866852bd6eb52d09d8","modified":1514384454103},{"_id":"public/tags/算法学习/index.html","hash":"0999239403e69d0239f476d4fcea90ccecd5ec30","modified":1514384454103},{"_id":"public/tags/百科/index.html","hash":"067e629d5bc4fea0c8432a82c099fd78a515376a","modified":1514384454103},{"_id":"public/tags/python学习/index.html","hash":"a6daae92ae6bffd06eb454ae4786018c3ee410d1","modified":1514384454103},{"_id":"public/tags/机器学习/index.html","hash":"440e8e084c3cb5129e6ca514d1d5dd98545e8c9e","modified":1514384454103},{"_id":"public/tags/python爬虫/index.html","hash":"ca595476404890e28414bac95f6aa0a916e62461","modified":1514384454103},{"_id":"public/tags/小问题/index.html","hash":"19782f362e7ca3e3abfba137c636978c70f30f5e","modified":1514384454103},{"_id":"public/tags/web学习整理/index.html","hash":"01b181c91c1c14ba1d38392e3e59fbeb070906d5","modified":1514385364509},{"_id":"public/tags/课程/index.html","hash":"aa261c7ac6ef4b2092a7eb418e73d244fb4f23b0","modified":1514384454103},{"_id":"public/2017/04/13/e7-ae-97-e6-b3-95-e5-85-a5-e9-97-a8-e6-b7-b1-e6-90-9c-ef-bc-88depth-first-search-ef-bc-89-e5-b0-8f-e7-bb-93/index.html","hash":"d0a5c85620ec2a05a284193be9339cacfbd3ef05","modified":1514384454103},{"_id":"public/2017/04/21/session-e5-92-8ccookie-e7-9a-84-e5-8c-ba-e5-88-ab/index.html","hash":"eeace9ff5e344972fbdfb540987da123eb7a99b1","modified":1514384454103},{"_id":"public/2017/06/07/e7-bb-b4-e5-9f-ba-e7-99-be-e7-a7-91-e5-85-ad-e5-ba-a6-e5-88-86-e9-9a-94-e7-90-86-e8-ae-ba/index.html","hash":"e224d8218598f4a89f3ce0b20256e1ab56b21a8b","modified":1514384454103},{"_id":"public/2017/04/26/e5-9b-be-e5-bd-a2-e5-ad-a6-e5-a4-8d-e4-b9-a0-e6-96-87-e6-a1-a3/index.html","hash":"b4a8e3c4a7e4e961ff1deb1083a0c8c4a087beee","modified":1514384454103},{"_id":"public/categories/python学习/index.html","hash":"47a775d1c0f63b5c2b02e31b5f667bb0a94f66f5","modified":1514384454103},{"_id":"public/2017/04/10/lanqiao B2/index.html","hash":"c6b281fd2395d1e63f4a0ff62412c840d9c8efbb","modified":1514384454103},{"_id":"public/categories/c-学习/index.html","hash":"0690df4025d843345528ba3f56d5dd312fb93d39","modified":1514384454103},{"_id":"public/categories/web学习整理/index.html","hash":"e9d2903a69307c00771355fc4b184619592a9ccc","modified":1514385364511},{"_id":"public/archives/page/3/index.html","hash":"acbb566136aa3a7655e8566018a39b17b24f66d2","modified":1514384454103},{"_id":"public/archives/index.html","hash":"108cfce3a1ccb6c45cefb5f6452a62dcc557b3fe","modified":1514385364510},{"_id":"public/archives/page/2/index.html","hash":"78197053f51fc6a1902e7a47a9a8a939c9dc404b","modified":1514384454103},{"_id":"public/archives/page/4/index.html","hash":"0a1c65c140a899c8e1477e3b9128ecfa580c2360","modified":1514384454103},{"_id":"public/archives/2017/page/2/index.html","hash":"42ea3fd918ad31d25d626760a6c6eb9ec436594e","modified":1514384454103},{"_id":"public/archives/2017/index.html","hash":"33312e8222ec9415cb3c678c32949be7db932b87","modified":1514385364510},{"_id":"public/archives/2017/page/3/index.html","hash":"9138bc16204ebe0aa9276d964faeb8cd96c95317","modified":1514384454103},{"_id":"public/archives/2017/page/4/index.html","hash":"fffeff14ba4d965e2fbce69e821f999f79d60d45","modified":1514384454103},{"_id":"public/archives/2017/06/index.html","hash":"a410c493c6df2bee24d542998eeb4cd07f9c7da6","modified":1514384454103},{"_id":"public/archives/2017/07/index.html","hash":"ba28c63199cc8dc6791b33caf739f9cd94cccdb8","modified":1514384454103},{"_id":"public/archives/2017/08/index.html","hash":"df11551e3ca06ccaadb000ed976b5f1b9e7db49c","modified":1514384454103},{"_id":"public/index.html","hash":"9aa0099f0717ce0d1220455b4f86818a28517e76","modified":1514385364511},{"_id":"public/page/2/index.html","hash":"0ddcf34934c71d4c0c8964f80a14c54742acb5e3","modified":1514384454103},{"_id":"public/page/3/index.html","hash":"2c73890a679efe13fc15339619b806741b9cc11c","modified":1514384454103},{"_id":"public/page/4/index.html","hash":"71fb7640c24a3498a72b3cc32c76eefb3cae9a8a","modified":1514384454103},{"_id":"public/tags/c/index.html","hash":"6e537b9a38e25192c95b65b6e298f35f36a5f51f","modified":1514384454103},{"_id":"public/CNAME","hash":"e5e076f44e8516aa88546fa8413403111b493881","modified":1514384454103},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1514384454103},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1514384454103},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1514384454103},{"_id":"public/images/alipay.jpg","hash":"0d8d35f69d14cb43f36db5b48cbc04adeef2eb0a","modified":1514384454103},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1514384454103},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1514384454103},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1514384454103},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1514384454103},{"_id":"public/images/favicon.png","hash":"b76d64ddd0a9f735e4040f5f7005c3373b279e92","modified":1514384454103},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514384454103},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1514384454103},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1514384454103},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1514384454103},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1514384454103},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1514384454103},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1514384454103},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1514384454103},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1514384454103},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1514384454103},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1514384454103},{"_id":"public/images/wechatpay.jpg","hash":"adb47f1d0828ae77f6cadd2ae34c3e951568f961","modified":1514384454103},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1514384454103},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1514384454103},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1514384454103},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1514384454103},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1514384454103},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1514384454103},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1514384454103},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1514384454103},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1514384454103},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1514384454103},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1514384454103},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1514384454103},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1514384454103},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1514384454103},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1514384454103},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1514384454714},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1514384454724},{"_id":"public/404.html","hash":"d6cd47ba4ab178269d9e7be773e521a3f74a738b","modified":1514384454734},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1514384454734},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1514384454734},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1514384454734},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1514384454734},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1514384454734},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1514384454734},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1514384454734},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1514384454744},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1514384454744},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1514384454744},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1514384454744},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1514384454744},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1514384454744},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1514384454744},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1514384454744},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1514384454744},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1514384454744},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1514384454744},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1514384454744},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1514384454744},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1514384454744},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1514384454744},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1514384454744},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1514384454744},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1514384454744},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1514384454744},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1514384454744},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1514384454744},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1514384454744},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1514384454744},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1514384454744},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1514384454744},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1514384454744},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1514384454744},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1514384454744},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1514384454744},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1514384454744},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1514384454744},{"_id":"public/js/src/utils.js","hash":"dbdc3d1300eec7da9632608ebc0e5b697779dad7","modified":1514384454744},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1514384454744},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1514384454744},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1514384454744},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1514384454744},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1514384454744},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1514384454744},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1514384454744},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1514384454744},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1514384454744},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1514384454744},{"_id":"public/css/main.css","hash":"72e53e34eee6acea996fb222c77975718cecfbd3","modified":1514384454744},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1514384454744},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1514384454744},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1514384454744},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1514384454744},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1514384454744},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1514384454744},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1514384454744},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1514384454744},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1514384454744},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1514384454744},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1514384454744},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1514384454744},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1514384454744},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1514384454744},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1514384454744},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1514384454744},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1514384454744},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1514384454744},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1514384454744},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1514384454744},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1514384454744},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1514384454754},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1514384454754},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1514384455010},{"_id":"public/images/avatar.jpg","hash":"a1b6b702dadfcf16d7e55b29db3f8cd15f2ab874","modified":1514384455376}],"Category":[{"name":"python学习","_id":"cjbp5ebzp0004iwtwm4nxdm5z"},{"name":"c++学习","_id":"cjbp5ec09000miwtw7v3u993o"},{"name":"工具们","parent":"cjbp5ebzp0004iwtwm4nxdm5z","_id":"cjbp5ec0t0016iwtwlucvn1jv"},{"name":"web学习整理","_id":"cjbp5ec13001jiwtw3wsryk2j"},{"name":"语言","_id":"cjbp5ec1d001qiwtwpj6qfwvf"},{"name":"操作系统","_id":"cjbp5ec1n002diwtwh30bixfx"},{"name":"工具们","_id":"cjbp5ec1x002liwtw97qksx8f"},{"name":"git","_id":"cjbp5ec27002uiwtw7gjhu8ow"},{"name":"机器学习","parent":"cjbp5ebzp0004iwtwm4nxdm5z","_id":"cjbp5ec270030iwtwx4d397lo"},{"name":"操作系统","parent":"cjbp5ec1x002liwtw97qksx8f","_id":"cjbp5ec2t003oiwtwgkkxr90b"},{"name":"机器学习","_id":"cjbp5ec2x003uiwtw2t76sgcm"},{"name":"工具们","parent":"cjbp5ec27002uiwtw7gjhu8ow","_id":"cjbp5ec330045iwtwj7a8rt8m"},{"name":"课程小结","_id":"cjbp5ec33004biwtwl26cayt6"}],"Data":[],"Page":[{"<!-- title":"关于我 -->","type":"about","date":"2017-12-09T13:24:55.000Z","comments":0,"_content":"\n![aboutme](http://p0stu0mm3.bkt.clouddn.com/about.jpg)","source":"about/index.md","raw":"---\n<!-- title: 关于我 -->\ntype: \"about\"\ndate: 2017-12-09 21:24:55\ncomments: false\n---\n\n![aboutme](http://p0stu0mm3.bkt.clouddn.com/about.jpg)","updated":"2017-12-11T13:41:52.580Z","path":"about/index.html","title":"","layout":"page","_id":"cjbp5ebzp0001iwtwfes6u25w","content":"<p><img src=\"http://p0stu0mm3.bkt.clouddn.com/about.jpg\" alt=\"aboutme\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://p0stu0mm3.bkt.clouddn.com/about.jpg\" alt=\"aboutme\"></p>\n"},{"title":"分类","date":"2017-12-09T14:12:33.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-12-09 22:12:33\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-12-09T14:15:20.264Z","path":"categories/index.html","layout":"page","_id":"cjbp5ebzp0003iwtwq98b75u7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"。","id":379,"comment":false,"date":"2017-11-24T01:59:34.000Z","_content":"\n[无人分享和吐槽，遂开此贴]\n\n# 志记\n\n* * *\n\n&nbsp;","source":"record/index.md","raw":"---\ntitle: 。\nid: 379\ncomment: false\ndate: 2017-11-24 09:59:34\n---\n\n[无人分享和吐槽，遂开此贴]\n\n# 志记\n\n* * *\n\n&nbsp;","updated":"2017-12-09T17:06:50.797Z","path":"record/index.html","comments":1,"layout":"page","_id":"cjbp5ebzp0006iwtwsjt0aaw4","content":"<p>[无人分享和吐槽，遂开此贴]</p>\n<h1 id=\"志记\"><a href=\"#志记\" class=\"headerlink\" title=\"志记\"></a>志记</h1><hr>\n<p>&nbsp;</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[无人分享和吐槽，遂开此贴]</p>\n<h1 id=\"志记\"><a href=\"#志记\" class=\"headerlink\" title=\"志记\"></a>志记</h1><hr>\n<p>&nbsp;</p>\n"},{"title":"标签","date":"2017-12-09T14:07:35.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-12-09 22:07:35\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-12-09T14:08:35.218Z","path":"tags/index.html","layout":"page","_id":"cjbp5ebzz0008iwtwn4lzcg7v","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"-","id":267,"comment":false,"date":"2017-08-02T15:11:37.000Z","_content":"\n:\n\n![](http://www.alanpro.win/wp-content/uploads/2017/08/wp-1493431453196.jpeg)\n\n晚上睡觉做梦笑醒了，看了一下时间是3.50，我起床刷了下手机。[8/16]\n\n游泳：13号游了500米；14号想着挑战下1000米，找到自己的节奏后，挑战成功；15号又想去游泳了，想着试试挑战1500米，游到800的时候觉得自己肯定游不完了，结果就抱着试试的心态，竟然游了1600米，大概是游到1200米以后疲倦的极限被打破了，反而游的更舒服更快了。[8/15]\n\n这几天成了信息的奴隶，时刻想着翻手机，看有没有新信息。[8/13]\n\n晚上和同学吃烧烤。喝了一瓶啤酒，有点酒精过敏，从小我就不是能喝酒的体质，一喝酒就上脸，现在喝酒还多了两个毛病，手掌有浮肿的感觉，胸前有一片红色的疹子。如果我有什么心事，该拿什么来消愁呢？[8/10]\n\n中午睡觉醒后，发现是被被冻醒的。昨天刚立秋，室外气温31度，室内25度。刚醒的几秒钟记得梦了什么，下床就忘了，只模糊的记得是什么我不想记得的事。[8/8]\n\n每个人都在忙着自己生活，如果有人能陪你做什么、和你分享什么，就是你生活中的锦上添花。[8/8]\n\n不以恶意揣测别人，不用善意幻想别人。如果总被别人的想法左右、影响的话，我注定是不快乐了。我想挣脱出来，特立独行[8/7]\n\n生活如果被放大一点就会变成梦，梦再被放大一点就成了剧本。[8/6]\n\n&nbsp;","source":"dairy/index.md","raw":"---\ntitle: '-'\nid: 267\ncomment: false\ndate: 2017-08-02 23:11:37\n---\n\n:\n\n![](http://www.alanpro.win/wp-content/uploads/2017/08/wp-1493431453196.jpeg)\n\n晚上睡觉做梦笑醒了，看了一下时间是3.50，我起床刷了下手机。[8/16]\n\n游泳：13号游了500米；14号想着挑战下1000米，找到自己的节奏后，挑战成功；15号又想去游泳了，想着试试挑战1500米，游到800的时候觉得自己肯定游不完了，结果就抱着试试的心态，竟然游了1600米，大概是游到1200米以后疲倦的极限被打破了，反而游的更舒服更快了。[8/15]\n\n这几天成了信息的奴隶，时刻想着翻手机，看有没有新信息。[8/13]\n\n晚上和同学吃烧烤。喝了一瓶啤酒，有点酒精过敏，从小我就不是能喝酒的体质，一喝酒就上脸，现在喝酒还多了两个毛病，手掌有浮肿的感觉，胸前有一片红色的疹子。如果我有什么心事，该拿什么来消愁呢？[8/10]\n\n中午睡觉醒后，发现是被被冻醒的。昨天刚立秋，室外气温31度，室内25度。刚醒的几秒钟记得梦了什么，下床就忘了，只模糊的记得是什么我不想记得的事。[8/8]\n\n每个人都在忙着自己生活，如果有人能陪你做什么、和你分享什么，就是你生活中的锦上添花。[8/8]\n\n不以恶意揣测别人，不用善意幻想别人。如果总被别人的想法左右、影响的话，我注定是不快乐了。我想挣脱出来，特立独行[8/7]\n\n生活如果被放大一点就会变成梦，梦再被放大一点就成了剧本。[8/6]\n\n&nbsp;","updated":"2017-12-09T17:06:50.797Z","path":"dairy/index.html","comments":1,"layout":"page","_id":"cjbp5ebzz000biwtw7thjrs36","content":"<p>:</p>\n<p><img src=\"http://www.alanpro.win/wp-content/uploads/2017/08/wp-1493431453196.jpeg\" alt=\"\"></p>\n<p>晚上睡觉做梦笑醒了，看了一下时间是3.50，我起床刷了下手机。[8/16]</p>\n<p>游泳：13号游了500米；14号想着挑战下1000米，找到自己的节奏后，挑战成功；15号又想去游泳了，想着试试挑战1500米，游到800的时候觉得自己肯定游不完了，结果就抱着试试的心态，竟然游了1600米，大概是游到1200米以后疲倦的极限被打破了，反而游的更舒服更快了。[8/15]</p>\n<p>这几天成了信息的奴隶，时刻想着翻手机，看有没有新信息。[8/13]</p>\n<p>晚上和同学吃烧烤。喝了一瓶啤酒，有点酒精过敏，从小我就不是能喝酒的体质，一喝酒就上脸，现在喝酒还多了两个毛病，手掌有浮肿的感觉，胸前有一片红色的疹子。如果我有什么心事，该拿什么来消愁呢？[8/10]</p>\n<p>中午睡觉醒后，发现是被被冻醒的。昨天刚立秋，室外气温31度，室内25度。刚醒的几秒钟记得梦了什么，下床就忘了，只模糊的记得是什么我不想记得的事。[8/8]</p>\n<p>每个人都在忙着自己生活，如果有人能陪你做什么、和你分享什么，就是你生活中的锦上添花。[8/8]</p>\n<p>不以恶意揣测别人，不用善意幻想别人。如果总被别人的想法左右、影响的话，我注定是不快乐了。我想挣脱出来，特立独行[8/7]</p>\n<p>生活如果被放大一点就会变成梦，梦再被放大一点就成了剧本。[8/6]</p>\n<p>&nbsp;</p>\n","site":{"data":{}},"excerpt":"","more":"<p>:</p>\n<p><img src=\"http://www.alanpro.win/wp-content/uploads/2017/08/wp-1493431453196.jpeg\" alt=\"\"></p>\n<p>晚上睡觉做梦笑醒了，看了一下时间是3.50，我起床刷了下手机。[8/16]</p>\n<p>游泳：13号游了500米；14号想着挑战下1000米，找到自己的节奏后，挑战成功；15号又想去游泳了，想着试试挑战1500米，游到800的时候觉得自己肯定游不完了，结果就抱着试试的心态，竟然游了1600米，大概是游到1200米以后疲倦的极限被打破了，反而游的更舒服更快了。[8/15]</p>\n<p>这几天成了信息的奴隶，时刻想着翻手机，看有没有新信息。[8/13]</p>\n<p>晚上和同学吃烧烤。喝了一瓶啤酒，有点酒精过敏，从小我就不是能喝酒的体质，一喝酒就上脸，现在喝酒还多了两个毛病，手掌有浮肿的感觉，胸前有一片红色的疹子。如果我有什么心事，该拿什么来消愁呢？[8/10]</p>\n<p>中午睡觉醒后，发现是被被冻醒的。昨天刚立秋，室外气温31度，室内25度。刚醒的几秒钟记得梦了什么，下床就忘了，只模糊的记得是什么我不想记得的事。[8/8]</p>\n<p>每个人都在忙着自己生活，如果有人能陪你做什么、和你分享什么，就是你生活中的锦上添花。[8/8]</p>\n<p>不以恶意揣测别人，不用善意幻想别人。如果总被别人的想法左右、影响的话，我注定是不快乐了。我想挣脱出来，特立独行[8/7]</p>\n<p>生活如果被放大一点就会变成梦，梦再被放大一点就成了剧本。[8/6]</p>\n<p>&nbsp;</p>\n"}],"Post":[{"title":"软件工程 复习","id":"193","_content":"","source":"_drafts/软件工程-复习.md","raw":"---\ntitle: 软件工程 复习\nid: 193\ncategories:\n  - python学习\ntags:\n---\n","slug":"软件工程-复习","published":0,"date":"2017-12-09T17:06:50.787Z","updated":"2017-12-09T17:06:50.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ebzf0000iwtw4yvl535d","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"C++标准库  顺序容器","id":"260","_content":"\n# 概述：\n\n所有容器类都共享公共的接口，不同容器按不同方式对其进行扩展。这个公共接口使容器的学习更加容易--我们基于某种容器所学习的内容也都适用于其他容器。每种容器都提供了不同的性能和功能的权衡。_**一个容器就是一些特定类型对象的集合**_。","source":"_drafts/C-标准库-顺序容器.md","raw":"---\ntitle: C++标准库  顺序容器\nid: 260\ncategories:\n  - python学习\ntags:\n---\n\n# 概述：\n\n所有容器类都共享公共的接口，不同容器按不同方式对其进行扩展。这个公共接口使容器的学习更加容易--我们基于某种容器所学习的内容也都适用于其他容器。每种容器都提供了不同的性能和功能的权衡。_**一个容器就是一些特定类型对象的集合**_。","slug":"C-标准库-顺序容器","published":0,"date":"2017-12-09T17:06:50.792Z","updated":"2017-12-09T17:06:50.798Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ebzp0002iwtwph9pejk8","content":"<h1 id=\"概述：\"><a href=\"#概述：\" class=\"headerlink\" title=\"概述：\"></a>概述：</h1><p>所有容器类都共享公共的接口，不同容器按不同方式对其进行扩展。这个公共接口使容器的学习更加容易–我们基于某种容器所学习的内容也都适用于其他容器。每种容器都提供了不同的性能和功能的权衡。<em><strong>一个容器就是一些特定类型对象的集合</strong></em>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"概述：\"><a href=\"#概述：\" class=\"headerlink\" title=\"概述：\"></a>概述：</h1><p>所有容器类都共享公共的接口，不同容器按不同方式对其进行扩展。这个公共接口使容器的学习更加容易–我们基于某种容器所学习的内容也都适用于其他容器。每种容器都提供了不同的性能和功能的权衡。<em><strong>一个容器就是一些特定类型对象的集合</strong></em>。</p>\n"},{"title":"anaconda环境命令笔记","id":"365","date":"2017-10-19T05:41:30.000Z","_content":"\n#环境：ubuntu16.04\nconda是anaconda下用于包管理和环境管理的工具，功能上类似pip和virtualenv的组合。安装成功后conda会默认加入到环境变量中，因此可以直接在命令行窗口运行命令conda<!--more-->\n\n#创建python3.6版本创建一个名字为python36的环境\nconda create --name python36 python=3.6\n\n#激活环境\nsource activate python36\n\n#查看python版本\npython -V\n\n#退出该环境\ndeactivate python36\n\n#删除该环境\nconda remove -n python --all\n\n#查看所有安装的环境\nconda info -e\n\nconda的包管理和pip一样：\n#安装matplotlib\nconda install matplotlib\n#查看所有安装了的包\nconda list\n#包更新\nconda update matplotlib\n#删除包\nconda remove matplotlib\n\n&nbsp;\n\n在conda中，anything is a package,conda本身也可以被看做是一个包，python环境也是一个包，anaconda也可以看做是一个包。因此除了普通的第三方包支持更新之外，这三个包也支持更新：\n#更新conda本身\nconda update conda\n#更新anaconda应用\nconda update anaconda\n#更新python\nconda python update","source":"_posts/anaconda-environment-notes.md","raw":"---\ntitle: anaconda环境命令笔记\nid: 365\ncategories:\n  - python学习\n  - 工具们\ndate: 2017-10-19 13:41:30\ntags:\n---\n\n#环境：ubuntu16.04\nconda是anaconda下用于包管理和环境管理的工具，功能上类似pip和virtualenv的组合。安装成功后conda会默认加入到环境变量中，因此可以直接在命令行窗口运行命令conda<!--more-->\n\n#创建python3.6版本创建一个名字为python36的环境\nconda create --name python36 python=3.6\n\n#激活环境\nsource activate python36\n\n#查看python版本\npython -V\n\n#退出该环境\ndeactivate python36\n\n#删除该环境\nconda remove -n python --all\n\n#查看所有安装的环境\nconda info -e\n\nconda的包管理和pip一样：\n#安装matplotlib\nconda install matplotlib\n#查看所有安装了的包\nconda list\n#包更新\nconda update matplotlib\n#删除包\nconda remove matplotlib\n\n&nbsp;\n\n在conda中，anything is a package,conda本身也可以被看做是一个包，python环境也是一个包，anaconda也可以看做是一个包。因此除了普通的第三方包支持更新之外，这三个包也支持更新：\n#更新conda本身\nconda update conda\n#更新anaconda应用\nconda update anaconda\n#更新python\nconda python update","slug":"anaconda-environment-notes","published":1,"updated":"2017-12-09T17:06:50.796Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ebzp0005iwtwar1ure2k","content":"<p>#环境：ubuntu16.04<br>conda是anaconda下用于包管理和环境管理的工具，功能上类似pip和virtualenv的组合。安装成功后conda会默认加入到环境变量中，因此可以直接在命令行窗口运行命令conda<a id=\"more\"></a></p>\n<p>#创建python3.6版本创建一个名字为python36的环境<br>conda create –name python36 python=3.6</p>\n<p>#激活环境<br>source activate python36</p>\n<p>#查看python版本<br>python -V</p>\n<p>#退出该环境<br>deactivate python36</p>\n<p>#删除该环境<br>conda remove -n python –all</p>\n<p>#查看所有安装的环境<br>conda info -e</p>\n<p>conda的包管理和pip一样：</p>\n<p>#安装matplotlib<br>conda install matplotlib</p>\n<p>#查看所有安装了的包<br>conda list</p>\n<p>#包更新<br>conda update matplotlib</p>\n<p>#删除包<br>conda remove matplotlib</p>\n<p>&nbsp;</p>\n<p>在conda中，anything is a package,conda本身也可以被看做是一个包，python环境也是一个包，anaconda也可以看做是一个包。因此除了普通的第三方包支持更新之外，这三个包也支持更新：</p>\n<p>#更新conda本身<br>conda update conda</p>\n<p>#更新anaconda应用<br>conda update anaconda</p>\n<p>#更新python<br>conda python update</p>\n","site":{"data":{}},"excerpt":"<p>#环境：ubuntu16.04<br>conda是anaconda下用于包管理和环境管理的工具，功能上类似pip和virtualenv的组合。安装成功后conda会默认加入到环境变量中，因此可以直接在命令行窗口运行命令conda","more":"</p>\n<p>#创建python3.6版本创建一个名字为python36的环境<br>conda create –name python36 python=3.6</p>\n<p>#激活环境<br>source activate python36</p>\n<p>#查看python版本<br>python -V</p>\n<p>#退出该环境<br>deactivate python36</p>\n<p>#删除该环境<br>conda remove -n python –all</p>\n<p>#查看所有安装的环境<br>conda info -e</p>\n<p>conda的包管理和pip一样：</p>\n<p>#安装matplotlib<br>conda install matplotlib</p>\n<p>#查看所有安装了的包<br>conda list</p>\n<p>#包更新<br>conda update matplotlib</p>\n<p>#删除包<br>conda remove matplotlib</p>\n<p>&nbsp;</p>\n<p>在conda中，anything is a package,conda本身也可以被看做是一个包，python环境也是一个包，anaconda也可以看做是一个包。因此除了普通的第三方包支持更新之外，这三个包也支持更新：</p>\n<p>#更新conda本身<br>conda update conda</p>\n<p>#更新anaconda应用<br>conda update anaconda</p>\n<p>#更新python<br>conda python update</p>"},{"title":"c++动态内存中 shared_ptr的理解","id":"269","date":"2017-08-03T09:20:46.000Z","_content":"\n新标准库中提供的智能指针shared_ptr允许多个指针通过一个对象。它也是<span style=\"color: #ff0000;\">模版</span>，因此我们才创建一个智能指针的时候必须要提供指针指向的类型。\n\n默认初始化的智能指针中存着一个空指针:shared_ptr&lt;string&gt; spt;就是一个指向空string的指针。<!--more-->\n\n### shared_ptr的拷贝和赋值：\n\n当进行拷贝或者赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：\n\nauto p=make_shared&lt;int&gt;(42);//p是指向值为42的int指针\n\nauto q(p);//p和q指向相同的对象，因此说这个对象有两个引用者。\n\n每个shared_ptr都有一个<span style=\"color: #ff0000;\">关联的计数器</span>（引用计数）。无论什么时候涉及到<span style=\"color: #ff0000;\">shared_ptr的拷贝时候，计数器都会递增</span>。当我们给shared_ptr赋新值或者是shared_ptr被销毁（离开局部作用域）计数器就会递减。当一个shared_ptr变为0的时候，就会自动释放它所指的对象。对于以上的q(p)构造q的过程，就是p的shared_ptr计数器递增1，也就是2；\n\np = r;//给p赋值，令它指向另外一个地址，r递增指向对象的计数。递减p所指对象的计数。而p所指对象的计数值为2，递减了仍然为1，所以它指向的那个对象不会被释放。此例子可以说明：<span style=\"color: #ff0000;\">引用计数是与对象绑定的，而不是指向该对象的某一个shared_ptr。</span>\n\n验证引用计数是与对象相关的代码：\n\n&nbsp;\n<pre>#include \n#include \nusing namespace std;\n\nint main(){\n\tauto p = make_shared(42);\n\tauto q(p);//此时p指向的对象有2个计数值\n\n\tauto r = make_shared(22);\n\n\tp = r;\n\n\tcout &lt;&lt; *q&lt;&lt;endl;\n\n\treturn 0;\n}\n</pre>","source":"_posts/c++-dynamic-memory-and-shared_ptr.md","raw":"---\ntitle: c++动态内存中 shared_ptr的理解\ntags:\n  - c++\nid: 269\ncategories:\n  - c++学习\ndate: 2017-08-03 17:20:46\n---\n\n新标准库中提供的智能指针shared_ptr允许多个指针通过一个对象。它也是<span style=\"color: #ff0000;\">模版</span>，因此我们才创建一个智能指针的时候必须要提供指针指向的类型。\n\n默认初始化的智能指针中存着一个空指针:shared_ptr&lt;string&gt; spt;就是一个指向空string的指针。<!--more-->\n\n### shared_ptr的拷贝和赋值：\n\n当进行拷贝或者赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：\n\nauto p=make_shared&lt;int&gt;(42);//p是指向值为42的int指针\n\nauto q(p);//p和q指向相同的对象，因此说这个对象有两个引用者。\n\n每个shared_ptr都有一个<span style=\"color: #ff0000;\">关联的计数器</span>（引用计数）。无论什么时候涉及到<span style=\"color: #ff0000;\">shared_ptr的拷贝时候，计数器都会递增</span>。当我们给shared_ptr赋新值或者是shared_ptr被销毁（离开局部作用域）计数器就会递减。当一个shared_ptr变为0的时候，就会自动释放它所指的对象。对于以上的q(p)构造q的过程，就是p的shared_ptr计数器递增1，也就是2；\n\np = r;//给p赋值，令它指向另外一个地址，r递增指向对象的计数。递减p所指对象的计数。而p所指对象的计数值为2，递减了仍然为1，所以它指向的那个对象不会被释放。此例子可以说明：<span style=\"color: #ff0000;\">引用计数是与对象绑定的，而不是指向该对象的某一个shared_ptr。</span>\n\n验证引用计数是与对象相关的代码：\n\n&nbsp;\n<pre>#include \n#include \nusing namespace std;\n\nint main(){\n\tauto p = make_shared(42);\n\tauto q(p);//此时p指向的对象有2个计数值\n\n\tauto r = make_shared(22);\n\n\tp = r;\n\n\tcout &lt;&lt; *q&lt;&lt;endl;\n\n\treturn 0;\n}\n</pre>","slug":"c++-dynamic-memory-and-shared_ptr","published":1,"updated":"2017-12-09T17:06:50.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ebzp0007iwtwv7fptep2","content":"<p>新标准库中提供的智能指针shared_ptr允许多个指针通过一个对象。它也是<span style=\"color: #ff0000;\">模版</span>，因此我们才创建一个智能指针的时候必须要提供指针指向的类型。</p>\n<p>默认初始化的智能指针中存着一个空指针:shared_ptr&lt;string&gt; spt;就是一个指向空string的指针。<a id=\"more\"></a></p>\n<h3 id=\"shared-ptr的拷贝和赋值：\"><a href=\"#shared-ptr的拷贝和赋值：\" class=\"headerlink\" title=\"shared_ptr的拷贝和赋值：\"></a>shared_ptr的拷贝和赋值：</h3><p>当进行拷贝或者赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：</p>\n<p>auto p=make_shared&lt;int&gt;(42);//p是指向值为42的int指针</p>\n<p>auto q(p);//p和q指向相同的对象，因此说这个对象有两个引用者。</p>\n<p>每个shared_ptr都有一个<span style=\"color: #ff0000;\">关联的计数器</span>（引用计数）。无论什么时候涉及到<span style=\"color: #ff0000;\">shared_ptr的拷贝时候，计数器都会递增</span>。当我们给shared_ptr赋新值或者是shared_ptr被销毁（离开局部作用域）计数器就会递减。当一个shared_ptr变为0的时候，就会自动释放它所指的对象。对于以上的q(p)构造q的过程，就是p的shared_ptr计数器递增1，也就是2；</p>\n<p>p = r;//给p赋值，令它指向另外一个地址，r递增指向对象的计数。递减p所指对象的计数。而p所指对象的计数值为2，递减了仍然为1，所以它指向的那个对象不会被释放。此例子可以说明：<span style=\"color: #ff0000;\">引用计数是与对象绑定的，而不是指向该对象的某一个shared_ptr。</span></p>\n<p>验证引用计数是与对象相关的代码：</p>\n<p>&nbsp;</p>\n<pre>#include \n#include \nusing namespace std;\n\nint main(){\n    auto p = make_shared(42);\n    auto q(p);//此时p指向的对象有2个计数值\n\n    auto r = make_shared(22);\n\n    p = r;\n\n    cout &lt;&lt; *q&lt;&lt;endl;\n\n    return 0;\n}\n</pre>","site":{"data":{}},"excerpt":"<p>新标准库中提供的智能指针shared_ptr允许多个指针通过一个对象。它也是<span style=\"color: #ff0000;\">模版</span>，因此我们才创建一个智能指针的时候必须要提供指针指向的类型。</p>\n<p>默认初始化的智能指针中存着一个空指针:shared_ptr&lt;string&gt; spt;就是一个指向空string的指针。","more":"</p>\n<h3 id=\"shared-ptr的拷贝和赋值：\"><a href=\"#shared-ptr的拷贝和赋值：\" class=\"headerlink\" title=\"shared_ptr的拷贝和赋值：\"></a>shared_ptr的拷贝和赋值：</h3><p>当进行拷贝或者赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：</p>\n<p>auto p=make_shared&lt;int&gt;(42);//p是指向值为42的int指针</p>\n<p>auto q(p);//p和q指向相同的对象，因此说这个对象有两个引用者。</p>\n<p>每个shared_ptr都有一个<span style=\"color: #ff0000;\">关联的计数器</span>（引用计数）。无论什么时候涉及到<span style=\"color: #ff0000;\">shared_ptr的拷贝时候，计数器都会递增</span>。当我们给shared_ptr赋新值或者是shared_ptr被销毁（离开局部作用域）计数器就会递减。当一个shared_ptr变为0的时候，就会自动释放它所指的对象。对于以上的q(p)构造q的过程，就是p的shared_ptr计数器递增1，也就是2；</p>\n<p>p = r;//给p赋值，令它指向另外一个地址，r递增指向对象的计数。递减p所指对象的计数。而p所指对象的计数值为2，递减了仍然为1，所以它指向的那个对象不会被释放。此例子可以说明：<span style=\"color: #ff0000;\">引用计数是与对象绑定的，而不是指向该对象的某一个shared_ptr。</span></p>\n<p>验证引用计数是与对象相关的代码：</p>\n<p>&nbsp;</p>\n<pre>#include \n#include \nusing namespace std;\n\nint main(){\n    auto p = make_shared(42);\n    auto q(p);//此时p指向的对象有2个计数值\n\n    auto r = make_shared(22);\n\n    p = r;\n\n    cout &lt;&lt; *q&lt;&lt;endl;\n\n    return 0;\n}\n</pre>"},{"title":"c++动态内存中 weak_ptr和unique_ptr","id":"276","date":"2017-08-04T14:40:28.000Z","_content":"\n## unique_ptr：\n\n一个unique_ptr拥有它所指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁的时候，它所指向的对象也被销毁。当我们定义一个unique_ptr时候，需要将其绑定到一个new 返回的指针（这一点很容易出错，如果不是绑定到new返回的指针，也就是不是动态分配的内存，那么编译器将会报出没有delete的错误）。初始化unique_ptr必须采用直接初始化形式。\n\n一个unique_ptr拥有它所保存的对象，因此unique_ptr<span style=\"color: #ff0000;\">不支持普通的</span>拷贝或赋值操作。<!--more-->\n\n虽然不能用普通的拷贝或者赋值，但是我们可以用它的成员函数，如：调用release或reset将指针的所有权从一个unique_ptr转移给另一个unique_ptr:\n\nunique_ptr&lt;string&gt; p2(p1.release());//把p1的指向所有权转移给p2\n\nunique_str&lt;string&gt; p3(new string(\"test\"));\n\np2.reset(p3.release());//将所有权从p2转移到p3，reset释放了p2 原来指向的内存\n\n注意：release成员返回unique_ptr当前保存的指针，并将自己置为空。因此p2被初始化为p1原来的指针，p1被置为nullptr\n\nreset成员接受一个可选的指针参数，令unique_ptr重新指向给定的指针。如果unique_ptr不指向空，则它原来指向的对象释放。因此p2调用reset释放了p1之前指向的对象的内存，将p3的控制权交给了p2，并将p3置为空。\n\n如果我们不用另外一个智能指针来保存release返回的指针，那么我们的程序就要自己负责释放它，否则就会造成泄漏：\n\np2.release();//p2不会释放内存，而且我们丢失了指针。造成了泄漏\n\n&nbsp;\n\n## weak_ptr:\n\nweake_ptr是一种不控制所指对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到shared_ptr不会影响shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就被释放。即使有weak_ptr指向对象，对象也会被释放，所以说它是一个“弱”指针。\n\nauto p = make_shared&lt;string&gt;(\"hello\");\n\nweak_ptr&lt;string&gt; wp(p);//wp弱共享p；p的引用计数没变\n\nwp指向的对象可能被释放掉。在使用前要用lock()来检查是否它所指的对象的use_count()为0，如果为0就返回一个空shared_ptr;反之返回它所指的shared_ptr\n\n&nbsp;","source":"_posts/c++-unique_ptr-and-weak_ptr.md","raw":"---\ntitle: c++动态内存中 weak_ptr和unique_ptr\nid: 276\ncategories:\n  - python学习\ndate: 2017-08-04 22:40:28\ntags:\n---\n\n## unique_ptr：\n\n一个unique_ptr拥有它所指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁的时候，它所指向的对象也被销毁。当我们定义一个unique_ptr时候，需要将其绑定到一个new 返回的指针（这一点很容易出错，如果不是绑定到new返回的指针，也就是不是动态分配的内存，那么编译器将会报出没有delete的错误）。初始化unique_ptr必须采用直接初始化形式。\n\n一个unique_ptr拥有它所保存的对象，因此unique_ptr<span style=\"color: #ff0000;\">不支持普通的</span>拷贝或赋值操作。<!--more-->\n\n虽然不能用普通的拷贝或者赋值，但是我们可以用它的成员函数，如：调用release或reset将指针的所有权从一个unique_ptr转移给另一个unique_ptr:\n\nunique_ptr&lt;string&gt; p2(p1.release());//把p1的指向所有权转移给p2\n\nunique_str&lt;string&gt; p3(new string(\"test\"));\n\np2.reset(p3.release());//将所有权从p2转移到p3，reset释放了p2 原来指向的内存\n\n注意：release成员返回unique_ptr当前保存的指针，并将自己置为空。因此p2被初始化为p1原来的指针，p1被置为nullptr\n\nreset成员接受一个可选的指针参数，令unique_ptr重新指向给定的指针。如果unique_ptr不指向空，则它原来指向的对象释放。因此p2调用reset释放了p1之前指向的对象的内存，将p3的控制权交给了p2，并将p3置为空。\n\n如果我们不用另外一个智能指针来保存release返回的指针，那么我们的程序就要自己负责释放它，否则就会造成泄漏：\n\np2.release();//p2不会释放内存，而且我们丢失了指针。造成了泄漏\n\n&nbsp;\n\n## weak_ptr:\n\nweake_ptr是一种不控制所指对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到shared_ptr不会影响shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就被释放。即使有weak_ptr指向对象，对象也会被释放，所以说它是一个“弱”指针。\n\nauto p = make_shared&lt;string&gt;(\"hello\");\n\nweak_ptr&lt;string&gt; wp(p);//wp弱共享p；p的引用计数没变\n\nwp指向的对象可能被释放掉。在使用前要用lock()来检查是否它所指的对象的use_count()为0，如果为0就返回一个空shared_ptr;反之返回它所指的shared_ptr\n\n&nbsp;","slug":"c++-unique_ptr-and-weak_ptr","published":1,"updated":"2017-12-27T14:18:03.443Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ebzz0009iwtw0s9677cf","content":"<h2 id=\"unique-ptr：\"><a href=\"#unique-ptr：\" class=\"headerlink\" title=\"unique_ptr：\"></a>unique_ptr：</h2><p>一个unique_ptr拥有它所指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁的时候，它所指向的对象也被销毁。当我们定义一个unique_ptr时候，需要将其绑定到一个new 返回的指针（这一点很容易出错，如果不是绑定到new返回的指针，也就是不是动态分配的内存，那么编译器将会报出没有delete的错误）。初始化unique_ptr必须采用直接初始化形式。</p>\n<p>一个unique_ptr拥有它所保存的对象，因此unique_ptr<span style=\"color: #ff0000;\">不支持普通的</span>拷贝或赋值操作。<a id=\"more\"></a></p>\n<p>虽然不能用普通的拷贝或者赋值，但是我们可以用它的成员函数，如：调用release或reset将指针的所有权从一个unique_ptr转移给另一个unique_ptr:</p>\n<p>unique_ptr&lt;string&gt; p2(p1.release());//把p1的指向所有权转移给p2</p>\n<p>unique_str&lt;string&gt; p3(new string(“test”));</p>\n<p>p2.reset(p3.release());//将所有权从p2转移到p3，reset释放了p2 原来指向的内存</p>\n<p>注意：release成员返回unique_ptr当前保存的指针，并将自己置为空。因此p2被初始化为p1原来的指针，p1被置为nullptr</p>\n<p>reset成员接受一个可选的指针参数，令unique_ptr重新指向给定的指针。如果unique_ptr不指向空，则它原来指向的对象释放。因此p2调用reset释放了p1之前指向的对象的内存，将p3的控制权交给了p2，并将p3置为空。</p>\n<p>如果我们不用另外一个智能指针来保存release返回的指针，那么我们的程序就要自己负责释放它，否则就会造成泄漏：</p>\n<p>p2.release();//p2不会释放内存，而且我们丢失了指针。造成了泄漏</p>\n<p>&nbsp;</p>\n<h2 id=\"weak-ptr\"><a href=\"#weak-ptr\" class=\"headerlink\" title=\"weak_ptr:\"></a>weak_ptr:</h2><p>weake_ptr是一种不控制所指对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到shared_ptr不会影响shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就被释放。即使有weak_ptr指向对象，对象也会被释放，所以说它是一个“弱”指针。</p>\n<p>auto p = make_shared&lt;string&gt;(“hello”);</p>\n<p>weak_ptr&lt;string&gt; wp(p);//wp弱共享p；p的引用计数没变</p>\n<p>wp指向的对象可能被释放掉。在使用前要用lock()来检查是否它所指的对象的use_count()为0，如果为0就返回一个空shared_ptr;反之返回它所指的shared_ptr</p>\n<p>&nbsp;</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"unique-ptr：\"><a href=\"#unique-ptr：\" class=\"headerlink\" title=\"unique_ptr：\"></a>unique_ptr：</h2><p>一个unique_ptr拥有它所指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁的时候，它所指向的对象也被销毁。当我们定义一个unique_ptr时候，需要将其绑定到一个new 返回的指针（这一点很容易出错，如果不是绑定到new返回的指针，也就是不是动态分配的内存，那么编译器将会报出没有delete的错误）。初始化unique_ptr必须采用直接初始化形式。</p>\n<p>一个unique_ptr拥有它所保存的对象，因此unique_ptr<span style=\"color: #ff0000;\">不支持普通的</span>拷贝或赋值操作。","more":"</p>\n<p>虽然不能用普通的拷贝或者赋值，但是我们可以用它的成员函数，如：调用release或reset将指针的所有权从一个unique_ptr转移给另一个unique_ptr:</p>\n<p>unique_ptr&lt;string&gt; p2(p1.release());//把p1的指向所有权转移给p2</p>\n<p>unique_str&lt;string&gt; p3(new string(“test”));</p>\n<p>p2.reset(p3.release());//将所有权从p2转移到p3，reset释放了p2 原来指向的内存</p>\n<p>注意：release成员返回unique_ptr当前保存的指针，并将自己置为空。因此p2被初始化为p1原来的指针，p1被置为nullptr</p>\n<p>reset成员接受一个可选的指针参数，令unique_ptr重新指向给定的指针。如果unique_ptr不指向空，则它原来指向的对象释放。因此p2调用reset释放了p1之前指向的对象的内存，将p3的控制权交给了p2，并将p3置为空。</p>\n<p>如果我们不用另外一个智能指针来保存release返回的指针，那么我们的程序就要自己负责释放它，否则就会造成泄漏：</p>\n<p>p2.release();//p2不会释放内存，而且我们丢失了指针。造成了泄漏</p>\n<p>&nbsp;</p>\n<h2 id=\"weak-ptr\"><a href=\"#weak-ptr\" class=\"headerlink\" title=\"weak_ptr:\"></a>weak_ptr:</h2><p>weake_ptr是一种不控制所指对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到shared_ptr不会影响shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就被释放。即使有weak_ptr指向对象，对象也会被释放，所以说它是一个“弱”指针。</p>\n<p>auto p = make_shared&lt;string&gt;(“hello”);</p>\n<p>weak_ptr&lt;string&gt; wp(p);//wp弱共享p；p的引用计数没变</p>\n<p>wp指向的对象可能被释放掉。在使用前要用lock()来检查是否它所指的对象的use_count()为0，如果为0就返回一个空shared_ptr;反之返回它所指的shared_ptr</p>\n<p>&nbsp;</p>"},{"title":"c++基础 变量和基本类型","id":"194","date":"2017-07-03T13:59:48.000Z","_content":"\n#  类型篇：\n\n一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个char的大小和一个机器字节一样\n\nc++语言规定，一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long 至少和一个long一样大。\n\n在算术表达式中不要使用char和bool，只有在存放字符或者布尔值时才使用它们。因为char在有些机器上是有符号的有些是无符号的，所以用char运算特别容易出问题。\n\n当一个算术表达式中既有无符号数又有int 值时，那个int值会自动转换成无符号数，把int转换成无符号数的过程和直接把int值赋值给无符号数的过程一样。<!--more-->\n例如：\n<pre>unsigned int u = 10;\n\nint i = -42;\n\ncout << i + i << endl;//输出-82，没问题\n\ncout << i +u << endl;//如果int是32位，输出4294967264.把负数转换成无符号数的过程类似于直接给无符号数赋一个负值，结果等于这个负数+无符号数的模\n\n</pre>\n\n### 对常量的引用：\n\n引用的类型必须与其所引用的对象的类型一致，但是有两个例外：\n\n1.  在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果可以转换成引用的类型即可：尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至一般表达式\n\n    *   int i = 42;\n    *   const int &amp;r1 = i;\n    *   const int &amp;r2 = 10;\n    *   const int &amp;r3 = i * 2;\n必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是常量未作限定。因为对象也可能是个非常量，所以允许通过其他路径改变它的值。\n\n_<span style=\"color: #ff0000;\">**tips：**</span>所谓的指向常量的指针和引用，不过是指针和引用“自以为是，一厢情愿”罢了，它们觉得自己指向或者绑定了常量，就自觉的不去改变它们，而干涉不了其他行为会不会改变它们了。_\n\n### 辨析：指向常量的指针 和 常量指针\n\n**指向常量的指针：**不能用于改变其所指对象的值，要想存放常量对象的地址，只能使用指向常量的指针：\n\nconst double pi = 3.14;\n\nconst double *ptr = &amp;pi;\n\n_**<span style=\"color: #ff0000;\">tip:</span>**_指针的类型必须与其所指的对象类型一致，但是有两个例外：\n\n允许令一个指向常量的指针指向一个非常量的对象：double d1 = 32; const double *ptr1 = &amp;d1;//但是不能通过ptr1来修改d1的值\n\n**常量指针：**指针是对象而引用不是，所以就像其他对象类型一样，允许把指针本身定为常量。常量指针必须初始化，并且一旦初始化之后，则它的值（存放在指针中的那个地址）就不能再改变，把*放在const前面 说明指针是一个常量:\n\nint num = 10;\n\nint *const cptr = &amp;num;//cptr指向num，并且cptr的指向不能改变了\n\n_**<span style=\"color: #ff0000;\">tip:</span>**_ 要弄清声明的含义最好从右往左阅读：例如：const int *const ptr = &amp;cnt; 离标识符ptr最近的是const,说明ptr是常量对象，对象的类型由其他类型说明符确定：下一个符号是*，说明ptr是一个常量指针，接下来是int说明了常量指针类型是int，最后的const说明了是指向常量的int类型的常量指针，也就是说ptr既不能改变cnt的值，也不能指向其他对象\n\n### 顶层const与底层const：（以前一直没有想通的问题）\n\n指针本身是一个对象，它又可以指向另一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词 **_顶层const表示指针本身是一个常量，底层const表示指针所指的对象是一个常量。_**\n\n更一般的：顶层const可以表示任意的对象是常量，底层const则只与指针和引用等复合类型的基本类型部分有关（因为只有他们是有指向或者绑定的对象的）\n\n比较特殊的是：指针类型既可以是顶层const又可以是底层const。\n\n在执行拷贝操作时，常量是顶层还是底层的区别明显：顶层const基本不受影响。而对于底层const，拷入拷出的对象必须具有相同的底层const资格（都要是底层，如果即是底层又是顶层，则忽略掉顶层），或者两个对象的数据类型可以转换。一般来说，非常量可以转成常量，反之则不行。\n\n&nbsp;\n\n### auto类型说明符\n\nc++11新标准引入了auto类型说明符，用它能够让编译器替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型，所以auto定义的变量必须要有初始值：auto item = val1 + val2;\n\n使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本类型，所以该语句中所有变量的初始基本数据类型都必须一样：\n\nauto siz= 10, pi = 3.14;//错误，siz和pi的类型不一样\n\n&nbsp;\n\n关于auto的应用：\n<pre><span style=\"color: #ff0000;\">**_tips：_**</span>auto一般会忽略掉顶层的const，同时底层const则会保留下来。默认绑定底层const（p62疑点）\n#include \nusing namespace std;\n\nint main(){\n\tint i = 0, &r = i;//r是int类型的引用，绑定i\n\tauto a = r;//a是一个整数，r是i的别名，而i是int\n\n\tconst int ci = i, &cr = ci;//ci是一个int常量，cr是常量引用，绑定的是ci\n\tauto b = ci;//ci是顶层const被忽略掉，所以b是int类型的普通变量\n\tauto c = cr;//c是一个整数，cr本身是ci，而ci是顶层const\n\tauto d = &i;//i是整数，&i是取地址，所以d是指向int的指针（整型的地址就是指向整数的指针）\n\tauto e = &ci;//e是指向整数常量的指针（ci对常量取地址是一种底层const）\n\n\tconst auto f = ci;//f是const类型的整数\n\tauto &g = ci;//g是对整数常量的引用，绑定到ci\n\tconst auto &j = 42;//可以为常量引用直接绑定字面值\n\n\ta = 42;\n\tb = 42;\n\tc = 42;\n\t*d = 42;\n\te = &ci;//e是指向整数常量的指针 \n\n\treturn 0;\n} \n</pre>\n\n### decltype和引用：\n\nint i = 42, *p = &amp;i, &amp;r = i;\n\ndecltype(r+0) b;//加法的结果是int，所以b是一个未初始化的int\n\ndecltype(*p) c;//错误，c是int&amp; ,而未初始化\n\nr是一个引用，decltype(r)的结果是引用类型。如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这个表达式的结果将是一个具体的值而非一个引用。\n\n另一方面，如果表达式的内容是解引用操作，则decltype将得到引用类型。解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此,decltype(*p)的结果类型就是int&amp;,而非int\n\ndecltype的结果类型与表达式形式密切相关。不加括号，得到的结果就是该变量的类型；如果给变量加一层或者多层括号，就会把它当作表达式。\n\n<span style=\"color: #ff0000;\">_**tips:**_</span>decltype((variable))结果永远是引用，而decltype(variable)只有当variable本身就是一个引用的时候才是引用\n\n&nbsp;\n\nauto和decltype区别\n\n#include <iostream>;\nusing namespace std;\n\nint global{};\nint& foo(){\nreturn global;\n}\n\nint main(){\ndecltype(foo()) a = foo();//a is int&;\nauto b = foo();//b is int\nb = 2;\n\ncout << \"a:\" << a <<endl;\ncout << \"b:\" << b <<endl;\n\ncout << \"-------------------\"<<endl;\n\ndecltype(foo()) c = foo();//c is int&.\nc = 10;\n\ncout << \"a:\" << a <<endl;\ncout << \"b:\" << b <<endl;\ncout << \"c:\" << c <<endl;\n\ncout << \"global:\" << global << endl;//c引用了foo()返回的global\n\nreturn 0;\n}\n\n7/13更新：一个重要的点： 设置一个类型为auto的引用时，初始值中的顶层常量属性依然保留（而不是丢弃顶层const）。比如：\n\nconst int ci = 10;\n\nauto &a = ci;//a这个时候就没有丢弃ci的顶层属性，所以a的类型是const int &a,绑定到ci","source":"_posts/c++-primary-variables.md","raw":"---\ntitle: c++基础 变量和基本类型\ntags:\n  - c++\nid: 194\ncategories:\n  - c++学习\ndate: 2017-07-03 21:59:48\n---\n\n#  类型篇：\n\n一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个char的大小和一个机器字节一样\n\nc++语言规定，一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long 至少和一个long一样大。\n\n在算术表达式中不要使用char和bool，只有在存放字符或者布尔值时才使用它们。因为char在有些机器上是有符号的有些是无符号的，所以用char运算特别容易出问题。\n\n当一个算术表达式中既有无符号数又有int 值时，那个int值会自动转换成无符号数，把int转换成无符号数的过程和直接把int值赋值给无符号数的过程一样。<!--more-->\n例如：\n<pre>unsigned int u = 10;\n\nint i = -42;\n\ncout << i + i << endl;//输出-82，没问题\n\ncout << i +u << endl;//如果int是32位，输出4294967264.把负数转换成无符号数的过程类似于直接给无符号数赋一个负值，结果等于这个负数+无符号数的模\n\n</pre>\n\n### 对常量的引用：\n\n引用的类型必须与其所引用的对象的类型一致，但是有两个例外：\n\n1.  在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果可以转换成引用的类型即可：尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至一般表达式\n\n    *   int i = 42;\n    *   const int &amp;r1 = i;\n    *   const int &amp;r2 = 10;\n    *   const int &amp;r3 = i * 2;\n必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是常量未作限定。因为对象也可能是个非常量，所以允许通过其他路径改变它的值。\n\n_<span style=\"color: #ff0000;\">**tips：**</span>所谓的指向常量的指针和引用，不过是指针和引用“自以为是，一厢情愿”罢了，它们觉得自己指向或者绑定了常量，就自觉的不去改变它们，而干涉不了其他行为会不会改变它们了。_\n\n### 辨析：指向常量的指针 和 常量指针\n\n**指向常量的指针：**不能用于改变其所指对象的值，要想存放常量对象的地址，只能使用指向常量的指针：\n\nconst double pi = 3.14;\n\nconst double *ptr = &amp;pi;\n\n_**<span style=\"color: #ff0000;\">tip:</span>**_指针的类型必须与其所指的对象类型一致，但是有两个例外：\n\n允许令一个指向常量的指针指向一个非常量的对象：double d1 = 32; const double *ptr1 = &amp;d1;//但是不能通过ptr1来修改d1的值\n\n**常量指针：**指针是对象而引用不是，所以就像其他对象类型一样，允许把指针本身定为常量。常量指针必须初始化，并且一旦初始化之后，则它的值（存放在指针中的那个地址）就不能再改变，把*放在const前面 说明指针是一个常量:\n\nint num = 10;\n\nint *const cptr = &amp;num;//cptr指向num，并且cptr的指向不能改变了\n\n_**<span style=\"color: #ff0000;\">tip:</span>**_ 要弄清声明的含义最好从右往左阅读：例如：const int *const ptr = &amp;cnt; 离标识符ptr最近的是const,说明ptr是常量对象，对象的类型由其他类型说明符确定：下一个符号是*，说明ptr是一个常量指针，接下来是int说明了常量指针类型是int，最后的const说明了是指向常量的int类型的常量指针，也就是说ptr既不能改变cnt的值，也不能指向其他对象\n\n### 顶层const与底层const：（以前一直没有想通的问题）\n\n指针本身是一个对象，它又可以指向另一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词 **_顶层const表示指针本身是一个常量，底层const表示指针所指的对象是一个常量。_**\n\n更一般的：顶层const可以表示任意的对象是常量，底层const则只与指针和引用等复合类型的基本类型部分有关（因为只有他们是有指向或者绑定的对象的）\n\n比较特殊的是：指针类型既可以是顶层const又可以是底层const。\n\n在执行拷贝操作时，常量是顶层还是底层的区别明显：顶层const基本不受影响。而对于底层const，拷入拷出的对象必须具有相同的底层const资格（都要是底层，如果即是底层又是顶层，则忽略掉顶层），或者两个对象的数据类型可以转换。一般来说，非常量可以转成常量，反之则不行。\n\n&nbsp;\n\n### auto类型说明符\n\nc++11新标准引入了auto类型说明符，用它能够让编译器替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型，所以auto定义的变量必须要有初始值：auto item = val1 + val2;\n\n使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本类型，所以该语句中所有变量的初始基本数据类型都必须一样：\n\nauto siz= 10, pi = 3.14;//错误，siz和pi的类型不一样\n\n&nbsp;\n\n关于auto的应用：\n<pre><span style=\"color: #ff0000;\">**_tips：_**</span>auto一般会忽略掉顶层的const，同时底层const则会保留下来。默认绑定底层const（p62疑点）\n#include \nusing namespace std;\n\nint main(){\n\tint i = 0, &r = i;//r是int类型的引用，绑定i\n\tauto a = r;//a是一个整数，r是i的别名，而i是int\n\n\tconst int ci = i, &cr = ci;//ci是一个int常量，cr是常量引用，绑定的是ci\n\tauto b = ci;//ci是顶层const被忽略掉，所以b是int类型的普通变量\n\tauto c = cr;//c是一个整数，cr本身是ci，而ci是顶层const\n\tauto d = &i;//i是整数，&i是取地址，所以d是指向int的指针（整型的地址就是指向整数的指针）\n\tauto e = &ci;//e是指向整数常量的指针（ci对常量取地址是一种底层const）\n\n\tconst auto f = ci;//f是const类型的整数\n\tauto &g = ci;//g是对整数常量的引用，绑定到ci\n\tconst auto &j = 42;//可以为常量引用直接绑定字面值\n\n\ta = 42;\n\tb = 42;\n\tc = 42;\n\t*d = 42;\n\te = &ci;//e是指向整数常量的指针 \n\n\treturn 0;\n} \n</pre>\n\n### decltype和引用：\n\nint i = 42, *p = &amp;i, &amp;r = i;\n\ndecltype(r+0) b;//加法的结果是int，所以b是一个未初始化的int\n\ndecltype(*p) c;//错误，c是int&amp; ,而未初始化\n\nr是一个引用，decltype(r)的结果是引用类型。如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这个表达式的结果将是一个具体的值而非一个引用。\n\n另一方面，如果表达式的内容是解引用操作，则decltype将得到引用类型。解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此,decltype(*p)的结果类型就是int&amp;,而非int\n\ndecltype的结果类型与表达式形式密切相关。不加括号，得到的结果就是该变量的类型；如果给变量加一层或者多层括号，就会把它当作表达式。\n\n<span style=\"color: #ff0000;\">_**tips:**_</span>decltype((variable))结果永远是引用，而decltype(variable)只有当variable本身就是一个引用的时候才是引用\n\n&nbsp;\n\nauto和decltype区别\n\n#include <iostream>;\nusing namespace std;\n\nint global{};\nint& foo(){\nreturn global;\n}\n\nint main(){\ndecltype(foo()) a = foo();//a is int&;\nauto b = foo();//b is int\nb = 2;\n\ncout << \"a:\" << a <<endl;\ncout << \"b:\" << b <<endl;\n\ncout << \"-------------------\"<<endl;\n\ndecltype(foo()) c = foo();//c is int&.\nc = 10;\n\ncout << \"a:\" << a <<endl;\ncout << \"b:\" << b <<endl;\ncout << \"c:\" << c <<endl;\n\ncout << \"global:\" << global << endl;//c引用了foo()返回的global\n\nreturn 0;\n}\n\n7/13更新：一个重要的点： 设置一个类型为auto的引用时，初始值中的顶层常量属性依然保留（而不是丢弃顶层const）。比如：\n\nconst int ci = 10;\n\nauto &a = ci;//a这个时候就没有丢弃ci的顶层属性，所以a的类型是const int &a,绑定到ci","slug":"c++-primary-variables","published":1,"updated":"2017-12-09T17:06:50.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ebzz000diwtw3m2aclkx","content":"<h1 id=\"类型篇：\"><a href=\"#类型篇：\" class=\"headerlink\" title=\"类型篇：\"></a>类型篇：</h1><p>一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个char的大小和一个机器字节一样</p>\n<p>c++语言规定，一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long 至少和一个long一样大。</p>\n<p>在算术表达式中不要使用char和bool，只有在存放字符或者布尔值时才使用它们。因为char在有些机器上是有符号的有些是无符号的，所以用char运算特别容易出问题。</p>\n<p>当一个算术表达式中既有无符号数又有int 值时，那个int值会自动转换成无符号数，把int转换成无符号数的过程和直接把int值赋值给无符号数的过程一样。<a id=\"more\"></a><br>例如：</p>\n<pre>unsigned int u = 10;\n\nint i = -42;\n\ncout << i + i << endl;//输出-82，没问题\n\ncout << i +u << endl;//如果int是32位，输出4294967264.把负数转换成无符号数的过程类似于直接给无符号数赋一个负值，结果等于这个负数+无符号数的模\n\n</pre>\n\n<h3 id=\"对常量的引用：\"><a href=\"#对常量的引用：\" class=\"headerlink\" title=\"对常量的引用：\"></a>对常量的引用：</h3><p>引用的类型必须与其所引用的对象的类型一致，但是有两个例外：</p>\n<ol>\n<li><p>在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果可以转换成引用的类型即可：尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至一般表达式</p>\n<ul>\n<li>int i = 42;</li>\n<li>const int &amp;r1 = i;</li>\n<li>const int &amp;r2 = 10;</li>\n<li>const int &amp;r3 = i * 2;<br>必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是常量未作限定。因为对象也可能是个非常量，所以允许通过其他路径改变它的值。</li>\n</ul>\n</li>\n</ol>\n<p><em><span style=\"color: #ff0000;\"><strong>tips：</strong></span>所谓的指向常量的指针和引用，不过是指针和引用“自以为是，一厢情愿”罢了，它们觉得自己指向或者绑定了常量，就自觉的不去改变它们，而干涉不了其他行为会不会改变它们了。</em></p>\n<h3 id=\"辨析：指向常量的指针-和-常量指针\"><a href=\"#辨析：指向常量的指针-和-常量指针\" class=\"headerlink\" title=\"辨析：指向常量的指针 和 常量指针\"></a>辨析：指向常量的指针 和 常量指针</h3><p><strong>指向常量的指针：</strong>不能用于改变其所指对象的值，要想存放常量对象的地址，只能使用指向常量的指针：</p>\n<p>const double pi = 3.14;</p>\n<p>const double *ptr = &amp;pi;</p>\n<p><em><strong><span style=\"color: #ff0000;\">tip:</span></strong></em>指针的类型必须与其所指的对象类型一致，但是有两个例外：</p>\n<p>允许令一个指向常量的指针指向一个非常量的对象：double d1 = 32; const double *ptr1 = &amp;d1;//但是不能通过ptr1来修改d1的值</p>\n<p><strong>常量指针：</strong>指针是对象而引用不是，所以就像其他对象类型一样，允许把指针本身定为常量。常量指针必须初始化，并且一旦初始化之后，则它的值（存放在指针中的那个地址）就不能再改变，把*放在const前面 说明指针是一个常量:</p>\n<p>int num = 10;</p>\n<p>int *const cptr = &amp;num;//cptr指向num，并且cptr的指向不能改变了</p>\n<p><em><strong><span style=\"color: #ff0000;\">tip:</span></strong></em> 要弄清声明的含义最好从右往左阅读：例如：const int <em>const ptr = &amp;cnt; 离标识符ptr最近的是const,说明ptr是常量对象，对象的类型由其他类型说明符确定：下一个符号是</em>，说明ptr是一个常量指针，接下来是int说明了常量指针类型是int，最后的const说明了是指向常量的int类型的常量指针，也就是说ptr既不能改变cnt的值，也不能指向其他对象</p>\n<h3 id=\"顶层const与底层const：（以前一直没有想通的问题）\"><a href=\"#顶层const与底层const：（以前一直没有想通的问题）\" class=\"headerlink\" title=\"顶层const与底层const：（以前一直没有想通的问题）\"></a>顶层const与底层const：（以前一直没有想通的问题）</h3><p>指针本身是一个对象，它又可以指向另一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词 <strong><em>顶层const表示指针本身是一个常量，底层const表示指针所指的对象是一个常量。</em></strong></p>\n<p>更一般的：顶层const可以表示任意的对象是常量，底层const则只与指针和引用等复合类型的基本类型部分有关（因为只有他们是有指向或者绑定的对象的）</p>\n<p>比较特殊的是：指针类型既可以是顶层const又可以是底层const。</p>\n<p>在执行拷贝操作时，常量是顶层还是底层的区别明显：顶层const基本不受影响。而对于底层const，拷入拷出的对象必须具有相同的底层const资格（都要是底层，如果即是底层又是顶层，则忽略掉顶层），或者两个对象的数据类型可以转换。一般来说，非常量可以转成常量，反之则不行。</p>\n<p>&nbsp;</p>\n<h3 id=\"auto类型说明符\"><a href=\"#auto类型说明符\" class=\"headerlink\" title=\"auto类型说明符\"></a>auto类型说明符</h3><p>c++11新标准引入了auto类型说明符，用它能够让编译器替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型，所以auto定义的变量必须要有初始值：auto item = val1 + val2;</p>\n<p>使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本类型，所以该语句中所有变量的初始基本数据类型都必须一样：</p>\n<p>auto siz= 10, pi = 3.14;//错误，siz和pi的类型不一样</p>\n<p>&nbsp;</p>\n<p>关于auto的应用：</p>\n<pre><span style=\"color: #ff0000;\">**_tips：_**</span>auto一般会忽略掉顶层的const，同时底层const则会保留下来。默认绑定底层const（p62疑点）\n#include \nusing namespace std;\n\nint main(){\n    int i = 0, &r = i;//r是int类型的引用，绑定i\n    auto a = r;//a是一个整数，r是i的别名，而i是int\n\n    const int ci = i, &cr = ci;//ci是一个int常量，cr是常量引用，绑定的是ci\n    auto b = ci;//ci是顶层const被忽略掉，所以b是int类型的普通变量\n    auto c = cr;//c是一个整数，cr本身是ci，而ci是顶层const\n    auto d = &i;//i是整数，&i是取地址，所以d是指向int的指针（整型的地址就是指向整数的指针）\n    auto e = &ci;//e是指向整数常量的指针（ci对常量取地址是一种底层const）\n\n    const auto f = ci;//f是const类型的整数\n    auto &g = ci;//g是对整数常量的引用，绑定到ci\n    const auto &j = 42;//可以为常量引用直接绑定字面值\n\n    a = 42;\n    b = 42;\n    c = 42;\n    *d = 42;\n    e = &ci;//e是指向整数常量的指针 \n\n    return 0;\n} \n</pre>\n\n<h3 id=\"decltype和引用：\"><a href=\"#decltype和引用：\" class=\"headerlink\" title=\"decltype和引用：\"></a>decltype和引用：</h3><p>int i = 42, *p = &amp;i, &amp;r = i;</p>\n<p>decltype(r+0) b;//加法的结果是int，所以b是一个未初始化的int</p>\n<p>decltype(*p) c;//错误，c是int&amp; ,而未初始化</p>\n<p>r是一个引用，decltype(r)的结果是引用类型。如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这个表达式的结果将是一个具体的值而非一个引用。</p>\n<p>另一方面，如果表达式的内容是解引用操作，则decltype将得到引用类型。解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此,decltype(*p)的结果类型就是int&amp;,而非int</p>\n<p>decltype的结果类型与表达式形式密切相关。不加括号，得到的结果就是该变量的类型；如果给变量加一层或者多层括号，就会把它当作表达式。</p>\n<p><span style=\"color: #ff0000;\"><em><strong>tips:</strong></em></span>decltype((variable))结果永远是引用，而decltype(variable)只有当variable本身就是一个引用的时候才是引用</p>\n<p>&nbsp;</p>\n<p>auto和decltype区别</p>\n<p>#include <iostream>;<br>using namespace std;</iostream></p>\n<p>int global{};<br>int&amp; foo(){<br>return global;<br>}</p>\n<p>int main(){<br>decltype(foo()) a = foo();//a is int&amp;;<br>auto b = foo();//b is int<br>b = 2;</p>\n<p>cout &lt;&lt; “a:” &lt;&lt; a &lt;&lt;endl;<br>cout &lt;&lt; “b:” &lt;&lt; b &lt;&lt;endl;</p>\n<p>cout &lt;&lt; “——————-“&lt;&lt;endl;</p>\n<p>decltype(foo()) c = foo();//c is int&amp;.<br>c = 10;</p>\n<p>cout &lt;&lt; “a:” &lt;&lt; a &lt;&lt;endl;<br>cout &lt;&lt; “b:” &lt;&lt; b &lt;&lt;endl;<br>cout &lt;&lt; “c:” &lt;&lt; c &lt;&lt;endl;</p>\n<p>cout &lt;&lt; “global:” &lt;&lt; global &lt;&lt; endl;//c引用了foo()返回的global</p>\n<p>return 0;<br>}</p>\n<p>7/13更新：一个重要的点： 设置一个类型为auto的引用时，初始值中的顶层常量属性依然保留（而不是丢弃顶层const）。比如：</p>\n<p>const int ci = 10;</p>\n<p>auto &amp;a = ci;//a这个时候就没有丢弃ci的顶层属性，所以a的类型是const int &amp;a,绑定到ci</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"类型篇：\"><a href=\"#类型篇：\" class=\"headerlink\" title=\"类型篇：\"></a>类型篇：</h1><p>一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个char的大小和一个机器字节一样</p>\n<p>c++语言规定，一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long 至少和一个long一样大。</p>\n<p>在算术表达式中不要使用char和bool，只有在存放字符或者布尔值时才使用它们。因为char在有些机器上是有符号的有些是无符号的，所以用char运算特别容易出问题。</p>\n<p>当一个算术表达式中既有无符号数又有int 值时，那个int值会自动转换成无符号数，把int转换成无符号数的过程和直接把int值赋值给无符号数的过程一样。","more":"<br>例如：</p>\n<pre>unsigned int u = 10;\n\nint i = -42;\n\ncout << i + i << endl;//输出-82，没问题\n\ncout << i +u << endl;//如果int是32位，输出4294967264.把负数转换成无符号数的过程类似于直接给无符号数赋一个负值，结果等于这个负数+无符号数的模\n\n</pre>\n\n<h3 id=\"对常量的引用：\"><a href=\"#对常量的引用：\" class=\"headerlink\" title=\"对常量的引用：\"></a>对常量的引用：</h3><p>引用的类型必须与其所引用的对象的类型一致，但是有两个例外：</p>\n<ol>\n<li><p>在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果可以转换成引用的类型即可：尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至一般表达式</p>\n<ul>\n<li>int i = 42;</li>\n<li>const int &amp;r1 = i;</li>\n<li>const int &amp;r2 = 10;</li>\n<li>const int &amp;r3 = i * 2;<br>必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是常量未作限定。因为对象也可能是个非常量，所以允许通过其他路径改变它的值。</li>\n</ul>\n</li>\n</ol>\n<p><em><span style=\"color: #ff0000;\"><strong>tips：</strong></span>所谓的指向常量的指针和引用，不过是指针和引用“自以为是，一厢情愿”罢了，它们觉得自己指向或者绑定了常量，就自觉的不去改变它们，而干涉不了其他行为会不会改变它们了。</em></p>\n<h3 id=\"辨析：指向常量的指针-和-常量指针\"><a href=\"#辨析：指向常量的指针-和-常量指针\" class=\"headerlink\" title=\"辨析：指向常量的指针 和 常量指针\"></a>辨析：指向常量的指针 和 常量指针</h3><p><strong>指向常量的指针：</strong>不能用于改变其所指对象的值，要想存放常量对象的地址，只能使用指向常量的指针：</p>\n<p>const double pi = 3.14;</p>\n<p>const double *ptr = &amp;pi;</p>\n<p><em><strong><span style=\"color: #ff0000;\">tip:</span></strong></em>指针的类型必须与其所指的对象类型一致，但是有两个例外：</p>\n<p>允许令一个指向常量的指针指向一个非常量的对象：double d1 = 32; const double *ptr1 = &amp;d1;//但是不能通过ptr1来修改d1的值</p>\n<p><strong>常量指针：</strong>指针是对象而引用不是，所以就像其他对象类型一样，允许把指针本身定为常量。常量指针必须初始化，并且一旦初始化之后，则它的值（存放在指针中的那个地址）就不能再改变，把*放在const前面 说明指针是一个常量:</p>\n<p>int num = 10;</p>\n<p>int *const cptr = &amp;num;//cptr指向num，并且cptr的指向不能改变了</p>\n<p><em><strong><span style=\"color: #ff0000;\">tip:</span></strong></em> 要弄清声明的含义最好从右往左阅读：例如：const int <em>const ptr = &amp;cnt; 离标识符ptr最近的是const,说明ptr是常量对象，对象的类型由其他类型说明符确定：下一个符号是</em>，说明ptr是一个常量指针，接下来是int说明了常量指针类型是int，最后的const说明了是指向常量的int类型的常量指针，也就是说ptr既不能改变cnt的值，也不能指向其他对象</p>\n<h3 id=\"顶层const与底层const：（以前一直没有想通的问题）\"><a href=\"#顶层const与底层const：（以前一直没有想通的问题）\" class=\"headerlink\" title=\"顶层const与底层const：（以前一直没有想通的问题）\"></a>顶层const与底层const：（以前一直没有想通的问题）</h3><p>指针本身是一个对象，它又可以指向另一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词 <strong><em>顶层const表示指针本身是一个常量，底层const表示指针所指的对象是一个常量。</em></strong></p>\n<p>更一般的：顶层const可以表示任意的对象是常量，底层const则只与指针和引用等复合类型的基本类型部分有关（因为只有他们是有指向或者绑定的对象的）</p>\n<p>比较特殊的是：指针类型既可以是顶层const又可以是底层const。</p>\n<p>在执行拷贝操作时，常量是顶层还是底层的区别明显：顶层const基本不受影响。而对于底层const，拷入拷出的对象必须具有相同的底层const资格（都要是底层，如果即是底层又是顶层，则忽略掉顶层），或者两个对象的数据类型可以转换。一般来说，非常量可以转成常量，反之则不行。</p>\n<p>&nbsp;</p>\n<h3 id=\"auto类型说明符\"><a href=\"#auto类型说明符\" class=\"headerlink\" title=\"auto类型说明符\"></a>auto类型说明符</h3><p>c++11新标准引入了auto类型说明符，用它能够让编译器替我们去分析表达式所属的类型。auto让编译器通过初始值来推算变量的类型，所以auto定义的变量必须要有初始值：auto item = val1 + val2;</p>\n<p>使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本类型，所以该语句中所有变量的初始基本数据类型都必须一样：</p>\n<p>auto siz= 10, pi = 3.14;//错误，siz和pi的类型不一样</p>\n<p>&nbsp;</p>\n<p>关于auto的应用：</p>\n<pre><span style=\"color: #ff0000;\">**_tips：_**</span>auto一般会忽略掉顶层的const，同时底层const则会保留下来。默认绑定底层const（p62疑点）\n#include \nusing namespace std;\n\nint main(){\n    int i = 0, &r = i;//r是int类型的引用，绑定i\n    auto a = r;//a是一个整数，r是i的别名，而i是int\n\n    const int ci = i, &cr = ci;//ci是一个int常量，cr是常量引用，绑定的是ci\n    auto b = ci;//ci是顶层const被忽略掉，所以b是int类型的普通变量\n    auto c = cr;//c是一个整数，cr本身是ci，而ci是顶层const\n    auto d = &i;//i是整数，&i是取地址，所以d是指向int的指针（整型的地址就是指向整数的指针）\n    auto e = &ci;//e是指向整数常量的指针（ci对常量取地址是一种底层const）\n\n    const auto f = ci;//f是const类型的整数\n    auto &g = ci;//g是对整数常量的引用，绑定到ci\n    const auto &j = 42;//可以为常量引用直接绑定字面值\n\n    a = 42;\n    b = 42;\n    c = 42;\n    *d = 42;\n    e = &ci;//e是指向整数常量的指针 \n\n    return 0;\n} \n</pre>\n\n<h3 id=\"decltype和引用：\"><a href=\"#decltype和引用：\" class=\"headerlink\" title=\"decltype和引用：\"></a>decltype和引用：</h3><p>int i = 42, *p = &amp;i, &amp;r = i;</p>\n<p>decltype(r+0) b;//加法的结果是int，所以b是一个未初始化的int</p>\n<p>decltype(*p) c;//错误，c是int&amp; ,而未初始化</p>\n<p>r是一个引用，decltype(r)的结果是引用类型。如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这个表达式的结果将是一个具体的值而非一个引用。</p>\n<p>另一方面，如果表达式的内容是解引用操作，则decltype将得到引用类型。解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此,decltype(*p)的结果类型就是int&amp;,而非int</p>\n<p>decltype的结果类型与表达式形式密切相关。不加括号，得到的结果就是该变量的类型；如果给变量加一层或者多层括号，就会把它当作表达式。</p>\n<p><span style=\"color: #ff0000;\"><em><strong>tips:</strong></em></span>decltype((variable))结果永远是引用，而decltype(variable)只有当variable本身就是一个引用的时候才是引用</p>\n<p>&nbsp;</p>\n<p>auto和decltype区别</p>\n<p>#include <iostream>;<br>using namespace std;</iostream></p>\n<p>int global{};<br>int&amp; foo(){<br>return global;<br>}</p>\n<p>int main(){<br>decltype(foo()) a = foo();//a is int&amp;;<br>auto b = foo();//b is int<br>b = 2;</p>\n<p>cout &lt;&lt; “a:” &lt;&lt; a &lt;&lt;endl;<br>cout &lt;&lt; “b:” &lt;&lt; b &lt;&lt;endl;</p>\n<p>cout &lt;&lt; “——————-“&lt;&lt;endl;</p>\n<p>decltype(foo()) c = foo();//c is int&amp;.<br>c = 10;</p>\n<p>cout &lt;&lt; “a:” &lt;&lt; a &lt;&lt;endl;<br>cout &lt;&lt; “b:” &lt;&lt; b &lt;&lt;endl;<br>cout &lt;&lt; “c:” &lt;&lt; c &lt;&lt;endl;</p>\n<p>cout &lt;&lt; “global:” &lt;&lt; global &lt;&lt; endl;//c引用了foo()返回的global</p>\n<p>return 0;<br>}</p>\n<p>7/13更新：一个重要的点： 设置一个类型为auto的引用时，初始值中的顶层常量属性依然保留（而不是丢弃顶层const）。比如：</p>\n<p>const int ci = 10;</p>\n<p>auto &amp;a = ci;//a这个时候就没有丢弃ci的顶层属性，所以a的类型是const int &amp;a,绑定到ci</p>"},{"title":"别人口中的真理，在你这可能不成立","id":"113","_content":"\n上学期看了高晓松的《晓松奇谈》的一期节目，叫《白衣飘飘的年代》。晓松讲了那个时代的大学和大学生，正好讲那期节目的时候也是校园民谣出现20周年。那个时代的校园民谣都是风花雪月的骚柔，又有激情又有温柔。晓松讲那个时代的大学生很勇敢，勇敢追求自己爱的人，爱的事。因为勇敢，所以单纯，所以纯粹。\n而我现在所处在的这个时代和大学，仿佛充满了犹豫、等待和纠结，充满了金钱和利益，总想着怎样才能获得更大的利益更大的名气，这哪里像大学。我曾经幻想过的大学是有歌有酒有爱情，有泪有汗水的地方，而已经体验了快一半的大学生活了，这些东西很少出现。仿佛周围的老师都在说，努力学习好好学专业课，到时候就能找个好工作，工资多少多少。这仿佛磨灭了年轻人的激情和梦想，没有让我们去思考我们真正的梦想是什么。学习当然重要，专业课也得学好，但是这些只是生活的一部分，生活就得让自己快快乐乐高高兴兴地按照自己的想法去做事。","source":"_drafts/别人口中的真理，在你这可能不成立.md","raw":"---\ntitle: 别人口中的真理，在你这可能不成立\ntags:\n  - 生活记录\nid: 113\n---\n\n上学期看了高晓松的《晓松奇谈》的一期节目，叫《白衣飘飘的年代》。晓松讲了那个时代的大学和大学生，正好讲那期节目的时候也是校园民谣出现20周年。那个时代的校园民谣都是风花雪月的骚柔，又有激情又有温柔。晓松讲那个时代的大学生很勇敢，勇敢追求自己爱的人，爱的事。因为勇敢，所以单纯，所以纯粹。\n而我现在所处在的这个时代和大学，仿佛充满了犹豫、等待和纠结，充满了金钱和利益，总想着怎样才能获得更大的利益更大的名气，这哪里像大学。我曾经幻想过的大学是有歌有酒有爱情，有泪有汗水的地方，而已经体验了快一半的大学生活了，这些东西很少出现。仿佛周围的老师都在说，努力学习好好学专业课，到时候就能找个好工作，工资多少多少。这仿佛磨灭了年轻人的激情和梦想，没有让我们去思考我们真正的梦想是什么。学习当然重要，专业课也得学好，但是这些只是生活的一部分，生活就得让自己快快乐乐高高兴兴地按照自己的想法去做事。","slug":"别人口中的真理，在你这可能不成立","published":0,"date":"2017-12-09T17:06:50.792Z","updated":"2017-12-09T17:06:50.798Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec09000eiwtwzu2ausls","content":"<p>上学期看了高晓松的《晓松奇谈》的一期节目，叫《白衣飘飘的年代》。晓松讲了那个时代的大学和大学生，正好讲那期节目的时候也是校园民谣出现20周年。那个时代的校园民谣都是风花雪月的骚柔，又有激情又有温柔。晓松讲那个时代的大学生很勇敢，勇敢追求自己爱的人，爱的事。因为勇敢，所以单纯，所以纯粹。<br>而我现在所处在的这个时代和大学，仿佛充满了犹豫、等待和纠结，充满了金钱和利益，总想着怎样才能获得更大的利益更大的名气，这哪里像大学。我曾经幻想过的大学是有歌有酒有爱情，有泪有汗水的地方，而已经体验了快一半的大学生活了，这些东西很少出现。仿佛周围的老师都在说，努力学习好好学专业课，到时候就能找个好工作，工资多少多少。这仿佛磨灭了年轻人的激情和梦想，没有让我们去思考我们真正的梦想是什么。学习当然重要，专业课也得学好，但是这些只是生活的一部分，生活就得让自己快快乐乐高高兴兴地按照自己的想法去做事。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上学期看了高晓松的《晓松奇谈》的一期节目，叫《白衣飘飘的年代》。晓松讲了那个时代的大学和大学生，正好讲那期节目的时候也是校园民谣出现20周年。那个时代的校园民谣都是风花雪月的骚柔，又有激情又有温柔。晓松讲那个时代的大学生很勇敢，勇敢追求自己爱的人，爱的事。因为勇敢，所以单纯，所以纯粹。<br>而我现在所处在的这个时代和大学，仿佛充满了犹豫、等待和纠结，充满了金钱和利益，总想着怎样才能获得更大的利益更大的名气，这哪里像大学。我曾经幻想过的大学是有歌有酒有爱情，有泪有汗水的地方，而已经体验了快一半的大学生活了，这些东西很少出现。仿佛周围的老师都在说，努力学习好好学专业课，到时候就能找个好工作，工资多少多少。这仿佛磨灭了年轻人的激情和梦想，没有让我们去思考我们真正的梦想是什么。学习当然重要，专业课也得学好，但是这些只是生活的一部分，生活就得让自己快快乐乐高高兴兴地按照自己的想法去做事。</p>\n"},{"title":"c++基础 字符串、向量和数组","id":"228","date":"2017-07-13T05:07:52.000Z","_content":"\n<del>_**遗留问题：范围for循环迭代指针**_</del>\n\n作用域操作符（::）的含义：编译器从操作符左侧所示的作用域中寻找右侧那个名字。因此std::cin是要使用命名空间std中的名字cin\n\nstring s;\n\ncin &gt;&gt; s;\n\n在执行读取操作时，string对象会自动忽略开头的空白，并从第一个真正的字符开始读，直到碰到下一个空白为止；\n\n要想得到的字符串中保留输入时的空白符，应该用getline。和输入运算符一样，getline也会返回它的流参数。触发getline函数返回的那个换行符实际上被丢弃了，得到的string对象中不包含该换行符<!--more-->\n\nstring::size_type类，string类以及其他大多数标准库类型都定义了几种配套的类型。这些配套类型都体现了标准库类型和机器无关的特性。在具体使用的时候，通过作用域操作符来表明名字size_type是在类string中定义的。\n\n尽管string::size_type的类型有点神秘，但是在c++11标准中，允许编译器通过auto或者decltype来推断变量的类型。\n\n<span style=\"color: #ff0000;\">_**tips：**_</span>如果一条表达式中已经有了size()函数就不要再使用int类型了，这样可以避免混用int和unsigned引发的问题了\n\n### 字面值和string对象相加：\n\nc++中字符串字面值并不是标准库类型string的对象。**切记：字符串字面值和string是不同的类型。**\n\n**_标准库允许把字符字面值和字符串字面值转换成string。当把string对象和字符字面值或者字符串字面值混在一条语句中使用时，必须确保每个加法运算符的两侧的运算对象至少有一个是string_**\n\n&nbsp;\n\n下标运算符[]接受的输入参数是string::size_type类型的值，这个参数表示要访问的字符的位置，<span style=\"color: #ff0000;\">返回值是该位置上字符的引用</span>\n\n_#include &lt;iostream&gt;_\n_using namespace std;_\n_#include &lt;cctype&gt;_\n_int main(){_\n_ string s = \"hello,world\";_\n\n_ for (decltype(s.size()) index = 0; index != s.size() &amp;&amp; !ispunct(s[index]); ++index){_\n_ s[index] = toupper(s[index]);_\n_ }_\n_ //&amp;&amp;运算符有屏蔽作用，如果&amp;&amp;前是真才会看&amp;&amp;后的逻辑判断，也就是说只有index在范围内，才会检查s[index] _\n_ cout &lt;&lt; s&lt;&lt;endl;_\n_ return 0;_\n_}_\n\n_**<span style=\"color: #ff0000;\">tips：</span>**_c++标准库并不要求标准库检查下标是否合法，所以一旦使用了一个超出范围的下标，就会产生不可预估的后果。那么在使用前用string::size_type的index在size()范围内来保证下标的合法性！！\n\n&nbsp;\n\n_**<span style=\"color: #ff0000;\">tips:</span>**_在类内初始值的初始化时候，只能用花括号或者放在等号右边。如：struct Node{int x=0; int y{0}; };\n\nc++语言提供了几种不同的初始化方式，在大多数情况下这些初始化方式可以相互等价地使用。但是有几个例外情况：\n\n1.  使用拷贝初始化的时候（用=号的时候），只能提供一个初始值\n2.  提供的是一个类内初始化，则只能用花括号｛｝和拷贝初始化（=）\n3.  如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，这不能放在花括号里。\n泛型编程：只有string和vector等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有的标准库容器的迭代器都定义了==和！=，但是它们大多数都没有定义&lt;运算符，因此推荐使用==和!=运算符，这样就不用管是哪种容器类型了。\n\n&nbsp;\n\n虽然vector对象可以动态地增长，但是也会有一些副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素，比如push_back都会使该vector对象的迭代器失效。\n\n迭代器的加减：只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓的距离就是右侧的迭代器向前移动多少个单位就能追上左侧的迭代器，其类型名是difference_type,因为这个距离可负可正，所以difference_type是带符号型的；\n\n&nbsp;\n\n_**<span style=\"color: #ff0000;\">字符数组的特殊性：</span>**_字符数组有一种额外的初始化形式，可以用字符串字面值来对此类数组初始化。当使用这种方式的时候，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串其他字符一样被拷贝到字符数组中去。char a[6]=\"hello!\"，就是错误的，因为hello!是6个字符，还有一个'\\0'会被填入，却因为数组开小了 失败。\n\n&nbsp;\n\n_**<span style=\"color: #ff0000;\">初始化与不初始化：</span>**_\n\n例子:\n\nunsigned scores[11];//没有初始化，scores中的值都是由它们所在的位置来确定，所以都是垃圾值。不初始化可能会造成不可估量的错误，往往这种错误也不好找\n\nunsigned grade[11]={};//用花括号初始化，grade内元素的值都是0；\n\n&nbsp;\n\n**_<span style=\"color: #ff6600;\">数组与指针的关系很紧密，但是又不可以等价：</span>_**\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main(){\nint ia[] = {1,2,3,4,5,6};\ndecltype(ia) ia1;//经过decltype(array)得到的是数组（另外开辟的内存空间）\ncout &lt;&lt; sizeof(ia)&lt;&lt;endl;//24\ncout &lt;&lt; sizeof(ia1)&lt;&lt;endl;//24\n\nauto ia2 = ia;\ncout &lt;&lt; *ia2;//经过auto得到的是数组ia的首地址。\nreturn 0;\n}\n\n<span style=\"color: #ff6600;\">我的理解是：数组是开辟的一块内存，而指针只是存某一单位的内存地址的对象。auto将数组翻译成指针，并且这个指针存的是数组的首地址。而decltype将数组仍然翻译成数组，也就另外开辟内存空间了的。总的来说，decltype比auto更具体</span>\n\n&nbsp;\n\n<span style=\"color: #ff0000;\">_**下标和指针：**_</span>\n\n很多情况下使用数组名字其实用的是一个指向数组首元素的指针。当对数组使用下标运算符的时候，编译器会自动执行上述转换操作，比如：\n\nint a[10]={};\n\nint b = a[2];//&lt;=&gt;*(a+2)，a是数组的首地址\n\n只要指针指向的是数组中的元素，都可以执行下标运算：\n\nint *p=&amp;ia[2];\n\nint j = p[1];//等价于ia[3];\n\nint k = p[-2];//等价于ia[0];\n\n标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。内置的下标运算符可以处理负值。\n\n&nbsp;\n\n_**<span style=\"color: #ff0000;\">使用范围for循环处理多维数组需要注意的点：</span>**_\n\n&nbsp;\n\n&nbsp;\n<pre>#include \nusing namespace std;\n\nint main(){\nint ia[3][4]={0};\nsize_t cnt = 0;\n\nfor (auto &amp;row : ia){\nfor (auto &amp;col : row){\ncol = cnt;\ncnt++;\n}\n}\n\nfor (const auto &amp;row : ia){\nfor (auto col : row){\ncout &lt;&lt; col &lt;&lt; endl;\n}\n}\nreturn 0;\n}\n\n</pre>\n上面的例子中，因为要改变数组的值，所以要选用引用类型作为循环控制变量。但是其实有个更深层次的原因促使我们这么多：在第二个嵌套for循环中，没有任何写操作，只有读操作，可是我们还是将外层循环的控制变量声明成了引用类型。<span style=\"color: #ff0000;\">这是为了避免数组自动被转换成指针类型。</span>\n\n举个栗子：\n\nfor(auto row:ia){\n\nfor(auto rol:row){}}\n\n将无法通过编译。因为像之前一样第一个循环遍历ia的所有元素，这些元素实际上是大小为4的数组。因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素转换成指向该数组内首元素的指针。这样得到的row的类型就是int*，显然内层循环就不合法。\n\n<span style=\"color: #ff0000;\">_**指针数组和数组指针的辨别：**_</span>\n\nint *ip[4];//整型指针数组\n\nint (*ip)[4];//指向含有4个整数的数组\n\n&nbsp;\n\nc++11标准中通过auto和decltype就能尽可能地避免在数组前面加上一个指针类型了：\n\n//输出ia中每个元素的值，每个内层数组各占一行\n\n//版本1：\n\nint ia[3][4]={0};\n\nfor(auto p=ia; p!=ia+3; ++p){\n\nfor (auto q = *p; q != *p + 4; ++q){\n\ncout &lt;&lt; *q &lt;&lt;endl;}\n\ncout &lt;&lt; endl;\n\n}\n\n//版本2:这个版本中，循环终止条件由end函数负责判断。虽然我们可以推断出p是指向含有4个整数的数组的指针，q是指向整数的指针，但是使用auto我们就不用关系到底是什么类型了\n\nfor (auto p = begin(ia); p != end(ia); ++p){\n\nfor (auto q = begin(*p); q != end(*p); ++q){\n\ncout &lt;&lt; *q &lt;&lt;endl;}\n\ncout &lt;&lt; endl;\n\n}\n\n//版本3：使用类型别名来简化;程序将类型“4个整数组成的数组”命名为int_array\n\nusing int_array = int[4];//typedef int int_array[4];\n\nfor (int_array *p = ia; p != ia + 3; ++p){\n\nfor (int *q = *p; q != *p + 4; ++q){\n\ncout &lt;&lt; *q &lt;&lt;endl;}\n\ncout &lt;&lt;endl;\n\n}","source":"_posts/c-e5-9f-ba-e7-a1-80-e5-ad-97-e7-ac-a6-e4-b8-b2-e3-80-81-e5-90-91-e9-87-8f-e5-92-8c-e6-95-b0-e7-bb-84.md","raw":"---\ntitle: c++基础 字符串、向量和数组\ntags:\n  - c++\nid: 228\ncategories:\n  - c++学习\ndate: 2017-07-13 13:07:52\n---\n\n<del>_**遗留问题：范围for循环迭代指针**_</del>\n\n作用域操作符（::）的含义：编译器从操作符左侧所示的作用域中寻找右侧那个名字。因此std::cin是要使用命名空间std中的名字cin\n\nstring s;\n\ncin &gt;&gt; s;\n\n在执行读取操作时，string对象会自动忽略开头的空白，并从第一个真正的字符开始读，直到碰到下一个空白为止；\n\n要想得到的字符串中保留输入时的空白符，应该用getline。和输入运算符一样，getline也会返回它的流参数。触发getline函数返回的那个换行符实际上被丢弃了，得到的string对象中不包含该换行符<!--more-->\n\nstring::size_type类，string类以及其他大多数标准库类型都定义了几种配套的类型。这些配套类型都体现了标准库类型和机器无关的特性。在具体使用的时候，通过作用域操作符来表明名字size_type是在类string中定义的。\n\n尽管string::size_type的类型有点神秘，但是在c++11标准中，允许编译器通过auto或者decltype来推断变量的类型。\n\n<span style=\"color: #ff0000;\">_**tips：**_</span>如果一条表达式中已经有了size()函数就不要再使用int类型了，这样可以避免混用int和unsigned引发的问题了\n\n### 字面值和string对象相加：\n\nc++中字符串字面值并不是标准库类型string的对象。**切记：字符串字面值和string是不同的类型。**\n\n**_标准库允许把字符字面值和字符串字面值转换成string。当把string对象和字符字面值或者字符串字面值混在一条语句中使用时，必须确保每个加法运算符的两侧的运算对象至少有一个是string_**\n\n&nbsp;\n\n下标运算符[]接受的输入参数是string::size_type类型的值，这个参数表示要访问的字符的位置，<span style=\"color: #ff0000;\">返回值是该位置上字符的引用</span>\n\n_#include &lt;iostream&gt;_\n_using namespace std;_\n_#include &lt;cctype&gt;_\n_int main(){_\n_ string s = \"hello,world\";_\n\n_ for (decltype(s.size()) index = 0; index != s.size() &amp;&amp; !ispunct(s[index]); ++index){_\n_ s[index] = toupper(s[index]);_\n_ }_\n_ //&amp;&amp;运算符有屏蔽作用，如果&amp;&amp;前是真才会看&amp;&amp;后的逻辑判断，也就是说只有index在范围内，才会检查s[index] _\n_ cout &lt;&lt; s&lt;&lt;endl;_\n_ return 0;_\n_}_\n\n_**<span style=\"color: #ff0000;\">tips：</span>**_c++标准库并不要求标准库检查下标是否合法，所以一旦使用了一个超出范围的下标，就会产生不可预估的后果。那么在使用前用string::size_type的index在size()范围内来保证下标的合法性！！\n\n&nbsp;\n\n_**<span style=\"color: #ff0000;\">tips:</span>**_在类内初始值的初始化时候，只能用花括号或者放在等号右边。如：struct Node{int x=0; int y{0}; };\n\nc++语言提供了几种不同的初始化方式，在大多数情况下这些初始化方式可以相互等价地使用。但是有几个例外情况：\n\n1.  使用拷贝初始化的时候（用=号的时候），只能提供一个初始值\n2.  提供的是一个类内初始化，则只能用花括号｛｝和拷贝初始化（=）\n3.  如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，这不能放在花括号里。\n泛型编程：只有string和vector等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有的标准库容器的迭代器都定义了==和！=，但是它们大多数都没有定义&lt;运算符，因此推荐使用==和!=运算符，这样就不用管是哪种容器类型了。\n\n&nbsp;\n\n虽然vector对象可以动态地增长，但是也会有一些副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素，比如push_back都会使该vector对象的迭代器失效。\n\n迭代器的加减：只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓的距离就是右侧的迭代器向前移动多少个单位就能追上左侧的迭代器，其类型名是difference_type,因为这个距离可负可正，所以difference_type是带符号型的；\n\n&nbsp;\n\n_**<span style=\"color: #ff0000;\">字符数组的特殊性：</span>**_字符数组有一种额外的初始化形式，可以用字符串字面值来对此类数组初始化。当使用这种方式的时候，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串其他字符一样被拷贝到字符数组中去。char a[6]=\"hello!\"，就是错误的，因为hello!是6个字符，还有一个'\\0'会被填入，却因为数组开小了 失败。\n\n&nbsp;\n\n_**<span style=\"color: #ff0000;\">初始化与不初始化：</span>**_\n\n例子:\n\nunsigned scores[11];//没有初始化，scores中的值都是由它们所在的位置来确定，所以都是垃圾值。不初始化可能会造成不可估量的错误，往往这种错误也不好找\n\nunsigned grade[11]={};//用花括号初始化，grade内元素的值都是0；\n\n&nbsp;\n\n**_<span style=\"color: #ff6600;\">数组与指针的关系很紧密，但是又不可以等价：</span>_**\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main(){\nint ia[] = {1,2,3,4,5,6};\ndecltype(ia) ia1;//经过decltype(array)得到的是数组（另外开辟的内存空间）\ncout &lt;&lt; sizeof(ia)&lt;&lt;endl;//24\ncout &lt;&lt; sizeof(ia1)&lt;&lt;endl;//24\n\nauto ia2 = ia;\ncout &lt;&lt; *ia2;//经过auto得到的是数组ia的首地址。\nreturn 0;\n}\n\n<span style=\"color: #ff6600;\">我的理解是：数组是开辟的一块内存，而指针只是存某一单位的内存地址的对象。auto将数组翻译成指针，并且这个指针存的是数组的首地址。而decltype将数组仍然翻译成数组，也就另外开辟内存空间了的。总的来说，decltype比auto更具体</span>\n\n&nbsp;\n\n<span style=\"color: #ff0000;\">_**下标和指针：**_</span>\n\n很多情况下使用数组名字其实用的是一个指向数组首元素的指针。当对数组使用下标运算符的时候，编译器会自动执行上述转换操作，比如：\n\nint a[10]={};\n\nint b = a[2];//&lt;=&gt;*(a+2)，a是数组的首地址\n\n只要指针指向的是数组中的元素，都可以执行下标运算：\n\nint *p=&amp;ia[2];\n\nint j = p[1];//等价于ia[3];\n\nint k = p[-2];//等价于ia[0];\n\n标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。内置的下标运算符可以处理负值。\n\n&nbsp;\n\n_**<span style=\"color: #ff0000;\">使用范围for循环处理多维数组需要注意的点：</span>**_\n\n&nbsp;\n\n&nbsp;\n<pre>#include \nusing namespace std;\n\nint main(){\nint ia[3][4]={0};\nsize_t cnt = 0;\n\nfor (auto &amp;row : ia){\nfor (auto &amp;col : row){\ncol = cnt;\ncnt++;\n}\n}\n\nfor (const auto &amp;row : ia){\nfor (auto col : row){\ncout &lt;&lt; col &lt;&lt; endl;\n}\n}\nreturn 0;\n}\n\n</pre>\n上面的例子中，因为要改变数组的值，所以要选用引用类型作为循环控制变量。但是其实有个更深层次的原因促使我们这么多：在第二个嵌套for循环中，没有任何写操作，只有读操作，可是我们还是将外层循环的控制变量声明成了引用类型。<span style=\"color: #ff0000;\">这是为了避免数组自动被转换成指针类型。</span>\n\n举个栗子：\n\nfor(auto row:ia){\n\nfor(auto rol:row){}}\n\n将无法通过编译。因为像之前一样第一个循环遍历ia的所有元素，这些元素实际上是大小为4的数组。因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素转换成指向该数组内首元素的指针。这样得到的row的类型就是int*，显然内层循环就不合法。\n\n<span style=\"color: #ff0000;\">_**指针数组和数组指针的辨别：**_</span>\n\nint *ip[4];//整型指针数组\n\nint (*ip)[4];//指向含有4个整数的数组\n\n&nbsp;\n\nc++11标准中通过auto和decltype就能尽可能地避免在数组前面加上一个指针类型了：\n\n//输出ia中每个元素的值，每个内层数组各占一行\n\n//版本1：\n\nint ia[3][4]={0};\n\nfor(auto p=ia; p!=ia+3; ++p){\n\nfor (auto q = *p; q != *p + 4; ++q){\n\ncout &lt;&lt; *q &lt;&lt;endl;}\n\ncout &lt;&lt; endl;\n\n}\n\n//版本2:这个版本中，循环终止条件由end函数负责判断。虽然我们可以推断出p是指向含有4个整数的数组的指针，q是指向整数的指针，但是使用auto我们就不用关系到底是什么类型了\n\nfor (auto p = begin(ia); p != end(ia); ++p){\n\nfor (auto q = begin(*p); q != end(*p); ++q){\n\ncout &lt;&lt; *q &lt;&lt;endl;}\n\ncout &lt;&lt; endl;\n\n}\n\n//版本3：使用类型别名来简化;程序将类型“4个整数组成的数组”命名为int_array\n\nusing int_array = int[4];//typedef int int_array[4];\n\nfor (int_array *p = ia; p != ia + 3; ++p){\n\nfor (int *q = *p; q != *p + 4; ++q){\n\ncout &lt;&lt; *q &lt;&lt;endl;}\n\ncout &lt;&lt;endl;\n\n}","slug":"c-e5-9f-ba-e7-a1-80-e5-ad-97-e7-ac-a6-e4-b8-b2-e3-80-81-e5-90-91-e9-87-8f-e5-92-8c-e6-95-b0-e7-bb-84","published":1,"updated":"2017-12-09T17:06:50.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec09000hiwtwahc21luc","content":"<p><del><em><strong>遗留问题：范围for循环迭代指针</strong></em></del></p>\n<p>作用域操作符（::）的含义：编译器从操作符左侧所示的作用域中寻找右侧那个名字。因此std::cin是要使用命名空间std中的名字cin</p>\n<p>string s;</p>\n<p>cin &gt;&gt; s;</p>\n<p>在执行读取操作时，string对象会自动忽略开头的空白，并从第一个真正的字符开始读，直到碰到下一个空白为止；</p>\n<p>要想得到的字符串中保留输入时的空白符，应该用getline。和输入运算符一样，getline也会返回它的流参数。触发getline函数返回的那个换行符实际上被丢弃了，得到的string对象中不包含该换行符<a id=\"more\"></a></p>\n<p>string::size_type类，string类以及其他大多数标准库类型都定义了几种配套的类型。这些配套类型都体现了标准库类型和机器无关的特性。在具体使用的时候，通过作用域操作符来表明名字size_type是在类string中定义的。</p>\n<p>尽管string::size_type的类型有点神秘，但是在c++11标准中，允许编译器通过auto或者decltype来推断变量的类型。</p>\n<p><span style=\"color: #ff0000;\"><em><strong>tips：</strong></em></span>如果一条表达式中已经有了size()函数就不要再使用int类型了，这样可以避免混用int和unsigned引发的问题了</p>\n<h3 id=\"字面值和string对象相加：\"><a href=\"#字面值和string对象相加：\" class=\"headerlink\" title=\"字面值和string对象相加：\"></a>字面值和string对象相加：</h3><p>c++中字符串字面值并不是标准库类型string的对象。<strong>切记：字符串字面值和string是不同的类型。</strong></p>\n<p><strong><em>标准库允许把字符字面值和字符串字面值转换成string。当把string对象和字符字面值或者字符串字面值混在一条语句中使用时，必须确保每个加法运算符的两侧的运算对象至少有一个是string</em></strong></p>\n<p>&nbsp;</p>\n<p>下标运算符[]接受的输入参数是string::size_type类型的值，这个参数表示要访问的字符的位置，<span style=\"color: #ff0000;\">返回值是该位置上字符的引用</span></p>\n<p><em>#include &lt;iostream&gt;</em><br><em>using namespace std;</em><br><em>#include &lt;cctype&gt;</em><br><em>int main(){</em><br><em> string s = “hello,world”;</em></p>\n<p><em> for (decltype(s.size()) index = 0; index != s.size() &amp;&amp; !ispunct(s[index]); ++index){</em><br><em> s[index] = toupper(s[index]);</em><br><em> }</em><br><em> //&amp;&amp;运算符有屏蔽作用，如果&amp;&amp;前是真才会看&amp;&amp;后的逻辑判断，也就是说只有index在范围内，才会检查s[index] </em><br><em> cout &lt;&lt; s&lt;&lt;endl;</em><br><em> return 0;</em><br><em>}</em></p>\n<p>_<strong><span style=\"color: #ff0000;\">tips：</span></strong>_c++标准库并不要求标准库检查下标是否合法，所以一旦使用了一个超出范围的下标，就会产生不可预估的后果。那么在使用前用string::size_type的index在size()范围内来保证下标的合法性！！</p>\n<p>&nbsp;</p>\n<p><em><strong><span style=\"color: #ff0000;\">tips:</span></strong></em>在类内初始值的初始化时候，只能用花括号或者放在等号右边。如：struct Node{int x=0; int y{0}; };</p>\n<p>c++语言提供了几种不同的初始化方式，在大多数情况下这些初始化方式可以相互等价地使用。但是有几个例外情况：</p>\n<ol>\n<li>使用拷贝初始化的时候（用=号的时候），只能提供一个初始值</li>\n<li>提供的是一个类内初始化，则只能用花括号｛｝和拷贝初始化（=）</li>\n<li>如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，这不能放在花括号里。<br>泛型编程：只有string和vector等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有的标准库容器的迭代器都定义了==和！=，但是它们大多数都没有定义&lt;运算符，因此推荐使用==和!=运算符，这样就不用管是哪种容器类型了。</li>\n</ol>\n<p>&nbsp;</p>\n<p>虽然vector对象可以动态地增长，但是也会有一些副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素，比如push_back都会使该vector对象的迭代器失效。</p>\n<p>迭代器的加减：只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓的距离就是右侧的迭代器向前移动多少个单位就能追上左侧的迭代器，其类型名是difference_type,因为这个距离可负可正，所以difference_type是带符号型的；</p>\n<p>&nbsp;</p>\n<p><em><strong><span style=\"color: #ff0000;\">字符数组的特殊性：</span></strong></em>字符数组有一种额外的初始化形式，可以用字符串字面值来对此类数组初始化。当使用这种方式的时候，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串其他字符一样被拷贝到字符数组中去。char a[6]=”hello!”，就是错误的，因为hello!是6个字符，还有一个’\\0’会被填入，却因为数组开小了 失败。</p>\n<p>&nbsp;</p>\n<p><em><strong><span style=\"color: #ff0000;\">初始化与不初始化：</span></strong></em></p>\n<p>例子:</p>\n<p>unsigned scores[11];//没有初始化，scores中的值都是由它们所在的位置来确定，所以都是垃圾值。不初始化可能会造成不可估量的错误，往往这种错误也不好找</p>\n<p>unsigned grade[11]={};//用花括号初始化，grade内元素的值都是0；</p>\n<p>&nbsp;</p>\n<p><strong><em><span style=\"color: #ff6600;\">数组与指针的关系很紧密，但是又不可以等价：</span></em></strong></p>\n<p>#include &lt;iostream&gt;<br>using namespace std;</p>\n<p>int main(){<br>int ia[] = {1,2,3,4,5,6};<br>decltype(ia) ia1;//经过decltype(array)得到的是数组（另外开辟的内存空间）<br>cout &lt;&lt; sizeof(ia)&lt;&lt;endl;//24<br>cout &lt;&lt; sizeof(ia1)&lt;&lt;endl;//24</p>\n<p>auto ia2 = ia;<br>cout &lt;&lt; *ia2;//经过auto得到的是数组ia的首地址。<br>return 0;<br>}</p>\n<p><span style=\"color: #ff6600;\">我的理解是：数组是开辟的一块内存，而指针只是存某一单位的内存地址的对象。auto将数组翻译成指针，并且这个指针存的是数组的首地址。而decltype将数组仍然翻译成数组，也就另外开辟内存空间了的。总的来说，decltype比auto更具体</span></p>\n<p>&nbsp;</p>\n<p><span style=\"color: #ff0000;\"><em><strong>下标和指针：</strong></em></span></p>\n<p>很多情况下使用数组名字其实用的是一个指向数组首元素的指针。当对数组使用下标运算符的时候，编译器会自动执行上述转换操作，比如：</p>\n<p>int a[10]={};</p>\n<p>int b = a[2];//&lt;=&gt;*(a+2)，a是数组的首地址</p>\n<p>只要指针指向的是数组中的元素，都可以执行下标运算：</p>\n<p>int *p=&amp;ia[2];</p>\n<p>int j = p[1];//等价于ia[3];</p>\n<p>int k = p[-2];//等价于ia[0];</p>\n<p>标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。内置的下标运算符可以处理负值。</p>\n<p>&nbsp;</p>\n<p><em><strong><span style=\"color: #ff0000;\">使用范围for循环处理多维数组需要注意的点：</span></strong></em></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><pre>#include<br>using namespace std;</pre></p>\n<p>int main(){<br>int ia[3][4]={0};<br>size_t cnt = 0;</p>\n<p>for (auto &amp;row : ia){<br>for (auto &amp;col : row){<br>col = cnt;<br>cnt++;<br>}<br>}</p>\n<p>for (const auto &amp;row : ia){<br>for (auto col : row){<br>cout &lt;&lt; col &lt;&lt; endl;<br>}<br>}<br>return 0;<br>}</p>\n<p><br>上面的例子中，因为要改变数组的值，所以要选用引用类型作为循环控制变量。但是其实有个更深层次的原因促使我们这么多：在第二个嵌套for循环中，没有任何写操作，只有读操作，可是我们还是将外层循环的控制变量声明成了引用类型。<span style=\"color: #ff0000;\">这是为了避免数组自动被转换成指针类型。</span></p>\n<p>举个栗子：</p>\n<p>for(auto row:ia){</p>\n<p>for(auto rol:row){}}</p>\n<p>将无法通过编译。因为像之前一样第一个循环遍历ia的所有元素，这些元素实际上是大小为4的数组。因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素转换成指向该数组内首元素的指针。这样得到的row的类型就是int*，显然内层循环就不合法。</p>\n<p><span style=\"color: #ff0000;\"><em><strong>指针数组和数组指针的辨别：</strong></em></span></p>\n<p>int *ip[4];//整型指针数组</p>\n<p>int (*ip)[4];//指向含有4个整数的数组</p>\n<p>&nbsp;</p>\n<p>c++11标准中通过auto和decltype就能尽可能地避免在数组前面加上一个指针类型了：</p>\n<p>//输出ia中每个元素的值，每个内层数组各占一行</p>\n<p>//版本1：</p>\n<p>int ia[3][4]={0};</p>\n<p>for(auto p=ia; p!=ia+3; ++p){</p>\n<p>for (auto q = <em>p; q != </em>p + 4; ++q){</p>\n<p>cout &lt;&lt; *q &lt;&lt;endl;}</p>\n<p>cout &lt;&lt; endl;</p>\n<p>}</p>\n<p>//版本2:这个版本中，循环终止条件由end函数负责判断。虽然我们可以推断出p是指向含有4个整数的数组的指针，q是指向整数的指针，但是使用auto我们就不用关系到底是什么类型了</p>\n<p>for (auto p = begin(ia); p != end(ia); ++p){</p>\n<p>for (auto q = begin(<em>p); q != end(</em>p); ++q){</p>\n<p>cout &lt;&lt; *q &lt;&lt;endl;}</p>\n<p>cout &lt;&lt; endl;</p>\n<p>}</p>\n<p>//版本3：使用类型别名来简化;程序将类型“4个整数组成的数组”命名为int_array</p>\n<p>using int_array = int[4];//typedef int int_array[4];</p>\n<p>for (int_array *p = ia; p != ia + 3; ++p){</p>\n<p>for (int <em>q = </em>p; q != *p + 4; ++q){</p>\n<p>cout &lt;&lt; *q &lt;&lt;endl;}</p>\n<p>cout &lt;&lt;endl;</p>\n<p>}</p>\n","site":{"data":{}},"excerpt":"<p><del><em><strong>遗留问题：范围for循环迭代指针</strong></em></del></p>\n<p>作用域操作符（::）的含义：编译器从操作符左侧所示的作用域中寻找右侧那个名字。因此std::cin是要使用命名空间std中的名字cin</p>\n<p>string s;</p>\n<p>cin &gt;&gt; s;</p>\n<p>在执行读取操作时，string对象会自动忽略开头的空白，并从第一个真正的字符开始读，直到碰到下一个空白为止；</p>\n<p>要想得到的字符串中保留输入时的空白符，应该用getline。和输入运算符一样，getline也会返回它的流参数。触发getline函数返回的那个换行符实际上被丢弃了，得到的string对象中不包含该换行符","more":"</p>\n<p>string::size_type类，string类以及其他大多数标准库类型都定义了几种配套的类型。这些配套类型都体现了标准库类型和机器无关的特性。在具体使用的时候，通过作用域操作符来表明名字size_type是在类string中定义的。</p>\n<p>尽管string::size_type的类型有点神秘，但是在c++11标准中，允许编译器通过auto或者decltype来推断变量的类型。</p>\n<p><span style=\"color: #ff0000;\"><em><strong>tips：</strong></em></span>如果一条表达式中已经有了size()函数就不要再使用int类型了，这样可以避免混用int和unsigned引发的问题了</p>\n<h3 id=\"字面值和string对象相加：\"><a href=\"#字面值和string对象相加：\" class=\"headerlink\" title=\"字面值和string对象相加：\"></a>字面值和string对象相加：</h3><p>c++中字符串字面值并不是标准库类型string的对象。<strong>切记：字符串字面值和string是不同的类型。</strong></p>\n<p><strong><em>标准库允许把字符字面值和字符串字面值转换成string。当把string对象和字符字面值或者字符串字面值混在一条语句中使用时，必须确保每个加法运算符的两侧的运算对象至少有一个是string</em></strong></p>\n<p>&nbsp;</p>\n<p>下标运算符[]接受的输入参数是string::size_type类型的值，这个参数表示要访问的字符的位置，<span style=\"color: #ff0000;\">返回值是该位置上字符的引用</span></p>\n<p><em>#include &lt;iostream&gt;</em><br><em>using namespace std;</em><br><em>#include &lt;cctype&gt;</em><br><em>int main(){</em><br><em> string s = “hello,world”;</em></p>\n<p><em> for (decltype(s.size()) index = 0; index != s.size() &amp;&amp; !ispunct(s[index]); ++index){</em><br><em> s[index] = toupper(s[index]);</em><br><em> }</em><br><em> //&amp;&amp;运算符有屏蔽作用，如果&amp;&amp;前是真才会看&amp;&amp;后的逻辑判断，也就是说只有index在范围内，才会检查s[index] </em><br><em> cout &lt;&lt; s&lt;&lt;endl;</em><br><em> return 0;</em><br><em>}</em></p>\n<p>_<strong><span style=\"color: #ff0000;\">tips：</span></strong>_c++标准库并不要求标准库检查下标是否合法，所以一旦使用了一个超出范围的下标，就会产生不可预估的后果。那么在使用前用string::size_type的index在size()范围内来保证下标的合法性！！</p>\n<p>&nbsp;</p>\n<p><em><strong><span style=\"color: #ff0000;\">tips:</span></strong></em>在类内初始值的初始化时候，只能用花括号或者放在等号右边。如：struct Node{int x=0; int y{0}; };</p>\n<p>c++语言提供了几种不同的初始化方式，在大多数情况下这些初始化方式可以相互等价地使用。但是有几个例外情况：</p>\n<ol>\n<li>使用拷贝初始化的时候（用=号的时候），只能提供一个初始值</li>\n<li>提供的是一个类内初始化，则只能用花括号｛｝和拷贝初始化（=）</li>\n<li>如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，这不能放在花括号里。<br>泛型编程：只有string和vector等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有的标准库容器的迭代器都定义了==和！=，但是它们大多数都没有定义&lt;运算符，因此推荐使用==和!=运算符，这样就不用管是哪种容器类型了。</li>\n</ol>\n<p>&nbsp;</p>\n<p>虽然vector对象可以动态地增长，但是也会有一些副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素，比如push_back都会使该vector对象的迭代器失效。</p>\n<p>迭代器的加减：只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓的距离就是右侧的迭代器向前移动多少个单位就能追上左侧的迭代器，其类型名是difference_type,因为这个距离可负可正，所以difference_type是带符号型的；</p>\n<p>&nbsp;</p>\n<p><em><strong><span style=\"color: #ff0000;\">字符数组的特殊性：</span></strong></em>字符数组有一种额外的初始化形式，可以用字符串字面值来对此类数组初始化。当使用这种方式的时候，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串其他字符一样被拷贝到字符数组中去。char a[6]=”hello!”，就是错误的，因为hello!是6个字符，还有一个’\\0’会被填入，却因为数组开小了 失败。</p>\n<p>&nbsp;</p>\n<p><em><strong><span style=\"color: #ff0000;\">初始化与不初始化：</span></strong></em></p>\n<p>例子:</p>\n<p>unsigned scores[11];//没有初始化，scores中的值都是由它们所在的位置来确定，所以都是垃圾值。不初始化可能会造成不可估量的错误，往往这种错误也不好找</p>\n<p>unsigned grade[11]={};//用花括号初始化，grade内元素的值都是0；</p>\n<p>&nbsp;</p>\n<p><strong><em><span style=\"color: #ff6600;\">数组与指针的关系很紧密，但是又不可以等价：</span></em></strong></p>\n<p>#include &lt;iostream&gt;<br>using namespace std;</p>\n<p>int main(){<br>int ia[] = {1,2,3,4,5,6};<br>decltype(ia) ia1;//经过decltype(array)得到的是数组（另外开辟的内存空间）<br>cout &lt;&lt; sizeof(ia)&lt;&lt;endl;//24<br>cout &lt;&lt; sizeof(ia1)&lt;&lt;endl;//24</p>\n<p>auto ia2 = ia;<br>cout &lt;&lt; *ia2;//经过auto得到的是数组ia的首地址。<br>return 0;<br>}</p>\n<p><span style=\"color: #ff6600;\">我的理解是：数组是开辟的一块内存，而指针只是存某一单位的内存地址的对象。auto将数组翻译成指针，并且这个指针存的是数组的首地址。而decltype将数组仍然翻译成数组，也就另外开辟内存空间了的。总的来说，decltype比auto更具体</span></p>\n<p>&nbsp;</p>\n<p><span style=\"color: #ff0000;\"><em><strong>下标和指针：</strong></em></span></p>\n<p>很多情况下使用数组名字其实用的是一个指向数组首元素的指针。当对数组使用下标运算符的时候，编译器会自动执行上述转换操作，比如：</p>\n<p>int a[10]={};</p>\n<p>int b = a[2];//&lt;=&gt;*(a+2)，a是数组的首地址</p>\n<p>只要指针指向的是数组中的元素，都可以执行下标运算：</p>\n<p>int *p=&amp;ia[2];</p>\n<p>int j = p[1];//等价于ia[3];</p>\n<p>int k = p[-2];//等价于ia[0];</p>\n<p>标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。内置的下标运算符可以处理负值。</p>\n<p>&nbsp;</p>\n<p><em><strong><span style=\"color: #ff0000;\">使用范围for循环处理多维数组需要注意的点：</span></strong></em></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><pre>#include<br>using namespace std;</pre></p>\n<p>int main(){<br>int ia[3][4]={0};<br>size_t cnt = 0;</p>\n<p>for (auto &amp;row : ia){<br>for (auto &amp;col : row){<br>col = cnt;<br>cnt++;<br>}<br>}</p>\n<p>for (const auto &amp;row : ia){<br>for (auto col : row){<br>cout &lt;&lt; col &lt;&lt; endl;<br>}<br>}<br>return 0;<br>}</p>\n<p><br>上面的例子中，因为要改变数组的值，所以要选用引用类型作为循环控制变量。但是其实有个更深层次的原因促使我们这么多：在第二个嵌套for循环中，没有任何写操作，只有读操作，可是我们还是将外层循环的控制变量声明成了引用类型。<span style=\"color: #ff0000;\">这是为了避免数组自动被转换成指针类型。</span></p>\n<p>举个栗子：</p>\n<p>for(auto row:ia){</p>\n<p>for(auto rol:row){}}</p>\n<p>将无法通过编译。因为像之前一样第一个循环遍历ia的所有元素，这些元素实际上是大小为4的数组。因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素转换成指向该数组内首元素的指针。这样得到的row的类型就是int*，显然内层循环就不合法。</p>\n<p><span style=\"color: #ff0000;\"><em><strong>指针数组和数组指针的辨别：</strong></em></span></p>\n<p>int *ip[4];//整型指针数组</p>\n<p>int (*ip)[4];//指向含有4个整数的数组</p>\n<p>&nbsp;</p>\n<p>c++11标准中通过auto和decltype就能尽可能地避免在数组前面加上一个指针类型了：</p>\n<p>//输出ia中每个元素的值，每个内层数组各占一行</p>\n<p>//版本1：</p>\n<p>int ia[3][4]={0};</p>\n<p>for(auto p=ia; p!=ia+3; ++p){</p>\n<p>for (auto q = <em>p; q != </em>p + 4; ++q){</p>\n<p>cout &lt;&lt; *q &lt;&lt;endl;}</p>\n<p>cout &lt;&lt; endl;</p>\n<p>}</p>\n<p>//版本2:这个版本中，循环终止条件由end函数负责判断。虽然我们可以推断出p是指向含有4个整数的数组的指针，q是指向整数的指针，但是使用auto我们就不用关系到底是什么类型了</p>\n<p>for (auto p = begin(ia); p != end(ia); ++p){</p>\n<p>for (auto q = begin(<em>p); q != end(</em>p); ++q){</p>\n<p>cout &lt;&lt; *q &lt;&lt;endl;}</p>\n<p>cout &lt;&lt; endl;</p>\n<p>}</p>\n<p>//版本3：使用类型别名来简化;程序将类型“4个整数组成的数组”命名为int_array</p>\n<p>using int_array = int[4];//typedef int int_array[4];</p>\n<p>for (int_array *p = ia; p != ia + 3; ++p){</p>\n<p>for (int <em>q = </em>p; q != *p + 4; ++q){</p>\n<p>cout &lt;&lt; *q &lt;&lt;endl;}</p>\n<p>cout &lt;&lt;endl;</p>\n<p>}</p>"},{"title":"C++/C Sleep函数的运用","id":"332","date":"2017-09-01T08:33:34.000Z","_content":"\nSleep函数\n\n功能： 执行挂起一段时间，也就是等待一段时间在继续执行\n\n用法：Sleep（时间）<!--more-->\n\n头文件：Windows下为--&gt; windows.h\n\nLinux 下为 --&gt; unistd.h\n\n注意：（1）Sleep是区分大小写的，有的编译器是大写，有的是小写。\n\n（2）Sleep括号里的时间，在windows下是已毫秒为单位，而Linux是以秒为单位\n```\n#include \nusing namespace std;\n#include \n#include \nint main(){\n\tfor (size_t i = 0; i &lt; 10; ++i){\n\t\tSleep(500);//挂起500ms \n\t\tcout &lt;&lt; time(0) &lt;&lt;endl;\n\t}\n\n\treturn 0;\n}\n```\n因此，在c++中的随机数生成器（随机数引擎和分布函数类）如果作为一个自动过程的一部分反复运行，将time的返回值作为种子的方式就无效了；\n可能多次用的是同一个种子，因为time()返回的是一秒的变化。\n```\n#include \n#include \n#include \n#include \n\nusing namespace std;\nint main(){\n\tdefault_random_engine e(time(0));\n\tuniform_int_distribution u(0, 100);\n\tvector v(100), v1(100);\n\n\tfor (size_t i = 0; i &lt; 100; ++i){\n\t\tv.push_back(u(e));\n\t\tv1.push_back(u(e));\n\t}\n\n\tif (v1 == v){\n\t\tcout &lt;&lt; 1&lt;&lt;endl;\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/c++andc Sleep.md","raw":"---\ntitle: C++/C Sleep函数的运用\nid: 332\ncategories:\n  - c++学习\ndate: 2017-09-01 16:33:34\ntags:\n---\n\nSleep函数\n\n功能： 执行挂起一段时间，也就是等待一段时间在继续执行\n\n用法：Sleep（时间）<!--more-->\n\n头文件：Windows下为--&gt; windows.h\n\nLinux 下为 --&gt; unistd.h\n\n注意：（1）Sleep是区分大小写的，有的编译器是大写，有的是小写。\n\n（2）Sleep括号里的时间，在windows下是已毫秒为单位，而Linux是以秒为单位\n```\n#include \nusing namespace std;\n#include \n#include \nint main(){\n\tfor (size_t i = 0; i &lt; 10; ++i){\n\t\tSleep(500);//挂起500ms \n\t\tcout &lt;&lt; time(0) &lt;&lt;endl;\n\t}\n\n\treturn 0;\n}\n```\n因此，在c++中的随机数生成器（随机数引擎和分布函数类）如果作为一个自动过程的一部分反复运行，将time的返回值作为种子的方式就无效了；\n可能多次用的是同一个种子，因为time()返回的是一秒的变化。\n```\n#include \n#include \n#include \n#include \n\nusing namespace std;\nint main(){\n\tdefault_random_engine e(time(0));\n\tuniform_int_distribution u(0, 100);\n\tvector v(100), v1(100);\n\n\tfor (size_t i = 0; i &lt; 100; ++i){\n\t\tv.push_back(u(e));\n\t\tv1.push_back(u(e));\n\t}\n\n\tif (v1 == v){\n\t\tcout &lt;&lt; 1&lt;&lt;endl;\n\t}\n\n\treturn 0;\n}\n```","slug":"c++andc Sleep","published":1,"updated":"2017-12-09T17:17:37.273Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec09000liwtw8sz7p04x","content":"<p>Sleep函数</p>\n<p>功能： 执行挂起一段时间，也就是等待一段时间在继续执行</p>\n<p>用法：Sleep（时间）<a id=\"more\"></a></p>\n<p>头文件：Windows下为–&gt; windows.h</p>\n<p>Linux 下为 –&gt; unistd.h</p>\n<p>注意：（1）Sleep是区分大小写的，有的编译器是大写，有的是小写。</p>\n<p>（2）Sleep括号里的时间，在windows下是已毫秒为单位，而Linux是以秒为单位<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &amp;lt; <span class=\"number\">10</span>; ++i)&#123;</span><br><span class=\"line\">\t\tSleep(<span class=\"number\">500</span>);<span class=\"comment\">//挂起500ms </span></span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &amp;lt;&amp;lt; time(<span class=\"number\">0</span>) &amp;lt;&amp;lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因此，在c++中的随机数生成器（随机数引擎和分布函数类）如果作为一个自动过程的一部分反复运行，将time的返回值作为种子的方式就无效了；<br>可能多次用的是同一个种子，因为time()返回的是一秒的变化。<br><figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> </span></span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">\tdefault_random_engine e(time(<span class=\"number\">0</span>));</span><br><span class=\"line\">\tuniform_int_distribution u(<span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">\tvector v(<span class=\"number\">100</span>), v1(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor (size_t i = <span class=\"number\">0</span>; i <span class=\"variable\">&amp;lt</span>; <span class=\"number\">100</span>; ++i)&#123;</span><br><span class=\"line\">\t\tv.push_back(u(e));</span><br><span class=\"line\">\t\tv1.push_back(u(e));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (v1 == v)&#123;</span><br><span class=\"line\">\t\tcout <span class=\"variable\">&amp;lt</span>;<span class=\"variable\">&amp;lt</span>; <span class=\"number\">1</span><span class=\"variable\">&amp;lt</span>;<span class=\"variable\">&amp;lt</span>;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>Sleep函数</p>\n<p>功能： 执行挂起一段时间，也就是等待一段时间在继续执行</p>\n<p>用法：Sleep（时间）","more":"</p>\n<p>头文件：Windows下为–&gt; windows.h</p>\n<p>Linux 下为 –&gt; unistd.h</p>\n<p>注意：（1）Sleep是区分大小写的，有的编译器是大写，有的是小写。</p>\n<p>（2）Sleep括号里的时间，在windows下是已毫秒为单位，而Linux是以秒为单位<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &amp;lt; <span class=\"number\">10</span>; ++i)&#123;</span><br><span class=\"line\">\t\tSleep(<span class=\"number\">500</span>);<span class=\"comment\">//挂起500ms </span></span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &amp;lt;&amp;lt; time(<span class=\"number\">0</span>) &amp;lt;&amp;lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因此，在c++中的随机数生成器（随机数引擎和分布函数类）如果作为一个自动过程的一部分反复运行，将time的返回值作为种子的方式就无效了；<br>可能多次用的是同一个种子，因为time()返回的是一秒的变化。<br><figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> </span></span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">\tdefault_random_engine e(time(<span class=\"number\">0</span>));</span><br><span class=\"line\">\tuniform_int_distribution u(<span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">\tvector v(<span class=\"number\">100</span>), v1(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor (size_t i = <span class=\"number\">0</span>; i <span class=\"variable\">&amp;lt</span>; <span class=\"number\">100</span>; ++i)&#123;</span><br><span class=\"line\">\t\tv.push_back(u(e));</span><br><span class=\"line\">\t\tv1.push_back(u(e));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (v1 == v)&#123;</span><br><span class=\"line\">\t\tcout <span class=\"variable\">&amp;lt</span>;<span class=\"variable\">&amp;lt</span>; <span class=\"number\">1</span><span class=\"variable\">&amp;lt</span>;<span class=\"variable\">&amp;lt</span>;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"c++基础 函数","id":"248","date":"2017-07-18T11:26:49.000Z","_content":"\n### _**<span style=\"color: #ff0000;\">局部静态对象：</span>**_\n\n有时候需要让局部变量的生命周期贯穿函数调用和之后的时间。可以将局部变量定义成static类型从而获得这样的对象。局部静态变量在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使它所在的函数结束执行也不会对它有影响。\n\n举例函数，统计一个函数被调用多少次：<!--more-->\n\nsize_t func(){\n\nstatic size_t cnt=0;//在第一次经过这个静态变量时候被初始化。函数结束后也不会被销毁，主函数结束时候才被销毁。\n\nreturn cnt;\n\n}\n\nint main(){\n\nfor (size_t i = 0; i &lt; 10; ++i){\n\ncout &lt;&lt; func()&lt;&lt;endl;}\n\nreturn 0;\n\n}\n\n* * *\n\n### _**<span style=\"color: #ff0000;\">函数声明：</span>**_\n\n函数必须在使用之前声明。类似于变量，函数只能被定义一次，但是可以声明多次。如果一个函数永远不会被我们用到，那么它可以只有声明没有定义。\n\n### _**<span style=\"color: #ff0000;\">指针形参：</span>**_\n\n指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值（地址）。拷贝之后，两个指针是不同的指针。\n\n举例函数:\n\nvoid ptrfunc(int *ptr){\n\n*ptr = 0;//拷贝的指针所指对象的值设置为0\n\nptr = nullptr;//拷贝的指针设置为空。但是实参的地址并没有变化。因为指针的参数传递也是拷贝的。\n\n}\n\n* * *\n\n### _**<span style=\"color: #ff0000;\">引用形参：</span>**_\n\n形参分为两类，一种是引用形参，一种是非引用形参。非引用形参都有一个拷贝的过程，也就是说：在函数中对非引用的形参初始化的变量做任何操作都不能影响到实参。而对于引用参数，在函数中操作的是实参的别名，也就相当于操作的是“原件”。\n\n<span style=\"color: #ff0000;\">tips：使用引用避免拷贝，可以提高效率，甚至有的类类型（IO在内）并不支持拷贝操作。所以，对于比较大的对象来说，用引用比较高效。并且：对于函数不需要修改时，最好用常量引用。</span>\n\n* * *\n\n<span style=\"color: #0000ff;\">使用引用的另一个好处，可以隐式地返回额外的参数：</span>\n\n因为函数一次性只能返回一个参数，可以自定义一个数据结构来保存多个变量，但是过程有点复杂。对于只需要一两个返回值的函数，我们可以用传入引用形参的方式，隐式地得到几个返回值；比如：在一个字符串中查找指定字符，返回它第一次出现的位置和总出现次数:\nstring::size_type find_char(const string &amp;str, char c, string::size_type &amp;cnt){\n\nstring::size_type ret = -1;//如果没有找到，就返回-1\n\ncnt = 0;//将计数的参数置0\n\nfor (decltype(ret) i = 0; i != str.size(); ++i){\n\nif (str[i] == c){\n\nif (ret == -1) ret = i;//记录第一次的值\n\n++cnt;\n\n}\n\nreturn ret;//返回第一次出现的位置。<span style=\"color: #ff0000;\">出现次数通过引用隐式地传给了调用者</span>\n\n}\n\n* * *\n\n### _**<span style=\"color: #ff0000;\">尽量使用常量引用：</span>**_\n\n把函数不会改变的形参定义成普通的引用是一种比较常见的错误，这么做会给函数的调用者一种误导，即函数可以修改它的实参的值。\n\n此外，使用引用而非常量引用也会<span style=\"color: #ff0000;\">极大地限制函数所能接受的实参类型</span>。比如说，我们不能把const对象、字面值、需要类型转换的对象传给普通引用的形参。\n\n这种错误往往会造成出人意料的错误：\n\n1.  比如上面的find_char()函数，如果将string类型的形参定义成普通的引用：find_char(string &amp;str.....)。则只能将find_char()作用于string对象。像find_char(\"hello,world\",'0',cnt)将在编译时发生错误。\n还有一个更难察觉的问题：假如其他函数将他们的形参定义成常量引用，那么修改成普通引用的find_char()将无法在此类函数中正常使用。比如：判断string是否是句子的函数中用find_char()：\n\nbool is_sentence(const string &amp;str){\n\nstring::size_type ctr = 0;\n\nreturn find_char(s,'.',ctr) == s.size()-1 &amp;&amp; ctr==1;}\n\n则这个函数在编译时候会发生错误，因为const的string传给了普通引用。如果没有办法修改find_char()的形参类型，则在is_sentence()中将const的string 拷贝成普通string 再传给find_char()；\n\n&nbsp;\n\n&nbsp;","source":"_posts/c-e5-9f-ba-e7-a1-80-e5-87-bd-e6-95-b0.md","raw":"---\ntitle: c++基础 函数\ntags:\n  - c++\nid: 248\ncategories:\n  - c++学习\ndate: 2017-07-18 19:26:49\n---\n\n### _**<span style=\"color: #ff0000;\">局部静态对象：</span>**_\n\n有时候需要让局部变量的生命周期贯穿函数调用和之后的时间。可以将局部变量定义成static类型从而获得这样的对象。局部静态变量在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使它所在的函数结束执行也不会对它有影响。\n\n举例函数，统计一个函数被调用多少次：<!--more-->\n\nsize_t func(){\n\nstatic size_t cnt=0;//在第一次经过这个静态变量时候被初始化。函数结束后也不会被销毁，主函数结束时候才被销毁。\n\nreturn cnt;\n\n}\n\nint main(){\n\nfor (size_t i = 0; i &lt; 10; ++i){\n\ncout &lt;&lt; func()&lt;&lt;endl;}\n\nreturn 0;\n\n}\n\n* * *\n\n### _**<span style=\"color: #ff0000;\">函数声明：</span>**_\n\n函数必须在使用之前声明。类似于变量，函数只能被定义一次，但是可以声明多次。如果一个函数永远不会被我们用到，那么它可以只有声明没有定义。\n\n### _**<span style=\"color: #ff0000;\">指针形参：</span>**_\n\n指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值（地址）。拷贝之后，两个指针是不同的指针。\n\n举例函数:\n\nvoid ptrfunc(int *ptr){\n\n*ptr = 0;//拷贝的指针所指对象的值设置为0\n\nptr = nullptr;//拷贝的指针设置为空。但是实参的地址并没有变化。因为指针的参数传递也是拷贝的。\n\n}\n\n* * *\n\n### _**<span style=\"color: #ff0000;\">引用形参：</span>**_\n\n形参分为两类，一种是引用形参，一种是非引用形参。非引用形参都有一个拷贝的过程，也就是说：在函数中对非引用的形参初始化的变量做任何操作都不能影响到实参。而对于引用参数，在函数中操作的是实参的别名，也就相当于操作的是“原件”。\n\n<span style=\"color: #ff0000;\">tips：使用引用避免拷贝，可以提高效率，甚至有的类类型（IO在内）并不支持拷贝操作。所以，对于比较大的对象来说，用引用比较高效。并且：对于函数不需要修改时，最好用常量引用。</span>\n\n* * *\n\n<span style=\"color: #0000ff;\">使用引用的另一个好处，可以隐式地返回额外的参数：</span>\n\n因为函数一次性只能返回一个参数，可以自定义一个数据结构来保存多个变量，但是过程有点复杂。对于只需要一两个返回值的函数，我们可以用传入引用形参的方式，隐式地得到几个返回值；比如：在一个字符串中查找指定字符，返回它第一次出现的位置和总出现次数:\nstring::size_type find_char(const string &amp;str, char c, string::size_type &amp;cnt){\n\nstring::size_type ret = -1;//如果没有找到，就返回-1\n\ncnt = 0;//将计数的参数置0\n\nfor (decltype(ret) i = 0; i != str.size(); ++i){\n\nif (str[i] == c){\n\nif (ret == -1) ret = i;//记录第一次的值\n\n++cnt;\n\n}\n\nreturn ret;//返回第一次出现的位置。<span style=\"color: #ff0000;\">出现次数通过引用隐式地传给了调用者</span>\n\n}\n\n* * *\n\n### _**<span style=\"color: #ff0000;\">尽量使用常量引用：</span>**_\n\n把函数不会改变的形参定义成普通的引用是一种比较常见的错误，这么做会给函数的调用者一种误导，即函数可以修改它的实参的值。\n\n此外，使用引用而非常量引用也会<span style=\"color: #ff0000;\">极大地限制函数所能接受的实参类型</span>。比如说，我们不能把const对象、字面值、需要类型转换的对象传给普通引用的形参。\n\n这种错误往往会造成出人意料的错误：\n\n1.  比如上面的find_char()函数，如果将string类型的形参定义成普通的引用：find_char(string &amp;str.....)。则只能将find_char()作用于string对象。像find_char(\"hello,world\",'0',cnt)将在编译时发生错误。\n还有一个更难察觉的问题：假如其他函数将他们的形参定义成常量引用，那么修改成普通引用的find_char()将无法在此类函数中正常使用。比如：判断string是否是句子的函数中用find_char()：\n\nbool is_sentence(const string &amp;str){\n\nstring::size_type ctr = 0;\n\nreturn find_char(s,'.',ctr) == s.size()-1 &amp;&amp; ctr==1;}\n\n则这个函数在编译时候会发生错误，因为const的string传给了普通引用。如果没有办法修改find_char()的形参类型，则在is_sentence()中将const的string 拷贝成普通string 再传给find_char()；\n\n&nbsp;\n\n&nbsp;","slug":"c-e5-9f-ba-e7-a1-80-e5-87-bd-e6-95-b0","published":1,"updated":"2017-12-09T17:06:50.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec09000piwtw77r2w3qz","content":"<h3 id=\"局部静态对象：\"><a href=\"#局部静态对象：\" class=\"headerlink\" title=\"局部静态对象：\"></a><em><strong><span style=\"color: #ff0000;\">局部静态对象：</span></strong></em></h3><p>有时候需要让局部变量的生命周期贯穿函数调用和之后的时间。可以将局部变量定义成static类型从而获得这样的对象。局部静态变量在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使它所在的函数结束执行也不会对它有影响。</p>\n<p>举例函数，统计一个函数被调用多少次：<a id=\"more\"></a></p>\n<p>size_t func(){</p>\n<p>static size_t cnt=0;//在第一次经过这个静态变量时候被初始化。函数结束后也不会被销毁，主函数结束时候才被销毁。</p>\n<p>return cnt;</p>\n<p>}</p>\n<p>int main(){</p>\n<p>for (size_t i = 0; i &lt; 10; ++i){</p>\n<p>cout &lt;&lt; func()&lt;&lt;endl;}</p>\n<p>return 0;</p>\n<p>}</p>\n<hr>\n<h3 id=\"函数声明：\"><a href=\"#函数声明：\" class=\"headerlink\" title=\"函数声明：\"></a><em><strong><span style=\"color: #ff0000;\">函数声明：</span></strong></em></h3><p>函数必须在使用之前声明。类似于变量，函数只能被定义一次，但是可以声明多次。如果一个函数永远不会被我们用到，那么它可以只有声明没有定义。</p>\n<h3 id=\"指针形参：\"><a href=\"#指针形参：\" class=\"headerlink\" title=\"指针形参：\"></a><em><strong><span style=\"color: #ff0000;\">指针形参：</span></strong></em></h3><p>指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值（地址）。拷贝之后，两个指针是不同的指针。</p>\n<p>举例函数:</p>\n<p>void ptrfunc(int *ptr){</p>\n<p>*ptr = 0;//拷贝的指针所指对象的值设置为0</p>\n<p>ptr = nullptr;//拷贝的指针设置为空。但是实参的地址并没有变化。因为指针的参数传递也是拷贝的。</p>\n<p>}</p>\n<hr>\n<h3 id=\"引用形参：\"><a href=\"#引用形参：\" class=\"headerlink\" title=\"引用形参：\"></a><em><strong><span style=\"color: #ff0000;\">引用形参：</span></strong></em></h3><p>形参分为两类，一种是引用形参，一种是非引用形参。非引用形参都有一个拷贝的过程，也就是说：在函数中对非引用的形参初始化的变量做任何操作都不能影响到实参。而对于引用参数，在函数中操作的是实参的别名，也就相当于操作的是“原件”。</p>\n<p><span style=\"color: #ff0000;\">tips：使用引用避免拷贝，可以提高效率，甚至有的类类型（IO在内）并不支持拷贝操作。所以，对于比较大的对象来说，用引用比较高效。并且：对于函数不需要修改时，最好用常量引用。</span></p>\n<hr>\n<p><span style=\"color: #0000ff;\">使用引用的另一个好处，可以隐式地返回额外的参数：</span></p>\n<p>因为函数一次性只能返回一个参数，可以自定义一个数据结构来保存多个变量，但是过程有点复杂。对于只需要一两个返回值的函数，我们可以用传入引用形参的方式，隐式地得到几个返回值；比如：在一个字符串中查找指定字符，返回它第一次出现的位置和总出现次数:<br>string::size_type find_char(const string &amp;str, char c, string::size_type &amp;cnt){</p>\n<p>string::size_type ret = -1;//如果没有找到，就返回-1</p>\n<p>cnt = 0;//将计数的参数置0</p>\n<p>for (decltype(ret) i = 0; i != str.size(); ++i){</p>\n<p>if (str[i] == c){</p>\n<p>if (ret == -1) ret = i;//记录第一次的值</p>\n<p>++cnt;</p>\n<p>}</p>\n<p>return ret;//返回第一次出现的位置。<span style=\"color: #ff0000;\">出现次数通过引用隐式地传给了调用者</span></p>\n<p>}</p>\n<hr>\n<h3 id=\"尽量使用常量引用：\"><a href=\"#尽量使用常量引用：\" class=\"headerlink\" title=\"尽量使用常量引用：\"></a><em><strong><span style=\"color: #ff0000;\">尽量使用常量引用：</span></strong></em></h3><p>把函数不会改变的形参定义成普通的引用是一种比较常见的错误，这么做会给函数的调用者一种误导，即函数可以修改它的实参的值。</p>\n<p>此外，使用引用而非常量引用也会<span style=\"color: #ff0000;\">极大地限制函数所能接受的实参类型</span>。比如说，我们不能把const对象、字面值、需要类型转换的对象传给普通引用的形参。</p>\n<p>这种错误往往会造成出人意料的错误：</p>\n<ol>\n<li>比如上面的find_char()函数，如果将string类型的形参定义成普通的引用：find_char(string &amp;str…..)。则只能将find_char()作用于string对象。像find_char(“hello,world”,’0’,cnt)将在编译时发生错误。<br>还有一个更难察觉的问题：假如其他函数将他们的形参定义成常量引用，那么修改成普通引用的find_char()将无法在此类函数中正常使用。比如：判断string是否是句子的函数中用find_char()：</li>\n</ol>\n<p>bool is_sentence(const string &amp;str){</p>\n<p>string::size_type ctr = 0;</p>\n<p>return find_char(s,’.’,ctr) == s.size()-1 &amp;&amp; ctr==1;}</p>\n<p>则这个函数在编译时候会发生错误，因为const的string传给了普通引用。如果没有办法修改find_char()的形参类型，则在is_sentence()中将const的string 拷贝成普通string 再传给find_char()；</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"局部静态对象：\"><a href=\"#局部静态对象：\" class=\"headerlink\" title=\"局部静态对象：\"></a><em><strong><span style=\"color: #ff0000;\">局部静态对象：</span></strong></em></h3><p>有时候需要让局部变量的生命周期贯穿函数调用和之后的时间。可以将局部变量定义成static类型从而获得这样的对象。局部静态变量在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使它所在的函数结束执行也不会对它有影响。</p>\n<p>举例函数，统计一个函数被调用多少次：","more":"</p>\n<p>size_t func(){</p>\n<p>static size_t cnt=0;//在第一次经过这个静态变量时候被初始化。函数结束后也不会被销毁，主函数结束时候才被销毁。</p>\n<p>return cnt;</p>\n<p>}</p>\n<p>int main(){</p>\n<p>for (size_t i = 0; i &lt; 10; ++i){</p>\n<p>cout &lt;&lt; func()&lt;&lt;endl;}</p>\n<p>return 0;</p>\n<p>}</p>\n<hr>\n<h3 id=\"函数声明：\"><a href=\"#函数声明：\" class=\"headerlink\" title=\"函数声明：\"></a><em><strong><span style=\"color: #ff0000;\">函数声明：</span></strong></em></h3><p>函数必须在使用之前声明。类似于变量，函数只能被定义一次，但是可以声明多次。如果一个函数永远不会被我们用到，那么它可以只有声明没有定义。</p>\n<h3 id=\"指针形参：\"><a href=\"#指针形参：\" class=\"headerlink\" title=\"指针形参：\"></a><em><strong><span style=\"color: #ff0000;\">指针形参：</span></strong></em></h3><p>指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值（地址）。拷贝之后，两个指针是不同的指针。</p>\n<p>举例函数:</p>\n<p>void ptrfunc(int *ptr){</p>\n<p>*ptr = 0;//拷贝的指针所指对象的值设置为0</p>\n<p>ptr = nullptr;//拷贝的指针设置为空。但是实参的地址并没有变化。因为指针的参数传递也是拷贝的。</p>\n<p>}</p>\n<hr>\n<h3 id=\"引用形参：\"><a href=\"#引用形参：\" class=\"headerlink\" title=\"引用形参：\"></a><em><strong><span style=\"color: #ff0000;\">引用形参：</span></strong></em></h3><p>形参分为两类，一种是引用形参，一种是非引用形参。非引用形参都有一个拷贝的过程，也就是说：在函数中对非引用的形参初始化的变量做任何操作都不能影响到实参。而对于引用参数，在函数中操作的是实参的别名，也就相当于操作的是“原件”。</p>\n<p><span style=\"color: #ff0000;\">tips：使用引用避免拷贝，可以提高效率，甚至有的类类型（IO在内）并不支持拷贝操作。所以，对于比较大的对象来说，用引用比较高效。并且：对于函数不需要修改时，最好用常量引用。</span></p>\n<hr>\n<p><span style=\"color: #0000ff;\">使用引用的另一个好处，可以隐式地返回额外的参数：</span></p>\n<p>因为函数一次性只能返回一个参数，可以自定义一个数据结构来保存多个变量，但是过程有点复杂。对于只需要一两个返回值的函数，我们可以用传入引用形参的方式，隐式地得到几个返回值；比如：在一个字符串中查找指定字符，返回它第一次出现的位置和总出现次数:<br>string::size_type find_char(const string &amp;str, char c, string::size_type &amp;cnt){</p>\n<p>string::size_type ret = -1;//如果没有找到，就返回-1</p>\n<p>cnt = 0;//将计数的参数置0</p>\n<p>for (decltype(ret) i = 0; i != str.size(); ++i){</p>\n<p>if (str[i] == c){</p>\n<p>if (ret == -1) ret = i;//记录第一次的值</p>\n<p>++cnt;</p>\n<p>}</p>\n<p>return ret;//返回第一次出现的位置。<span style=\"color: #ff0000;\">出现次数通过引用隐式地传给了调用者</span></p>\n<p>}</p>\n<hr>\n<h3 id=\"尽量使用常量引用：\"><a href=\"#尽量使用常量引用：\" class=\"headerlink\" title=\"尽量使用常量引用：\"></a><em><strong><span style=\"color: #ff0000;\">尽量使用常量引用：</span></strong></em></h3><p>把函数不会改变的形参定义成普通的引用是一种比较常见的错误，这么做会给函数的调用者一种误导，即函数可以修改它的实参的值。</p>\n<p>此外，使用引用而非常量引用也会<span style=\"color: #ff0000;\">极大地限制函数所能接受的实参类型</span>。比如说，我们不能把const对象、字面值、需要类型转换的对象传给普通引用的形参。</p>\n<p>这种错误往往会造成出人意料的错误：</p>\n<ol>\n<li>比如上面的find_char()函数，如果将string类型的形参定义成普通的引用：find_char(string &amp;str…..)。则只能将find_char()作用于string对象。像find_char(“hello,world”,’0’,cnt)将在编译时发生错误。<br>还有一个更难察觉的问题：假如其他函数将他们的形参定义成常量引用，那么修改成普通引用的find_char()将无法在此类函数中正常使用。比如：判断string是否是句子的函数中用find_char()：</li>\n</ol>\n<p>bool is_sentence(const string &amp;str){</p>\n<p>string::size_type ctr = 0;</p>\n<p>return find_char(s,’.’,ctr) == s.size()-1 &amp;&amp; ctr==1;}</p>\n<p>则这个函数在编译时候会发生错误，因为const的string传给了普通引用。如果没有办法修改find_char()的形参类型，则在is_sentence()中将const的string 拷贝成普通string 再传给find_char()；</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>"},{"title":"c++基础  类","id":"253","date":"2017-07-22T06:51:59.000Z","_content":"\n关于类的设计：不同的编程角色\n\n在一些简单的应用程序中，类的用户和类的设计者常常是同一个人。尽管如此，还是要把角色区分开来。当我们设计类的接口时，就应该考虑如何才能使类易于使用；而当我们使用类时，不应该顾及类的实现机理。\n\n<!--more-->\n\n&nbsp;\n\n### _**<span style=\"color: #ff0000;\">类成员函数的调用：</span>**_\n\n_**成员函数通过一个名为 this的额外的隐式参数来访问调用它的那个对象。**_当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如 调用total.isbn()，则编译器的操作是把total的地址传给isbn的隐式形参this。所以可以等价的写成isbn(&amp;total)//伪代码\n\n在成员函数的内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问符来使用，因为this所指的就是这个对象。任何对类成员的直接访问都是对this的隐式引用。也就是说：如果isbn函数中使用bookid这个成员变量，它隐式的使用this指向的成员，相当于：this-&gt;bookid;\n\n我们可以在成员函数中使用this：string isbn() const{return this-&gt;bookid;}  因为this的目的总是指向“这个”对象，所以this是一个常量指针，不允许改变this中保存的值。\n\n### <span style=\"color: #00ff00;\">**[重难点]：**</span><span style=\"color: #ff0000;\">_**引入const成员函数**_</span>\n\nisbn函数的另一个关键点就是：在参数表后的const关键字，这里的const的作用是修改隐式this指针的类型。this类型是指向类类型非常量版本的常量指针。比如在Sales_data成员函数中，this的类型就是Sales_data *const类型的。尽管this是隐式的，但是它仍然需要初始化，意味着我们不能把this绑定到一个常量对象上。\n\n所以我们不能在一个常量对象上调用普通的成员函数。\n\n如果isbn是一个普通函数而且this是一个普通的指针参数，则我们应该把this声明成const Sales_data *const。毕竟，在isbn函数体内不会改变this所指的对象，所以把this设置为指向常量的指针有助于提高函数的灵活性。\n\n把const关键字放在成员函数参数列表之后表示this是一个指向常量的指针。像这样的成员函数被称为 常量成员函数。因为this是指向常量的指针（**<span style=\"color: #ff0000;\">也就是说这个对象在使用isbn的时候，被this临时变成了const类型，所以不能改变对象的内容。</span>**）\n\n&nbsp;\n\n**_类作用域和成员函数：编译器分两步处理类：首先编译成员的声明；然后再编译成员的函数体。因此成员函数体可以随意随意使用类中的其他成员而不用在意成员出现的顺序。_**\n\n* * *\n\n## _<span style=\"color: #ff6600;\">**返回*this的成员函数：**</span>_\n\nthis是一个隐式的对象指针常量，指向对象本身。而成员函数返回*this即返回的是这个对象本身，并且类型是引用的话，就相当于用的是该对象的原件。例如：\n\n成员函数Screen &amp;set(char);中返回的是引用，引用的是Screen对象本身。而如果该函数是Screen set(char);返回的是Screen对象的拷贝件，是一个临时副本。\n\n&nbsp;\n\n<span style=\"color: #ff0000;\">_**如果成员函数不加const，this 只是一个指针常量；如果加了const的话，那么this是一个指向常量的指针常量。因为const的变量接受的值更多：既能够接受const的量，也能接受非常量的变量。如果加了const的话，在成员函数内部就不能改变该对象的成员变量了。**_</span>\n\n* * *\n\n因为非常量版本的函数对于常量对象是不可用的（即：常量对象是不能调用非常量对象的），所以我们只能在一个常量对象上调用const成员函数。另一方面，虽然可以在非常量对象上调用常量版本或者非常量版本，但是显然此时调用非常量版本更为匹配~\n\n在面对const的成员函数时候，如果返回的是引用类型，则得到的是const的引用。那么对于调用其他的非const成员函数则会报错。所以在遇到这种情况的时候，要用到成员函数重载的功能。即：将功能分为两个函数：一个是针对常量的，另一个是针对非常量的；再调用一个真正实现功能的函数，这个成员函数是const的成员函数，针对别的成员传过来的this指针，这个const会把传来的指针变成指向const对象的指针。\n\n例如：\n\nScreen &amp;display();//针对非常量的对象，调用do_display()在调用的时候，会隐式的将this指针传给do_display()，并且会将this指针变成指向常量的指针常量。\n\nconst Screen &amp;display() const;//针对常量的对象。\n\nvoid do_display() const{}//真正的功能函数，实现显示的功能。由display()调用。\n\n因此对于以上两个重载了的成员函数。如果对象是const的，则调用第二个；如果是非常量的，则调用第一个。\n\n* * *\n\n## _**<span style=\"color: #ff0000;\">类作用域需要注意的：</span>**_\n\n一旦遇到类名和作用域访问符号(ClasssName::),成员的剩余部分包含在类作用域之中了，剩余部分即：参数列表和函数体。经过这样的声明作用域，我们可以直接使用类的其他成员而无语再授权了。举例：Type ClassName::function(Type1, char){Type2 t; };在这个成员函数中，由于指定了函数的作用域是类的作用域，Type1和Type2（这两个是ClassName这个类中的类型成员）都可以直接使用；而至于Type，如果它是该类中的类型成员，则必须要加上ClassName::Type才正确。\n\n* * *\n\n## _**<span style=\"color: #ff0000;\">构造函数使用初始化列表和不使用初始化列表的区别：</span>**_\n\n代码1：\n\nSales_data::Sales_data(const string &amp;s, unsigned cnt, double price)\n\n{\n\nbookNo = s;\n\nunits_sold = cnt;\n\nrevenue = cnt*price;\n\n}\n\n代码2:\n\nSales_data::Sales_data(const string &amp;s, unsigned cnt, double price):bookNo(s),units_sold(cnt), revenue(cnt*price){}\n\n&nbsp;\n\n这两段代码的区别在于：代码1 没有使用初始化列表，那么没有显示的初始化列表，<span style=\"color: #ff0000;\">成员就会在构造函数体之前执行默认初始化</span>。然后再在函数体内进行赋值。\n\n而对于代码2 有显式的初始化列表，所以在函数体执行之前就会对成员进行初始化。\n\n<span style=\"color: #ff0000;\">**正因为如此，在某些情况下，必须要使用初始化列表**</span>：如果成员中有const和引用类型的话，就必须将其初始化，因为它们没有机会赋值。","source":"_posts/c-e5-9f-ba-e7-a1-80-e7-b1-bb.md","raw":"---\ntitle: c++基础  类\ntags:\n  - c++\nid: 253\ncategories:\n  - c++学习\ndate: 2017-07-22 14:51:59\n---\n\n关于类的设计：不同的编程角色\n\n在一些简单的应用程序中，类的用户和类的设计者常常是同一个人。尽管如此，还是要把角色区分开来。当我们设计类的接口时，就应该考虑如何才能使类易于使用；而当我们使用类时，不应该顾及类的实现机理。\n\n<!--more-->\n\n&nbsp;\n\n### _**<span style=\"color: #ff0000;\">类成员函数的调用：</span>**_\n\n_**成员函数通过一个名为 this的额外的隐式参数来访问调用它的那个对象。**_当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如 调用total.isbn()，则编译器的操作是把total的地址传给isbn的隐式形参this。所以可以等价的写成isbn(&amp;total)//伪代码\n\n在成员函数的内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问符来使用，因为this所指的就是这个对象。任何对类成员的直接访问都是对this的隐式引用。也就是说：如果isbn函数中使用bookid这个成员变量，它隐式的使用this指向的成员，相当于：this-&gt;bookid;\n\n我们可以在成员函数中使用this：string isbn() const{return this-&gt;bookid;}  因为this的目的总是指向“这个”对象，所以this是一个常量指针，不允许改变this中保存的值。\n\n### <span style=\"color: #00ff00;\">**[重难点]：**</span><span style=\"color: #ff0000;\">_**引入const成员函数**_</span>\n\nisbn函数的另一个关键点就是：在参数表后的const关键字，这里的const的作用是修改隐式this指针的类型。this类型是指向类类型非常量版本的常量指针。比如在Sales_data成员函数中，this的类型就是Sales_data *const类型的。尽管this是隐式的，但是它仍然需要初始化，意味着我们不能把this绑定到一个常量对象上。\n\n所以我们不能在一个常量对象上调用普通的成员函数。\n\n如果isbn是一个普通函数而且this是一个普通的指针参数，则我们应该把this声明成const Sales_data *const。毕竟，在isbn函数体内不会改变this所指的对象，所以把this设置为指向常量的指针有助于提高函数的灵活性。\n\n把const关键字放在成员函数参数列表之后表示this是一个指向常量的指针。像这样的成员函数被称为 常量成员函数。因为this是指向常量的指针（**<span style=\"color: #ff0000;\">也就是说这个对象在使用isbn的时候，被this临时变成了const类型，所以不能改变对象的内容。</span>**）\n\n&nbsp;\n\n**_类作用域和成员函数：编译器分两步处理类：首先编译成员的声明；然后再编译成员的函数体。因此成员函数体可以随意随意使用类中的其他成员而不用在意成员出现的顺序。_**\n\n* * *\n\n## _<span style=\"color: #ff6600;\">**返回*this的成员函数：**</span>_\n\nthis是一个隐式的对象指针常量，指向对象本身。而成员函数返回*this即返回的是这个对象本身，并且类型是引用的话，就相当于用的是该对象的原件。例如：\n\n成员函数Screen &amp;set(char);中返回的是引用，引用的是Screen对象本身。而如果该函数是Screen set(char);返回的是Screen对象的拷贝件，是一个临时副本。\n\n&nbsp;\n\n<span style=\"color: #ff0000;\">_**如果成员函数不加const，this 只是一个指针常量；如果加了const的话，那么this是一个指向常量的指针常量。因为const的变量接受的值更多：既能够接受const的量，也能接受非常量的变量。如果加了const的话，在成员函数内部就不能改变该对象的成员变量了。**_</span>\n\n* * *\n\n因为非常量版本的函数对于常量对象是不可用的（即：常量对象是不能调用非常量对象的），所以我们只能在一个常量对象上调用const成员函数。另一方面，虽然可以在非常量对象上调用常量版本或者非常量版本，但是显然此时调用非常量版本更为匹配~\n\n在面对const的成员函数时候，如果返回的是引用类型，则得到的是const的引用。那么对于调用其他的非const成员函数则会报错。所以在遇到这种情况的时候，要用到成员函数重载的功能。即：将功能分为两个函数：一个是针对常量的，另一个是针对非常量的；再调用一个真正实现功能的函数，这个成员函数是const的成员函数，针对别的成员传过来的this指针，这个const会把传来的指针变成指向const对象的指针。\n\n例如：\n\nScreen &amp;display();//针对非常量的对象，调用do_display()在调用的时候，会隐式的将this指针传给do_display()，并且会将this指针变成指向常量的指针常量。\n\nconst Screen &amp;display() const;//针对常量的对象。\n\nvoid do_display() const{}//真正的功能函数，实现显示的功能。由display()调用。\n\n因此对于以上两个重载了的成员函数。如果对象是const的，则调用第二个；如果是非常量的，则调用第一个。\n\n* * *\n\n## _**<span style=\"color: #ff0000;\">类作用域需要注意的：</span>**_\n\n一旦遇到类名和作用域访问符号(ClasssName::),成员的剩余部分包含在类作用域之中了，剩余部分即：参数列表和函数体。经过这样的声明作用域，我们可以直接使用类的其他成员而无语再授权了。举例：Type ClassName::function(Type1, char){Type2 t; };在这个成员函数中，由于指定了函数的作用域是类的作用域，Type1和Type2（这两个是ClassName这个类中的类型成员）都可以直接使用；而至于Type，如果它是该类中的类型成员，则必须要加上ClassName::Type才正确。\n\n* * *\n\n## _**<span style=\"color: #ff0000;\">构造函数使用初始化列表和不使用初始化列表的区别：</span>**_\n\n代码1：\n\nSales_data::Sales_data(const string &amp;s, unsigned cnt, double price)\n\n{\n\nbookNo = s;\n\nunits_sold = cnt;\n\nrevenue = cnt*price;\n\n}\n\n代码2:\n\nSales_data::Sales_data(const string &amp;s, unsigned cnt, double price):bookNo(s),units_sold(cnt), revenue(cnt*price){}\n\n&nbsp;\n\n这两段代码的区别在于：代码1 没有使用初始化列表，那么没有显示的初始化列表，<span style=\"color: #ff0000;\">成员就会在构造函数体之前执行默认初始化</span>。然后再在函数体内进行赋值。\n\n而对于代码2 有显式的初始化列表，所以在函数体执行之前就会对成员进行初始化。\n\n<span style=\"color: #ff0000;\">**正因为如此，在某些情况下，必须要使用初始化列表**</span>：如果成员中有const和引用类型的话，就必须将其初始化，因为它们没有机会赋值。","slug":"c-e5-9f-ba-e7-a1-80-e7-b1-bb","published":1,"updated":"2017-12-09T17:06:50.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec0j000siwtwtmu1qaq2","content":"<p>关于类的设计：不同的编程角色</p>\n<p>在一些简单的应用程序中，类的用户和类的设计者常常是同一个人。尽管如此，还是要把角色区分开来。当我们设计类的接口时，就应该考虑如何才能使类易于使用；而当我们使用类时，不应该顾及类的实现机理。</p>\n<a id=\"more\"></a>\n<p>&nbsp;</p>\n<h3 id=\"类成员函数的调用：\"><a href=\"#类成员函数的调用：\" class=\"headerlink\" title=\"类成员函数的调用：\"></a><em><strong><span style=\"color: #ff0000;\">类成员函数的调用：</span></strong></em></h3><p><em><strong>成员函数通过一个名为 this的额外的隐式参数来访问调用它的那个对象。</strong></em>当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如 调用total.isbn()，则编译器的操作是把total的地址传给isbn的隐式形参this。所以可以等价的写成isbn(&amp;total)//伪代码</p>\n<p>在成员函数的内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问符来使用，因为this所指的就是这个对象。任何对类成员的直接访问都是对this的隐式引用。也就是说：如果isbn函数中使用bookid这个成员变量，它隐式的使用this指向的成员，相当于：this-&gt;bookid;</p>\n<p>我们可以在成员函数中使用this：string isbn() const{return this-&gt;bookid;}  因为this的目的总是指向“这个”对象，所以this是一个常量指针，不允许改变this中保存的值。</p>\n<h3 id=\"重难点-：引入const成员函数\"><a href=\"#重难点-：引入const成员函数\" class=\"headerlink\" title=\"[重难点]：引入const成员函数\"></a><span style=\"color: #00ff00;\"><strong>[重难点]：</strong></span><span style=\"color: #ff0000;\"><em><strong>引入const成员函数</strong></em></span></h3><p>isbn函数的另一个关键点就是：在参数表后的const关键字，这里的const的作用是修改隐式this指针的类型。this类型是指向类类型非常量版本的常量指针。比如在Sales_data成员函数中，this的类型就是Sales_data *const类型的。尽管this是隐式的，但是它仍然需要初始化，意味着我们不能把this绑定到一个常量对象上。</p>\n<p>所以我们不能在一个常量对象上调用普通的成员函数。</p>\n<p>如果isbn是一个普通函数而且this是一个普通的指针参数，则我们应该把this声明成const Sales_data *const。毕竟，在isbn函数体内不会改变this所指的对象，所以把this设置为指向常量的指针有助于提高函数的灵活性。</p>\n<p>把const关键字放在成员函数参数列表之后表示this是一个指向常量的指针。像这样的成员函数被称为 常量成员函数。因为this是指向常量的指针（<strong><span style=\"color: #ff0000;\">也就是说这个对象在使用isbn的时候，被this临时变成了const类型，所以不能改变对象的内容。</span></strong>）</p>\n<p>&nbsp;</p>\n<p><strong><em>类作用域和成员函数：编译器分两步处理类：首先编译成员的声明；然后再编译成员的函数体。因此成员函数体可以随意随意使用类中的其他成员而不用在意成员出现的顺序。</em></strong></p>\n<hr>\n<h2 id=\"返回-this的成员函数：\"><a href=\"#返回-this的成员函数：\" class=\"headerlink\" title=\"返回*this的成员函数：\"></a><em><span style=\"color: #ff6600;\"><strong>返回*this的成员函数：</strong></span></em></h2><p>this是一个隐式的对象指针常量，指向对象本身。而成员函数返回*this即返回的是这个对象本身，并且类型是引用的话，就相当于用的是该对象的原件。例如：</p>\n<p>成员函数Screen &amp;set(char);中返回的是引用，引用的是Screen对象本身。而如果该函数是Screen set(char);返回的是Screen对象的拷贝件，是一个临时副本。</p>\n<p>&nbsp;</p>\n<p><span style=\"color: #ff0000;\"><em><strong>如果成员函数不加const，this 只是一个指针常量；如果加了const的话，那么this是一个指向常量的指针常量。因为const的变量接受的值更多：既能够接受const的量，也能接受非常量的变量。如果加了const的话，在成员函数内部就不能改变该对象的成员变量了。</strong></em></span></p>\n<hr>\n<p>因为非常量版本的函数对于常量对象是不可用的（即：常量对象是不能调用非常量对象的），所以我们只能在一个常量对象上调用const成员函数。另一方面，虽然可以在非常量对象上调用常量版本或者非常量版本，但是显然此时调用非常量版本更为匹配~</p>\n<p>在面对const的成员函数时候，如果返回的是引用类型，则得到的是const的引用。那么对于调用其他的非const成员函数则会报错。所以在遇到这种情况的时候，要用到成员函数重载的功能。即：将功能分为两个函数：一个是针对常量的，另一个是针对非常量的；再调用一个真正实现功能的函数，这个成员函数是const的成员函数，针对别的成员传过来的this指针，这个const会把传来的指针变成指向const对象的指针。</p>\n<p>例如：</p>\n<p>Screen &amp;display();//针对非常量的对象，调用do_display()在调用的时候，会隐式的将this指针传给do_display()，并且会将this指针变成指向常量的指针常量。</p>\n<p>const Screen &amp;display() const;//针对常量的对象。</p>\n<p>void do_display() const{}//真正的功能函数，实现显示的功能。由display()调用。</p>\n<p>因此对于以上两个重载了的成员函数。如果对象是const的，则调用第二个；如果是非常量的，则调用第一个。</p>\n<hr>\n<h2 id=\"类作用域需要注意的：\"><a href=\"#类作用域需要注意的：\" class=\"headerlink\" title=\"类作用域需要注意的：\"></a><em><strong><span style=\"color: #ff0000;\">类作用域需要注意的：</span></strong></em></h2><p>一旦遇到类名和作用域访问符号(ClasssName::),成员的剩余部分包含在类作用域之中了，剩余部分即：参数列表和函数体。经过这样的声明作用域，我们可以直接使用类的其他成员而无语再授权了。举例：Type ClassName::function(Type1, char){Type2 t; };在这个成员函数中，由于指定了函数的作用域是类的作用域，Type1和Type2（这两个是ClassName这个类中的类型成员）都可以直接使用；而至于Type，如果它是该类中的类型成员，则必须要加上ClassName::Type才正确。</p>\n<hr>\n<h2 id=\"构造函数使用初始化列表和不使用初始化列表的区别：\"><a href=\"#构造函数使用初始化列表和不使用初始化列表的区别：\" class=\"headerlink\" title=\"构造函数使用初始化列表和不使用初始化列表的区别：\"></a><em><strong><span style=\"color: #ff0000;\">构造函数使用初始化列表和不使用初始化列表的区别：</span></strong></em></h2><p>代码1：</p>\n<p>Sales_data::Sales_data(const string &amp;s, unsigned cnt, double price)</p>\n<p>{</p>\n<p>bookNo = s;</p>\n<p>units_sold = cnt;</p>\n<p>revenue = cnt*price;</p>\n<p>}</p>\n<p>代码2:</p>\n<p>Sales_data::Sales_data(const string &amp;s, unsigned cnt, double price):bookNo(s),units_sold(cnt), revenue(cnt*price){}</p>\n<p>&nbsp;</p>\n<p>这两段代码的区别在于：代码1 没有使用初始化列表，那么没有显示的初始化列表，<span style=\"color: #ff0000;\">成员就会在构造函数体之前执行默认初始化</span>。然后再在函数体内进行赋值。</p>\n<p>而对于代码2 有显式的初始化列表，所以在函数体执行之前就会对成员进行初始化。</p>\n<p><span style=\"color: #ff0000;\"><strong>正因为如此，在某些情况下，必须要使用初始化列表</strong></span>：如果成员中有const和引用类型的话，就必须将其初始化，因为它们没有机会赋值。</p>\n","site":{"data":{}},"excerpt":"<p>关于类的设计：不同的编程角色</p>\n<p>在一些简单的应用程序中，类的用户和类的设计者常常是同一个人。尽管如此，还是要把角色区分开来。当我们设计类的接口时，就应该考虑如何才能使类易于使用；而当我们使用类时，不应该顾及类的实现机理。</p>","more":"<p>&nbsp;</p>\n<h3 id=\"类成员函数的调用：\"><a href=\"#类成员函数的调用：\" class=\"headerlink\" title=\"类成员函数的调用：\"></a><em><strong><span style=\"color: #ff0000;\">类成员函数的调用：</span></strong></em></h3><p><em><strong>成员函数通过一个名为 this的额外的隐式参数来访问调用它的那个对象。</strong></em>当我们调用一个成员函数时，用请求该函数的对象地址初始化this。例如 调用total.isbn()，则编译器的操作是把total的地址传给isbn的隐式形参this。所以可以等价的写成isbn(&amp;total)//伪代码</p>\n<p>在成员函数的内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问符来使用，因为this所指的就是这个对象。任何对类成员的直接访问都是对this的隐式引用。也就是说：如果isbn函数中使用bookid这个成员变量，它隐式的使用this指向的成员，相当于：this-&gt;bookid;</p>\n<p>我们可以在成员函数中使用this：string isbn() const{return this-&gt;bookid;}  因为this的目的总是指向“这个”对象，所以this是一个常量指针，不允许改变this中保存的值。</p>\n<h3 id=\"重难点-：引入const成员函数\"><a href=\"#重难点-：引入const成员函数\" class=\"headerlink\" title=\"[重难点]：引入const成员函数\"></a><span style=\"color: #00ff00;\"><strong>[重难点]：</strong></span><span style=\"color: #ff0000;\"><em><strong>引入const成员函数</strong></em></span></h3><p>isbn函数的另一个关键点就是：在参数表后的const关键字，这里的const的作用是修改隐式this指针的类型。this类型是指向类类型非常量版本的常量指针。比如在Sales_data成员函数中，this的类型就是Sales_data *const类型的。尽管this是隐式的，但是它仍然需要初始化，意味着我们不能把this绑定到一个常量对象上。</p>\n<p>所以我们不能在一个常量对象上调用普通的成员函数。</p>\n<p>如果isbn是一个普通函数而且this是一个普通的指针参数，则我们应该把this声明成const Sales_data *const。毕竟，在isbn函数体内不会改变this所指的对象，所以把this设置为指向常量的指针有助于提高函数的灵活性。</p>\n<p>把const关键字放在成员函数参数列表之后表示this是一个指向常量的指针。像这样的成员函数被称为 常量成员函数。因为this是指向常量的指针（<strong><span style=\"color: #ff0000;\">也就是说这个对象在使用isbn的时候，被this临时变成了const类型，所以不能改变对象的内容。</span></strong>）</p>\n<p>&nbsp;</p>\n<p><strong><em>类作用域和成员函数：编译器分两步处理类：首先编译成员的声明；然后再编译成员的函数体。因此成员函数体可以随意随意使用类中的其他成员而不用在意成员出现的顺序。</em></strong></p>\n<hr>\n<h2 id=\"返回-this的成员函数：\"><a href=\"#返回-this的成员函数：\" class=\"headerlink\" title=\"返回*this的成员函数：\"></a><em><span style=\"color: #ff6600;\"><strong>返回*this的成员函数：</strong></span></em></h2><p>this是一个隐式的对象指针常量，指向对象本身。而成员函数返回*this即返回的是这个对象本身，并且类型是引用的话，就相当于用的是该对象的原件。例如：</p>\n<p>成员函数Screen &amp;set(char);中返回的是引用，引用的是Screen对象本身。而如果该函数是Screen set(char);返回的是Screen对象的拷贝件，是一个临时副本。</p>\n<p>&nbsp;</p>\n<p><span style=\"color: #ff0000;\"><em><strong>如果成员函数不加const，this 只是一个指针常量；如果加了const的话，那么this是一个指向常量的指针常量。因为const的变量接受的值更多：既能够接受const的量，也能接受非常量的变量。如果加了const的话，在成员函数内部就不能改变该对象的成员变量了。</strong></em></span></p>\n<hr>\n<p>因为非常量版本的函数对于常量对象是不可用的（即：常量对象是不能调用非常量对象的），所以我们只能在一个常量对象上调用const成员函数。另一方面，虽然可以在非常量对象上调用常量版本或者非常量版本，但是显然此时调用非常量版本更为匹配~</p>\n<p>在面对const的成员函数时候，如果返回的是引用类型，则得到的是const的引用。那么对于调用其他的非const成员函数则会报错。所以在遇到这种情况的时候，要用到成员函数重载的功能。即：将功能分为两个函数：一个是针对常量的，另一个是针对非常量的；再调用一个真正实现功能的函数，这个成员函数是const的成员函数，针对别的成员传过来的this指针，这个const会把传来的指针变成指向const对象的指针。</p>\n<p>例如：</p>\n<p>Screen &amp;display();//针对非常量的对象，调用do_display()在调用的时候，会隐式的将this指针传给do_display()，并且会将this指针变成指向常量的指针常量。</p>\n<p>const Screen &amp;display() const;//针对常量的对象。</p>\n<p>void do_display() const{}//真正的功能函数，实现显示的功能。由display()调用。</p>\n<p>因此对于以上两个重载了的成员函数。如果对象是const的，则调用第二个；如果是非常量的，则调用第一个。</p>\n<hr>\n<h2 id=\"类作用域需要注意的：\"><a href=\"#类作用域需要注意的：\" class=\"headerlink\" title=\"类作用域需要注意的：\"></a><em><strong><span style=\"color: #ff0000;\">类作用域需要注意的：</span></strong></em></h2><p>一旦遇到类名和作用域访问符号(ClasssName::),成员的剩余部分包含在类作用域之中了，剩余部分即：参数列表和函数体。经过这样的声明作用域，我们可以直接使用类的其他成员而无语再授权了。举例：Type ClassName::function(Type1, char){Type2 t; };在这个成员函数中，由于指定了函数的作用域是类的作用域，Type1和Type2（这两个是ClassName这个类中的类型成员）都可以直接使用；而至于Type，如果它是该类中的类型成员，则必须要加上ClassName::Type才正确。</p>\n<hr>\n<h2 id=\"构造函数使用初始化列表和不使用初始化列表的区别：\"><a href=\"#构造函数使用初始化列表和不使用初始化列表的区别：\" class=\"headerlink\" title=\"构造函数使用初始化列表和不使用初始化列表的区别：\"></a><em><strong><span style=\"color: #ff0000;\">构造函数使用初始化列表和不使用初始化列表的区别：</span></strong></em></h2><p>代码1：</p>\n<p>Sales_data::Sales_data(const string &amp;s, unsigned cnt, double price)</p>\n<p>{</p>\n<p>bookNo = s;</p>\n<p>units_sold = cnt;</p>\n<p>revenue = cnt*price;</p>\n<p>}</p>\n<p>代码2:</p>\n<p>Sales_data::Sales_data(const string &amp;s, unsigned cnt, double price):bookNo(s),units_sold(cnt), revenue(cnt*price){}</p>\n<p>&nbsp;</p>\n<p>这两段代码的区别在于：代码1 没有使用初始化列表，那么没有显示的初始化列表，<span style=\"color: #ff0000;\">成员就会在构造函数体之前执行默认初始化</span>。然后再在函数体内进行赋值。</p>\n<p>而对于代码2 有显式的初始化列表，所以在函数体执行之前就会对成员进行初始化。</p>\n<p><span style=\"color: #ff0000;\"><strong>正因为如此，在某些情况下，必须要使用初始化列表</strong></span>：如果成员中有const和引用类型的话，就必须将其初始化，因为它们没有机会赋值。</p>"},{"title":"c++基础 表达式","id":"241","date":"2017-07-15T08:26:16.000Z","_content":"\n_**<span style=\"color: #ff0000;\">区分左值和右值：</span>**_\n\n当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被当作左值的时候，用的是对象的身份(内存的位置)\n\n使用关键字decltype的时候，左值和右值有所不同，如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。举例:p是int*，因为解引用运算符生成左值，所以decltype(*p)的结果是int&amp;。另一方面，因为取地址符生成右值，所以decltype(&amp;p)的结果是int**，也就是说，结果是一个指向整型指针的指针。\n\n<!--more-->\n\n求值顺序容易产生错误的一点：优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。\n\n<span style=\"color: #ff0000;\">对于没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。举个栗子：</span>\n\nint i;\n\ncout &lt;&lt; i &lt;&lt; \" \" &lt;&lt;++i &lt;&lt;endl;//是未定义的\n\n因为程序是未定义的所以，我们无法推断结果。不同的编译器执行的顺序可能不同，有可能先求++i再求i，也有可能先i后++i。\n\n如果改变了某个运算对象的值，在表达式其他的地方就不要再使用这个运算对象。有一个重要例外就是：表达式*++iter，递增运算符改变iter的值，然后在解引用。因为递增运算（即改变运算对象的子表达式）必须先求值，然后才轮到解引用。\n\n<span style=\"color: #ff0000;\">**_除法运算规则：_**</span>\n\n(-m)/n和m/(-n)都等于：-(m/n)\n\nm%(-n)等于m%n\n\n(-m)%n等于-(m%n)\n\n即：除法看整体，取余看被除数\n\n&nbsp;\n\n**<span style=\"color: #ff0000;\">前置递增和后置递增：</span>**\n\n前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置递增的操作就是一种浪费。\n\n对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化；但是对于相对复杂的迭代器类型，这种额外的工作消耗就非常大了。建议养成使用前置递增的习惯，这样不用担心性能问题并且写出的代码更符合编程的初衷。\n\n&nbsp;\n\n&nbsp;","source":"_posts/c-e5-9f-ba-e7-a1-80-e8-a1-a8-e8-be-be-e5-bc-8f.md","raw":"---\ntitle: c++基础 表达式\ntags:\n  - c++\nid: 241\ncategories:\n  - c++学习\ndate: 2017-07-15 16:26:16\n---\n\n_**<span style=\"color: #ff0000;\">区分左值和右值：</span>**_\n\n当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被当作左值的时候，用的是对象的身份(内存的位置)\n\n使用关键字decltype的时候，左值和右值有所不同，如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。举例:p是int*，因为解引用运算符生成左值，所以decltype(*p)的结果是int&amp;。另一方面，因为取地址符生成右值，所以decltype(&amp;p)的结果是int**，也就是说，结果是一个指向整型指针的指针。\n\n<!--more-->\n\n求值顺序容易产生错误的一点：优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。\n\n<span style=\"color: #ff0000;\">对于没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。举个栗子：</span>\n\nint i;\n\ncout &lt;&lt; i &lt;&lt; \" \" &lt;&lt;++i &lt;&lt;endl;//是未定义的\n\n因为程序是未定义的所以，我们无法推断结果。不同的编译器执行的顺序可能不同，有可能先求++i再求i，也有可能先i后++i。\n\n如果改变了某个运算对象的值，在表达式其他的地方就不要再使用这个运算对象。有一个重要例外就是：表达式*++iter，递增运算符改变iter的值，然后在解引用。因为递增运算（即改变运算对象的子表达式）必须先求值，然后才轮到解引用。\n\n<span style=\"color: #ff0000;\">**_除法运算规则：_**</span>\n\n(-m)/n和m/(-n)都等于：-(m/n)\n\nm%(-n)等于m%n\n\n(-m)%n等于-(m%n)\n\n即：除法看整体，取余看被除数\n\n&nbsp;\n\n**<span style=\"color: #ff0000;\">前置递增和后置递增：</span>**\n\n前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置递增的操作就是一种浪费。\n\n对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化；但是对于相对复杂的迭代器类型，这种额外的工作消耗就非常大了。建议养成使用前置递增的习惯，这样不用担心性能问题并且写出的代码更符合编程的初衷。\n\n&nbsp;\n\n&nbsp;","slug":"c-e5-9f-ba-e7-a1-80-e8-a1-a8-e8-be-be-e5-bc-8f","published":1,"updated":"2017-12-09T17:06:50.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec0j000viwtwrpestyc0","content":"<p><em><strong><span style=\"color: #ff0000;\">区分左值和右值：</span></strong></em></p>\n<p>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被当作左值的时候，用的是对象的身份(内存的位置)</p>\n<p>使用关键字decltype的时候，左值和右值有所不同，如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。举例:p是int<em>，因为解引用运算符生成左值，所以decltype(</em>p)的结果是int&amp;。另一方面，因为取地址符生成右值，所以decltype(&amp;p)的结果是int**，也就是说，结果是一个指向整型指针的指针。</p>\n<a id=\"more\"></a>\n<p>求值顺序容易产生错误的一点：优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。</p>\n<p><span style=\"color: #ff0000;\">对于没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。举个栗子：</span></p>\n<p>int i;</p>\n<p>cout &lt;&lt; i &lt;&lt; “ “ &lt;&lt;++i &lt;&lt;endl;//是未定义的</p>\n<p>因为程序是未定义的所以，我们无法推断结果。不同的编译器执行的顺序可能不同，有可能先求++i再求i，也有可能先i后++i。</p>\n<p>如果改变了某个运算对象的值，在表达式其他的地方就不要再使用这个运算对象。有一个重要例外就是：表达式*++iter，递增运算符改变iter的值，然后在解引用。因为递增运算（即改变运算对象的子表达式）必须先求值，然后才轮到解引用。</p>\n<p><span style=\"color: #ff0000;\"><strong><em>除法运算规则：</em></strong></span></p>\n<p>(-m)/n和m/(-n)都等于：-(m/n)</p>\n<p>m%(-n)等于m%n</p>\n<p>(-m)%n等于-(m%n)</p>\n<p>即：除法看整体，取余看被除数</p>\n<p>&nbsp;</p>\n<p><strong><span style=\"color: #ff0000;\">前置递增和后置递增：</span></strong></p>\n<p>前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置递增的操作就是一种浪费。</p>\n<p>对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化；但是对于相对复杂的迭代器类型，这种额外的工作消耗就非常大了。建议养成使用前置递增的习惯，这样不用担心性能问题并且写出的代码更符合编程的初衷。</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n","site":{"data":{}},"excerpt":"<p><em><strong><span style=\"color: #ff0000;\">区分左值和右值：</span></strong></em></p>\n<p>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被当作左值的时候，用的是对象的身份(内存的位置)</p>\n<p>使用关键字decltype的时候，左值和右值有所不同，如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。举例:p是int<em>，因为解引用运算符生成左值，所以decltype(</em>p)的结果是int&amp;。另一方面，因为取地址符生成右值，所以decltype(&amp;p)的结果是int**，也就是说，结果是一个指向整型指针的指针。</p>","more":"<p>求值顺序容易产生错误的一点：优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。</p>\n<p><span style=\"color: #ff0000;\">对于没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。举个栗子：</span></p>\n<p>int i;</p>\n<p>cout &lt;&lt; i &lt;&lt; “ “ &lt;&lt;++i &lt;&lt;endl;//是未定义的</p>\n<p>因为程序是未定义的所以，我们无法推断结果。不同的编译器执行的顺序可能不同，有可能先求++i再求i，也有可能先i后++i。</p>\n<p>如果改变了某个运算对象的值，在表达式其他的地方就不要再使用这个运算对象。有一个重要例外就是：表达式*++iter，递增运算符改变iter的值，然后在解引用。因为递增运算（即改变运算对象的子表达式）必须先求值，然后才轮到解引用。</p>\n<p><span style=\"color: #ff0000;\"><strong><em>除法运算规则：</em></strong></span></p>\n<p>(-m)/n和m/(-n)都等于：-(m/n)</p>\n<p>m%(-n)等于m%n</p>\n<p>(-m)%n等于-(m%n)</p>\n<p>即：除法看整体，取余看被除数</p>\n<p>&nbsp;</p>\n<p><strong><span style=\"color: #ff0000;\">前置递增和后置递增：</span></strong></p>\n<p>前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置递增的操作就是一种浪费。</p>\n<p>对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化；但是对于相对复杂的迭代器类型，这种额外的工作消耗就非常大了。建议养成使用前置递增的习惯，这样不用担心性能问题并且写出的代码更符合编程的初衷。</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>"},{"title":"c++标准库 泛型算法","id":"261","date":"2017-07-31T03:06:28.000Z","_content":"\n泛型算法与容器类似，都有一致的结构。除了少数例外，标准库算法都对一个范围内的元素进行操作。\n\n泛型算法的针对对象是容器或者类似于容器类型的迭代器和元素类型的运算法则，而不是针对容器或者类似容器类型。<!--more-->\n\n## 算法和元素类型：\n\naccumulate算法接受三个参数，起点迭代器、尾后迭代器和元素类型。\n\n例如：v是一个vector&lt;int&gt;, int sum = accumulate(v.cbegin(), v.cend(), 0);就是计算v元素的和，第三个参数决定了函数中使用哪个加法运算法则和返回值的类型，序列中元素的类型必须和第三个参数匹配或者能够转换为第三个参数的类型，因此：v中的元素可以是int ,double...\n\n例2：vector&lt;string&gt; ,string sum = accumulate(v.cbegin(),v.cend(), string(\"\"));中第三个参数显式地创建了string的空串。如果直接将字符串字面值空串传给第三个形参是不行的，因为字符串字面值的类型是const char*，并没有+运算符的定义，编译将出错。\n\n* * *\n\n## 特殊的迭代器：插入迭代器back_inserter\n\nfill(begin,end, value);和fill_n(dest,size, value);都需要在空间足够的容器中进行写操作。因为向目的位置迭代器写入数据的算法是假定目的位置空间足够大，能够容纳要写入的元素。\n\n现在一种保证算法有足够空间来容纳输入数据的方法就是使用插入迭代器.back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。通过此迭代器解引用的赋值，赋值运算符会调用push_back将一个具有给定值元素添加到容器中。因此，我们可以很方便的使用空容器来通过算法输入值，例如：\n\nvector&lt;int&gt; vi;//空容器\n\nfill_n(back_inserter(vi), 10, 2);//通过给fill_n传递插入迭代器，向vi中写入10个2；\n\n我们还可以做其他操作，比如：很多算法都提供所谓的拷贝版本，这些算法计算新元素的值，但是不会将它们放置到输入容器的末尾，而是新建一个序列保存。例如：replace的拷贝版本，将替换的值放入新的序列：\n\nvector&lt;int&gt; vi;\n\nreplace_copy(v.begin(), v.end(), back_inserter(vi), 1, 99);//将v中的值为1的元素替换成99，并把值保存到vi。因为vi通过back_inserter()返回了插入迭代器。","source":"_posts/c-e6-a0-87-e5-87-86-e5-ba-93-e6-b3-9b-e5-9e-8b-e7-ae-97-e6-b3-95.md","raw":"---\ntitle: c++标准库 泛型算法\ntags:\n  - c++\nid: 261\ncategories:\n  - c++学习\ndate: 2017-07-31 11:06:28\n---\n\n泛型算法与容器类似，都有一致的结构。除了少数例外，标准库算法都对一个范围内的元素进行操作。\n\n泛型算法的针对对象是容器或者类似于容器类型的迭代器和元素类型的运算法则，而不是针对容器或者类似容器类型。<!--more-->\n\n## 算法和元素类型：\n\naccumulate算法接受三个参数，起点迭代器、尾后迭代器和元素类型。\n\n例如：v是一个vector&lt;int&gt;, int sum = accumulate(v.cbegin(), v.cend(), 0);就是计算v元素的和，第三个参数决定了函数中使用哪个加法运算法则和返回值的类型，序列中元素的类型必须和第三个参数匹配或者能够转换为第三个参数的类型，因此：v中的元素可以是int ,double...\n\n例2：vector&lt;string&gt; ,string sum = accumulate(v.cbegin(),v.cend(), string(\"\"));中第三个参数显式地创建了string的空串。如果直接将字符串字面值空串传给第三个形参是不行的，因为字符串字面值的类型是const char*，并没有+运算符的定义，编译将出错。\n\n* * *\n\n## 特殊的迭代器：插入迭代器back_inserter\n\nfill(begin,end, value);和fill_n(dest,size, value);都需要在空间足够的容器中进行写操作。因为向目的位置迭代器写入数据的算法是假定目的位置空间足够大，能够容纳要写入的元素。\n\n现在一种保证算法有足够空间来容纳输入数据的方法就是使用插入迭代器.back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。通过此迭代器解引用的赋值，赋值运算符会调用push_back将一个具有给定值元素添加到容器中。因此，我们可以很方便的使用空容器来通过算法输入值，例如：\n\nvector&lt;int&gt; vi;//空容器\n\nfill_n(back_inserter(vi), 10, 2);//通过给fill_n传递插入迭代器，向vi中写入10个2；\n\n我们还可以做其他操作，比如：很多算法都提供所谓的拷贝版本，这些算法计算新元素的值，但是不会将它们放置到输入容器的末尾，而是新建一个序列保存。例如：replace的拷贝版本，将替换的值放入新的序列：\n\nvector&lt;int&gt; vi;\n\nreplace_copy(v.begin(), v.end(), back_inserter(vi), 1, 99);//将v中的值为1的元素替换成99，并把值保存到vi。因为vi通过back_inserter()返回了插入迭代器。","slug":"c-e6-a0-87-e5-87-86-e5-ba-93-e6-b3-9b-e5-9e-8b-e7-ae-97-e6-b3-95","published":1,"updated":"2017-12-09T17:06:50.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec0j000xiwtws7c8fbrv","content":"<p>泛型算法与容器类似，都有一致的结构。除了少数例外，标准库算法都对一个范围内的元素进行操作。</p>\n<p>泛型算法的针对对象是容器或者类似于容器类型的迭代器和元素类型的运算法则，而不是针对容器或者类似容器类型。<a id=\"more\"></a></p>\n<h2 id=\"算法和元素类型：\"><a href=\"#算法和元素类型：\" class=\"headerlink\" title=\"算法和元素类型：\"></a>算法和元素类型：</h2><p>accumulate算法接受三个参数，起点迭代器、尾后迭代器和元素类型。</p>\n<p>例如：v是一个vector&lt;int&gt;, int sum = accumulate(v.cbegin(), v.cend(), 0);就是计算v元素的和，第三个参数决定了函数中使用哪个加法运算法则和返回值的类型，序列中元素的类型必须和第三个参数匹配或者能够转换为第三个参数的类型，因此：v中的元素可以是int ,double…</p>\n<p>例2：vector&lt;string&gt; ,string sum = accumulate(v.cbegin(),v.cend(), string(“”));中第三个参数显式地创建了string的空串。如果直接将字符串字面值空串传给第三个形参是不行的，因为字符串字面值的类型是const char*，并没有+运算符的定义，编译将出错。</p>\n<hr>\n<h2 id=\"特殊的迭代器：插入迭代器back-inserter\"><a href=\"#特殊的迭代器：插入迭代器back-inserter\" class=\"headerlink\" title=\"特殊的迭代器：插入迭代器back_inserter\"></a>特殊的迭代器：插入迭代器back_inserter</h2><p>fill(begin,end, value);和fill_n(dest,size, value);都需要在空间足够的容器中进行写操作。因为向目的位置迭代器写入数据的算法是假定目的位置空间足够大，能够容纳要写入的元素。</p>\n<p>现在一种保证算法有足够空间来容纳输入数据的方法就是使用插入迭代器.back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。通过此迭代器解引用的赋值，赋值运算符会调用push_back将一个具有给定值元素添加到容器中。因此，我们可以很方便的使用空容器来通过算法输入值，例如：</p>\n<p>vector&lt;int&gt; vi;//空容器</p>\n<p>fill_n(back_inserter(vi), 10, 2);//通过给fill_n传递插入迭代器，向vi中写入10个2；</p>\n<p>我们还可以做其他操作，比如：很多算法都提供所谓的拷贝版本，这些算法计算新元素的值，但是不会将它们放置到输入容器的末尾，而是新建一个序列保存。例如：replace的拷贝版本，将替换的值放入新的序列：</p>\n<p>vector&lt;int&gt; vi;</p>\n<p>replace_copy(v.begin(), v.end(), back_inserter(vi), 1, 99);//将v中的值为1的元素替换成99，并把值保存到vi。因为vi通过back_inserter()返回了插入迭代器。</p>\n","site":{"data":{}},"excerpt":"<p>泛型算法与容器类似，都有一致的结构。除了少数例外，标准库算法都对一个范围内的元素进行操作。</p>\n<p>泛型算法的针对对象是容器或者类似于容器类型的迭代器和元素类型的运算法则，而不是针对容器或者类似容器类型。","more":"</p>\n<h2 id=\"算法和元素类型：\"><a href=\"#算法和元素类型：\" class=\"headerlink\" title=\"算法和元素类型：\"></a>算法和元素类型：</h2><p>accumulate算法接受三个参数，起点迭代器、尾后迭代器和元素类型。</p>\n<p>例如：v是一个vector&lt;int&gt;, int sum = accumulate(v.cbegin(), v.cend(), 0);就是计算v元素的和，第三个参数决定了函数中使用哪个加法运算法则和返回值的类型，序列中元素的类型必须和第三个参数匹配或者能够转换为第三个参数的类型，因此：v中的元素可以是int ,double…</p>\n<p>例2：vector&lt;string&gt; ,string sum = accumulate(v.cbegin(),v.cend(), string(“”));中第三个参数显式地创建了string的空串。如果直接将字符串字面值空串传给第三个形参是不行的，因为字符串字面值的类型是const char*，并没有+运算符的定义，编译将出错。</p>\n<hr>\n<h2 id=\"特殊的迭代器：插入迭代器back-inserter\"><a href=\"#特殊的迭代器：插入迭代器back-inserter\" class=\"headerlink\" title=\"特殊的迭代器：插入迭代器back_inserter\"></a>特殊的迭代器：插入迭代器back_inserter</h2><p>fill(begin,end, value);和fill_n(dest,size, value);都需要在空间足够的容器中进行写操作。因为向目的位置迭代器写入数据的算法是假定目的位置空间足够大，能够容纳要写入的元素。</p>\n<p>现在一种保证算法有足够空间来容纳输入数据的方法就是使用插入迭代器.back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。通过此迭代器解引用的赋值，赋值运算符会调用push_back将一个具有给定值元素添加到容器中。因此，我们可以很方便的使用空容器来通过算法输入值，例如：</p>\n<p>vector&lt;int&gt; vi;//空容器</p>\n<p>fill_n(back_inserter(vi), 10, 2);//通过给fill_n传递插入迭代器，向vi中写入10个2；</p>\n<p>我们还可以做其他操作，比如：很多算法都提供所谓的拷贝版本，这些算法计算新元素的值，但是不会将它们放置到输入容器的末尾，而是新建一个序列保存。例如：replace的拷贝版本，将替换的值放入新的序列：</p>\n<p>vector&lt;int&gt; vi;</p>\n<p>replace_copy(v.begin(), v.end(), back_inserter(vi), 1, 99);//将v中的值为1的元素替换成99，并把值保存到vi。因为vi通过back_inserter()返回了插入迭代器。</p>"},{"title":"c++ 无序容器的桶管理","id":"337","date":"2017-09-01T15:02:18.000Z","_content":"\n&nbsp;\n\n无序容器在存储上组织为一个“桶”，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个“桶”。容器将具有一个特定哈希值的所有元素都保存在相同的“桶”中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在一个“桶”中。因此，无序容器的性能依赖于哈希函数的质量和“桶”的容量和大小。<!--more-->\n\n对于相同的参数，哈希函数必须总是生成相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的“桶”。但是，将不同关键字的元素映射到相同的“桶” 也是允许的。当一个“桶”保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在“桶”中搜索通常都是很快的操作。但是，如果一个“桶”保存的很多元素，那么查找一个特定的元素就需要大量的比较操作。\n\n无序容器提供了一组管理“桶”的函数，这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。\n\n无序容器有：unordered_set, unordered_map,unordered_multimap, unordered_multiset. 分别定义在unordered_set和unordered_map的头文件中\n\n*   桶接口：\n\n    *   c.bucket_count() 正在使用的桶的数目\n    *   c.max_bucket_count() 容器能容纳的最多的桶的数目\n    *   c.bucket_size(n) 第n个桶中有多少个元素\n    *   c.bucket(k)关键字为k的元素在哪个桶中\n\n*   桶迭代：\n\n    *   local_iterator 可以用来访问桶中元素的迭代类型\n    *   const_local_iterator const版本\n无序容器对关键字类型的要求：默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还是用hash&lt;key_type&gt;类型的对象来生成每个哈希值。标准库为内置类型（包括指针）提供了hash模板。\n\n我们不能直接定义关键字类型为自定义类类型的无序容器，与容器不同，不能直接使用哈希模板，必须提供我们自己的hash模板版本。\n\n&nbsp;\n\n* * *\n\n用无序容器降低时间复杂度，相当是用空间换时间:[leetcode_Two Sum](https://leetcode.com/problems/two-sum/description/)\n\n[cpp]\nclass Solution {\npublic:\n\tvector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n\t\tvector&lt;int&gt; ret;//empty vector\n\t\tunordered_map&lt;int, size_t&gt; m;\n\n\t\tfor (size_t i = 0; i != nums.size(); ++i) {\n\t\t\tm.insert({nums[i], i });\n\t\t}\n\t\tfor (size_t j = 0; j != nums.size(); ++j) {\n\t\t\tint com = target - nums[j];\n\t\t\tif (m.find(com) != m.end() &amp;&amp; m[com] != j) {\n\t\t\t\tret.push_back(j);\n\t\t\t\tret.push_back(m[com]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\n\t\t//Time complexity : O(n)\n\n\t\t//time complexity  O(n^2)\n\t\t/*\n\t\tbool find = false;\n\t\tfor (size_t i = 0; i != nums.size() &amp;&amp; !find; ++i) {\n\t\t\tfor (size_t j = i + 1; j != nums.size() &amp;&amp; !find; ++j) {\n\t\t\t\tif (nums[i] + nums[j] == target) {\n\t\t\t\t\tret.push_back(i);\n\t\t\t\t\tret.push_back(j);\n\t\t\t\t\tfind = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n};\n[/cpp]\n\n注：摘自&lt;&lt;c++ primer&gt;&gt; 第五版","source":"_posts/c-e6-97-a0-e5-ba-8f-e5-ae-b9-e5-99-a8-e7-9a-84-e6-a1-b6-e7-ae-a1-e7-90-86.md","raw":"---\ntitle: c++ 无序容器的桶管理\nid: 337\ncategories:\n  - c++学习\ndate: 2017-09-01 23:02:18\ntags:\n---\n\n&nbsp;\n\n无序容器在存储上组织为一个“桶”，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个“桶”。容器将具有一个特定哈希值的所有元素都保存在相同的“桶”中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在一个“桶”中。因此，无序容器的性能依赖于哈希函数的质量和“桶”的容量和大小。<!--more-->\n\n对于相同的参数，哈希函数必须总是生成相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的“桶”。但是，将不同关键字的元素映射到相同的“桶” 也是允许的。当一个“桶”保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在“桶”中搜索通常都是很快的操作。但是，如果一个“桶”保存的很多元素，那么查找一个特定的元素就需要大量的比较操作。\n\n无序容器提供了一组管理“桶”的函数，这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。\n\n无序容器有：unordered_set, unordered_map,unordered_multimap, unordered_multiset. 分别定义在unordered_set和unordered_map的头文件中\n\n*   桶接口：\n\n    *   c.bucket_count() 正在使用的桶的数目\n    *   c.max_bucket_count() 容器能容纳的最多的桶的数目\n    *   c.bucket_size(n) 第n个桶中有多少个元素\n    *   c.bucket(k)关键字为k的元素在哪个桶中\n\n*   桶迭代：\n\n    *   local_iterator 可以用来访问桶中元素的迭代类型\n    *   const_local_iterator const版本\n无序容器对关键字类型的要求：默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还是用hash&lt;key_type&gt;类型的对象来生成每个哈希值。标准库为内置类型（包括指针）提供了hash模板。\n\n我们不能直接定义关键字类型为自定义类类型的无序容器，与容器不同，不能直接使用哈希模板，必须提供我们自己的hash模板版本。\n\n&nbsp;\n\n* * *\n\n用无序容器降低时间复杂度，相当是用空间换时间:[leetcode_Two Sum](https://leetcode.com/problems/two-sum/description/)\n\n[cpp]\nclass Solution {\npublic:\n\tvector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n\t\tvector&lt;int&gt; ret;//empty vector\n\t\tunordered_map&lt;int, size_t&gt; m;\n\n\t\tfor (size_t i = 0; i != nums.size(); ++i) {\n\t\t\tm.insert({nums[i], i });\n\t\t}\n\t\tfor (size_t j = 0; j != nums.size(); ++j) {\n\t\t\tint com = target - nums[j];\n\t\t\tif (m.find(com) != m.end() &amp;&amp; m[com] != j) {\n\t\t\t\tret.push_back(j);\n\t\t\t\tret.push_back(m[com]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\n\t\t//Time complexity : O(n)\n\n\t\t//time complexity  O(n^2)\n\t\t/*\n\t\tbool find = false;\n\t\tfor (size_t i = 0; i != nums.size() &amp;&amp; !find; ++i) {\n\t\t\tfor (size_t j = i + 1; j != nums.size() &amp;&amp; !find; ++j) {\n\t\t\t\tif (nums[i] + nums[j] == target) {\n\t\t\t\t\tret.push_back(i);\n\t\t\t\t\tret.push_back(j);\n\t\t\t\t\tfind = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n};\n[/cpp]\n\n注：摘自&lt;&lt;c++ primer&gt;&gt; 第五版","slug":"c-e6-97-a0-e5-ba-8f-e5-ae-b9-e5-99-a8-e7-9a-84-e6-a1-b6-e7-ae-a1-e7-90-86","published":1,"updated":"2017-12-09T17:06:50.796Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec0j0011iwtwnmj6ik8p","content":"<p>&nbsp;</p>\n<p>无序容器在存储上组织为一个“桶”，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个“桶”。容器将具有一个特定哈希值的所有元素都保存在相同的“桶”中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在一个“桶”中。因此，无序容器的性能依赖于哈希函数的质量和“桶”的容量和大小。<a id=\"more\"></a></p>\n<p>对于相同的参数，哈希函数必须总是生成相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的“桶”。但是，将不同关键字的元素映射到相同的“桶” 也是允许的。当一个“桶”保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在“桶”中搜索通常都是很快的操作。但是，如果一个“桶”保存的很多元素，那么查找一个特定的元素就需要大量的比较操作。</p>\n<p>无序容器提供了一组管理“桶”的函数，这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。</p>\n<p>无序容器有：unordered_set, unordered_map,unordered_multimap, unordered_multiset. 分别定义在unordered_set和unordered_map的头文件中</p>\n<ul>\n<li><p>桶接口：</p>\n<ul>\n<li>c.bucket_count() 正在使用的桶的数目</li>\n<li>c.max_bucket_count() 容器能容纳的最多的桶的数目</li>\n<li>c.bucket_size(n) 第n个桶中有多少个元素</li>\n<li>c.bucket(k)关键字为k的元素在哪个桶中</li>\n</ul>\n</li>\n<li><p>桶迭代：</p>\n<ul>\n<li>local_iterator 可以用来访问桶中元素的迭代类型</li>\n<li>const_local_iterator const版本<br>无序容器对关键字类型的要求：默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还是用hash&lt;key_type&gt;类型的对象来生成每个哈希值。标准库为内置类型（包括指针）提供了hash模板。</li>\n</ul>\n</li>\n</ul>\n<p>我们不能直接定义关键字类型为自定义类类型的无序容器，与容器不同，不能直接使用哈希模板，必须提供我们自己的hash模板版本。</p>\n<p>&nbsp;</p>\n<hr>\n<p>用无序容器降低时间复杂度，相当是用空间换时间:<a href=\"https://leetcode.com/problems/two-sum/description/\" target=\"_blank\" rel=\"noopener\">leetcode_Two Sum</a></p>\n<p>[cpp]<br>class Solution {<br>public:<br>    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {<br>        vector&lt;int&gt; ret;//empty vector<br>        unordered_map&lt;int, size_t&gt; m;</p>\n<pre><code>    for (size_t i = 0; i != nums.size(); ++i) {\n        m.insert({nums[i], i });\n    }\n    for (size_t j = 0; j != nums.size(); ++j) {\n        int com = target - nums[j];\n        if (m.find(com) != m.end() &amp;amp;&amp;amp; m[com] != j) {\n            ret.push_back(j);\n            ret.push_back(m[com]);\n            break;\n        }\n    }\n\n    return ret;\n\n    //Time complexity : O(n)\n\n    //time complexity  O(n^2)\n    /*\n    bool find = false;\n    for (size_t i = 0; i != nums.size() &amp;amp;&amp;amp; !find; ++i) {\n        for (size_t j = i + 1; j != nums.size() &amp;amp;&amp;amp; !find; ++j) {\n            if (nums[i] + nums[j] == target) {\n                ret.push_back(i);\n                ret.push_back(j);\n                find = true;\n            }\n        }\n    }*/\n}\n</code></pre><p>};<br>[/cpp]</p>\n<p>注：摘自&lt;&lt;c++ primer&gt;&gt; 第五版</p>\n","site":{"data":{}},"excerpt":"<p>&nbsp;</p>\n<p>无序容器在存储上组织为一个“桶”，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个“桶”。容器将具有一个特定哈希值的所有元素都保存在相同的“桶”中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在一个“桶”中。因此，无序容器的性能依赖于哈希函数的质量和“桶”的容量和大小。","more":"</p>\n<p>对于相同的参数，哈希函数必须总是生成相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的“桶”。但是，将不同关键字的元素映射到相同的“桶” 也是允许的。当一个“桶”保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在“桶”中搜索通常都是很快的操作。但是，如果一个“桶”保存的很多元素，那么查找一个特定的元素就需要大量的比较操作。</p>\n<p>无序容器提供了一组管理“桶”的函数，这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。</p>\n<p>无序容器有：unordered_set, unordered_map,unordered_multimap, unordered_multiset. 分别定义在unordered_set和unordered_map的头文件中</p>\n<ul>\n<li><p>桶接口：</p>\n<ul>\n<li>c.bucket_count() 正在使用的桶的数目</li>\n<li>c.max_bucket_count() 容器能容纳的最多的桶的数目</li>\n<li>c.bucket_size(n) 第n个桶中有多少个元素</li>\n<li>c.bucket(k)关键字为k的元素在哪个桶中</li>\n</ul>\n</li>\n<li><p>桶迭代：</p>\n<ul>\n<li>local_iterator 可以用来访问桶中元素的迭代类型</li>\n<li>const_local_iterator const版本<br>无序容器对关键字类型的要求：默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还是用hash&lt;key_type&gt;类型的对象来生成每个哈希值。标准库为内置类型（包括指针）提供了hash模板。</li>\n</ul>\n</li>\n</ul>\n<p>我们不能直接定义关键字类型为自定义类类型的无序容器，与容器不同，不能直接使用哈希模板，必须提供我们自己的hash模板版本。</p>\n<p>&nbsp;</p>\n<hr>\n<p>用无序容器降低时间复杂度，相当是用空间换时间:<a href=\"https://leetcode.com/problems/two-sum/description/\" target=\"_blank\" rel=\"noopener\">leetcode_Two Sum</a></p>\n<p>[cpp]<br>class Solution {<br>public:<br>    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {<br>        vector&lt;int&gt; ret;//empty vector<br>        unordered_map&lt;int, size_t&gt; m;</p>\n<pre><code>    for (size_t i = 0; i != nums.size(); ++i) {\n        m.insert({nums[i], i });\n    }\n    for (size_t j = 0; j != nums.size(); ++j) {\n        int com = target - nums[j];\n        if (m.find(com) != m.end() &amp;amp;&amp;amp; m[com] != j) {\n            ret.push_back(j);\n            ret.push_back(m[com]);\n            break;\n        }\n    }\n\n    return ret;\n\n    //Time complexity : O(n)\n\n    //time complexity  O(n^2)\n    /*\n    bool find = false;\n    for (size_t i = 0; i != nums.size() &amp;amp;&amp;amp; !find; ++i) {\n        for (size_t j = i + 1; j != nums.size() &amp;amp;&amp;amp; !find; ++j) {\n            if (nums[i] + nums[j] == target) {\n                ret.push_back(i);\n                ret.push_back(j);\n                find = true;\n            }\n        }\n    }*/\n}\n</code></pre><p>};<br>[/cpp]</p>\n<p>注：摘自&lt;&lt;c++ primer&gt;&gt; 第五版</p>"},{"title":"c++ 辨析之decltype和auto的使用","id":"243","date":"2017-07-15T09:59:09.000Z","_content":"\n如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。\n\n<span style=\"color: #ff0000;\">_**栗子1:**_</span>\n\nint i=42,*pi=&amp;i, &amp;ri=i;\n\ndecltype(ri) a = i;//a是引用类型\n\ndecltype(ri+0) b;//b是int类型，ri是引用的i，ri+0是int\n\ndecltype(*pi) c = i;//c也是引用类型，因为*pi的解引用操作得到的是指针所指的对象，而且还能给其赋值因此是int&amp;\n\n切记：decltype((variable))的结果永远是引用（有括号的），因为编译器会把它当成一个表达式，这样变量就变成可以作为赋值语句左值的特殊表达式，会被编译成引用类型。\n\n而decltype(variable)的结果只有当variable本身就是一个引用时才是引用。\n\n<!--more-->\n\n* * *\n\n_**<span style=\"color: #ff0000;\">栗子2：auto和decltype 的引用</span>**_\n\nint d=10, &amp;r = d;//d是int，r是int引用绑定d\n\nauto e = r;//e是int\n\ndecltype(r) f = d;//f是引用\n\ne = 100;\n\ncout &lt;&lt; d&lt;&lt;endl;//输出10\n\nf = 100;\n\ncout &lt;&lt; d &lt;&lt; endl;//输出100，说明通过f改变了d，故说明f是d的引用\n\n* * *\n\n_**<span style=\"color: #ff0000;\">栗子3：对指针</span>**_\n\nint a = 10;\n\nauto b = &amp;a;//对a取地址，赋值给b，b也是指针。\n\ndecltype(&amp;a) c = &amp;a;//c也是指针\n\n* * *\n\n_**<span style=\"color: #ff0000;\">栗子4:对数组</span>**_\n\n当使用数组作为一个auto变量的初始化时，推断得到的类型是指针而非数组：\n\nint ia[] = {1,2,3,4,5};//ia是一个含有10个整数的数组\n\nauto ia2(ia);//ia2是一个整型指针，指向ia的第一个元素\n\nia2 = 42;//错误，ia2是一个指针，不能用int来给指针赋值\n\n尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译器都会自动地将其替换为一个指向数组首元素的指针,相当于:**_auto ia2(&amp;ia[0]);//显然ia2的类型是指针_**\n\n但是使用decltype关键字时就不一样了，_**decltype(ia)得到的是由10个整数构成的数组；**_\n\n数组是在内存中连续的区域，而指针只是一个存地址的内存对象。\n\n&nbsp;\n\n以上，总结说明decltype得到的是表达式的具体类型","source":"_posts/c-e8-be-a8-e6-9e-90-e4-b9-8bdecltype-e5-92-8cauto-e7-9a-84-e4-bd-bf-e7-94-a8.md","raw":"---\ntitle: c++ 辨析之decltype和auto的使用\ntags:\n  - c++\nid: 243\ncategories:\n  - c++学习\ndate: 2017-07-15 17:59:09\n---\n\n如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。\n\n<span style=\"color: #ff0000;\">_**栗子1:**_</span>\n\nint i=42,*pi=&amp;i, &amp;ri=i;\n\ndecltype(ri) a = i;//a是引用类型\n\ndecltype(ri+0) b;//b是int类型，ri是引用的i，ri+0是int\n\ndecltype(*pi) c = i;//c也是引用类型，因为*pi的解引用操作得到的是指针所指的对象，而且还能给其赋值因此是int&amp;\n\n切记：decltype((variable))的结果永远是引用（有括号的），因为编译器会把它当成一个表达式，这样变量就变成可以作为赋值语句左值的特殊表达式，会被编译成引用类型。\n\n而decltype(variable)的结果只有当variable本身就是一个引用时才是引用。\n\n<!--more-->\n\n* * *\n\n_**<span style=\"color: #ff0000;\">栗子2：auto和decltype 的引用</span>**_\n\nint d=10, &amp;r = d;//d是int，r是int引用绑定d\n\nauto e = r;//e是int\n\ndecltype(r) f = d;//f是引用\n\ne = 100;\n\ncout &lt;&lt; d&lt;&lt;endl;//输出10\n\nf = 100;\n\ncout &lt;&lt; d &lt;&lt; endl;//输出100，说明通过f改变了d，故说明f是d的引用\n\n* * *\n\n_**<span style=\"color: #ff0000;\">栗子3：对指针</span>**_\n\nint a = 10;\n\nauto b = &amp;a;//对a取地址，赋值给b，b也是指针。\n\ndecltype(&amp;a) c = &amp;a;//c也是指针\n\n* * *\n\n_**<span style=\"color: #ff0000;\">栗子4:对数组</span>**_\n\n当使用数组作为一个auto变量的初始化时，推断得到的类型是指针而非数组：\n\nint ia[] = {1,2,3,4,5};//ia是一个含有10个整数的数组\n\nauto ia2(ia);//ia2是一个整型指针，指向ia的第一个元素\n\nia2 = 42;//错误，ia2是一个指针，不能用int来给指针赋值\n\n尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译器都会自动地将其替换为一个指向数组首元素的指针,相当于:**_auto ia2(&amp;ia[0]);//显然ia2的类型是指针_**\n\n但是使用decltype关键字时就不一样了，_**decltype(ia)得到的是由10个整数构成的数组；**_\n\n数组是在内存中连续的区域，而指针只是一个存地址的内存对象。\n\n&nbsp;\n\n以上，总结说明decltype得到的是表达式的具体类型","slug":"c-e8-be-a8-e6-9e-90-e4-b9-8bdecltype-e5-92-8cauto-e7-9a-84-e4-bd-bf-e7-94-a8","published":1,"updated":"2017-12-09T17:06:50.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec0j0014iwtw2e2nv6qh","content":"<p>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。</p>\n<p><span style=\"color: #ff0000;\"><em><strong>栗子1:</strong></em></span></p>\n<p>int i=42,*pi=&amp;i, &amp;ri=i;</p>\n<p>decltype(ri) a = i;//a是引用类型</p>\n<p>decltype(ri+0) b;//b是int类型，ri是引用的i，ri+0是int</p>\n<p>decltype(<em>pi) c = i;//c也是引用类型，因为</em>pi的解引用操作得到的是指针所指的对象，而且还能给其赋值因此是int&amp;</p>\n<p>切记：decltype((variable))的结果永远是引用（有括号的），因为编译器会把它当成一个表达式，这样变量就变成可以作为赋值语句左值的特殊表达式，会被编译成引用类型。</p>\n<p>而decltype(variable)的结果只有当variable本身就是一个引用时才是引用。</p>\n<a id=\"more\"></a>\n<hr>\n<p><em><strong><span style=\"color: #ff0000;\">栗子2：auto和decltype 的引用</span></strong></em></p>\n<p>int d=10, &amp;r = d;//d是int，r是int引用绑定d</p>\n<p>auto e = r;//e是int</p>\n<p>decltype(r) f = d;//f是引用</p>\n<p>e = 100;</p>\n<p>cout &lt;&lt; d&lt;&lt;endl;//输出10</p>\n<p>f = 100;</p>\n<p>cout &lt;&lt; d &lt;&lt; endl;//输出100，说明通过f改变了d，故说明f是d的引用</p>\n<hr>\n<p><em><strong><span style=\"color: #ff0000;\">栗子3：对指针</span></strong></em></p>\n<p>int a = 10;</p>\n<p>auto b = &amp;a;//对a取地址，赋值给b，b也是指针。</p>\n<p>decltype(&amp;a) c = &amp;a;//c也是指针</p>\n<hr>\n<p><em><strong><span style=\"color: #ff0000;\">栗子4:对数组</span></strong></em></p>\n<p>当使用数组作为一个auto变量的初始化时，推断得到的类型是指针而非数组：</p>\n<p>int ia[] = {1,2,3,4,5};//ia是一个含有10个整数的数组</p>\n<p>auto ia2(ia);//ia2是一个整型指针，指向ia的第一个元素</p>\n<p>ia2 = 42;//错误，ia2是一个指针，不能用int来给指针赋值</p>\n<p>尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译器都会自动地将其替换为一个指向数组首元素的指针,相当于:<strong><em>auto ia2(&amp;ia[0]);//显然ia2的类型是指针</em></strong></p>\n<p>但是使用decltype关键字时就不一样了，<em><strong>decltype(ia)得到的是由10个整数构成的数组；</strong></em></p>\n<p>数组是在内存中连续的区域，而指针只是一个存地址的内存对象。</p>\n<p>&nbsp;</p>\n<p>以上，总结说明decltype得到的是表达式的具体类型</p>\n","site":{"data":{}},"excerpt":"<p>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。</p>\n<p><span style=\"color: #ff0000;\"><em><strong>栗子1:</strong></em></span></p>\n<p>int i=42,*pi=&amp;i, &amp;ri=i;</p>\n<p>decltype(ri) a = i;//a是引用类型</p>\n<p>decltype(ri+0) b;//b是int类型，ri是引用的i，ri+0是int</p>\n<p>decltype(<em>pi) c = i;//c也是引用类型，因为</em>pi的解引用操作得到的是指针所指的对象，而且还能给其赋值因此是int&amp;</p>\n<p>切记：decltype((variable))的结果永远是引用（有括号的），因为编译器会把它当成一个表达式，这样变量就变成可以作为赋值语句左值的特殊表达式，会被编译成引用类型。</p>\n<p>而decltype(variable)的结果只有当variable本身就是一个引用时才是引用。</p>","more":"<hr>\n<p><em><strong><span style=\"color: #ff0000;\">栗子2：auto和decltype 的引用</span></strong></em></p>\n<p>int d=10, &amp;r = d;//d是int，r是int引用绑定d</p>\n<p>auto e = r;//e是int</p>\n<p>decltype(r) f = d;//f是引用</p>\n<p>e = 100;</p>\n<p>cout &lt;&lt; d&lt;&lt;endl;//输出10</p>\n<p>f = 100;</p>\n<p>cout &lt;&lt; d &lt;&lt; endl;//输出100，说明通过f改变了d，故说明f是d的引用</p>\n<hr>\n<p><em><strong><span style=\"color: #ff0000;\">栗子3：对指针</span></strong></em></p>\n<p>int a = 10;</p>\n<p>auto b = &amp;a;//对a取地址，赋值给b，b也是指针。</p>\n<p>decltype(&amp;a) c = &amp;a;//c也是指针</p>\n<hr>\n<p><em><strong><span style=\"color: #ff0000;\">栗子4:对数组</span></strong></em></p>\n<p>当使用数组作为一个auto变量的初始化时，推断得到的类型是指针而非数组：</p>\n<p>int ia[] = {1,2,3,4,5};//ia是一个含有10个整数的数组</p>\n<p>auto ia2(ia);//ia2是一个整型指针，指向ia的第一个元素</p>\n<p>ia2 = 42;//错误，ia2是一个指针，不能用int来给指针赋值</p>\n<p>尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译器都会自动地将其替换为一个指向数组首元素的指针,相当于:<strong><em>auto ia2(&amp;ia[0]);//显然ia2的类型是指针</em></strong></p>\n<p>但是使用decltype关键字时就不一样了，<em><strong>decltype(ia)得到的是由10个整数构成的数组；</strong></em></p>\n<p>数组是在内存中连续的区域，而指针只是一个存地址的内存对象。</p>\n<p>&nbsp;</p>\n<p>以上，总结说明decltype得到的是表达式的具体类型</p>"},{"title":"前端笔记之CSS","id":"294","date":"2017-08-11T07:35:49.000Z","_content":"\ncss 样式由**选择符**和**声明**组成，而**声明**又由**属性**和**值**组成:![](http://www.alanpro.win/wp-content/uploads/2017/08/css.png)\n\n**选择符：**又称选择器，指明网页中要应用样式规则的元素，如本例中是网页中所有的段（p）的文字将变成蓝色，而其他的元素（如ol）不会受到影响。\n\n**声明：**在英文大括号“｛｝”中的的就是声明，属性和值之间用英文冒号“：”分隔。当有多条声明时，中间可以英文分号“;”分隔，如下所示：<!--more-->\n\np{\n\nfont-size:12px;\n\ncolor:red;\n\n}\n\nCSS样式可以写在哪些地方呢？从CSS 样式代码插入的形式来看基本可以分为以下3种：内联式(直接写在开始的style属性里)、嵌入式(将css放在style标签中，并将标签放在head中)和外部式(&lt;link href=\"**base.css**\" rel=\"stylesheet\" type=\"text/css\" /&gt;)三种.\n\n三者的优先级：内联式 &gt; 嵌入式 &gt; 外部式---&gt;总结来说，就是--就近原则（离被设置元素越近优先级别越高）。\n\n* * *\n\n选择器：\n\n类选择器在css样式编码中是最常用到的。\n\n语法：\n\n.类选器名称{css样式代码;}\n\n使用的时候，在标签内加class=\"类选择器名称\".注意设置类选择器的时候，名字前面要用英文的\".\"\n\nid选择器：#id选择器名称{...}\n\n在使用的时候，加上id=\"id选择器名称\"\n\n### id选择器和类选择器的异同点：\n\n**相同点：**可以应用于任何元素\n**不同点：**\n\n1、**ID选择器只能在文档中使用一次**。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而类选择器可以使用多次。\n\n2、**可以使用类选择器词列表方法为一个元素同时设置多个样式。**我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（**不能使用 ID 词列表）。**\n\n### 子选择器：（直接后代）\n\n即大于符号(&gt;),用于选择指定标签元素的**第一代子元素。**如右侧代码编辑器中的代码：\n\n.food&gt;li{border:1px solid red;}\n这行代码会使class名为food下的子元素li加入红色实线边框。\n\n### 包含选择器：\n\n即加入空格,用于选择指定标签元素下的**后辈元素。**\n\n请注意这个选择器与子选择器的区别，子选择器（child selector）仅是指它的直接后代，或者你可以理解为作用于子元素的第一代后代。而后代选择器是作用于所有子后代元素。\n\n通用选择器：*{..}，应用于所有html标签内容\n\n### 伪类选择符：\n\n它允许给html不存在的标签（标签的某种状态）设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色：\n\n<pre class=\"code\">a:hover{color:red;}</pre>\n上面一行代码就是为 a 标签鼠标滑过的状态设置字体颜色变红。这样就会使第一段文字内容中的“胆小如鼠”文字加入**鼠标滑过**字体颜色变为红色特效。 一般伪类选择符是a:hover的用法\n\n&nbsp;\n\n* * *\n\n浏览器会根据权值来判断使用哪种css样式：**标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100**\n\n* * *\n\ncss的格式化排版：\n\n字体：font-family\n\n字号：font-size\n\n粗体：font-weight:bold\n\n斜体：font-style:italic\n\n下划线：text-decoration:underline\n\n删除线：text-decoration:lint-through\n\n缩进：text-indent:2em\n\n行高/行间距：line-height:2em\n\n字间距：word-spacing:50px\n\n对齐：text-align:center\n\n* * *\n\n元素分类：<span style=\"color: #ff0000;\">块状元素、内联元素、内联块状元素</span>。可以通过display属性来设置分别是：block/inline/inline-block\n\n<span style=\"color: #ff0000;\">块状元素（&lt;div&gt;、 &lt;p&gt;、&lt;h1&gt;、&lt;form&gt;、&lt;ul&gt; 和 &lt;li&gt;）</span>的特点：在不设置宽度的情况下，显示为父容器的100%、元素的高度、宽度、行高、顶和底边距都可以设置\n\n<span style=\"color: #ff0000;\">内联元素（&lt;span&gt;、&lt;a&gt;、&lt;label&gt;、 &lt;strong&gt; 和&lt;em&gt;）</span>的特点：和其他元素都在一行上；元素的高度、宽度及顶部和底部边距<span style=\"color: #ff0000;\">**不可**</span>设置；元素的宽度就是它包含的文字或图片的宽度，<span style=\"color: #ff0000;\">不可</span>改变。\n\n<span style=\"color: #ff0000;\">内联块状元素（&lt;img&gt;、&lt;input&gt;）</span>的特点：和其他元素都在一行上；<span style=\"color: #ff0000;\">元素的高度、宽度、行高以及顶和底边距都可设置。</span>\n\n盒子模型：块状标签都具有盒子模型的特征。[http://zh.learnlayout.com/](http://zh.learnlayout.com/)\n\n&nbsp;\n\n内填充padding\n\n外边距margin\n\n边框border\n\n它们都是有方向的：\n\n![](http://www.alanpro.win/wp-content/uploads/2017/08/padding-1024x615.png)\n\n同padding，margin和border也有上下左右四个方向\n\n盒模型的元素的实际宽度（盒子的宽度）：![](http://www.alanpro.win/wp-content/uploads/2017/08/盒模型的宽度图.jpg)\n\n总结一下：padding和margin的区别，padding在边框里，margin在边框外。\n\n* * *\n\n在网页中，元素有三种布局模型：\n1、流动模型（Flow）默认的网页布局模式。a)**块状元素**都会在所处的**包含元素内**自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为**100%。b)内联 元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行）(em/a/span/strong都是内联元素)**\n2、浮动模型 (Float)可以在选择器中设置float属性来让块状元素浮动，让它们不占有一行\n3、层模型（Layer）三种形式：**绝对定位**(position: absolute)、**相对定位**(position: relative)、**固定定位**(position: fixed)\n\nrelative和absolute可以组合使用，不过relative需要是absolute的父标签。\n\n* * *\n\n适当的运用css代码缩写，占用更少的带宽。盒模型、颜色、字体都可以缩写\n\n长度值：目前比较常用到px（像素）、em、% 百分比，要注意其实这三种单位都是相对单位。px是相对于显示器的小点、em是相对于设置的font-size、行高行间距也是以font-size为参照的\n\n* * *\n\n水平居中：\n\n行内元素：当被设置的元素是文本、图片等行内元素时，水平居中通过父元素设置：text-align:center;\n\n如果被设置的元素不是行内元素，而是块状元素的话，就不能用这个方法了：\n\n定宽块状元素：可以指定宽度width,将它设置为固定值。满足定宽和块状两个条件的元素是可以通过设置“左右margin”值为“auto”来实现居中的。\n\n<span style=\"color: #ff0000;\">不定宽块状元素</span>：网页上的分页导航，因为分页的数量是不确定的，所以我们不能通过设置宽度来限制它的弹性。<span lang=\"EN-US\">(</span>不定宽块状元素：块状元素的宽度<span lang=\"EN-US\">width</span>不固定)\n\n1.  方法1：加入table标签，因为它是长度自适应性的，长度是根据其内文本长度决定，用margin:0px auto;上下外边距为0，左右自动\n2.  方法2：改变元素的display类型为inline，就变成了行内元素，然后用text-align:center来设置居中效果。\n3.  方法3：通过给父元素设置<span lang=\"EN-US\"> float</span>，然后给父元素设置 <span lang=\"EN-US\">position:relative</span><span lang=\"EN-US\"> </span>和<span lang=\"EN-US\"> left:50%</span>，子元素设置<span lang=\"EN-US\"> position:relative </span>和<span lang=\"EN-US\"> left: </span><span lang=\"EN-US\">-50%</span><span lang=\"EN-US\"> </span>来实现水平居中。","source":"_posts/e5-89-8d-e7-ab-af-e7-ac-94-e8-ae-b0.md","raw":"---\ntitle: 前端笔记之CSS\ntags:\n  - 前端\nid: 294\ncategories:\n  - web学习整理\ndate: 2017-08-11 15:35:49\n---\n\ncss 样式由**选择符**和**声明**组成，而**声明**又由**属性**和**值**组成:![](http://www.alanpro.win/wp-content/uploads/2017/08/css.png)\n\n**选择符：**又称选择器，指明网页中要应用样式规则的元素，如本例中是网页中所有的段（p）的文字将变成蓝色，而其他的元素（如ol）不会受到影响。\n\n**声明：**在英文大括号“｛｝”中的的就是声明，属性和值之间用英文冒号“：”分隔。当有多条声明时，中间可以英文分号“;”分隔，如下所示：<!--more-->\n\np{\n\nfont-size:12px;\n\ncolor:red;\n\n}\n\nCSS样式可以写在哪些地方呢？从CSS 样式代码插入的形式来看基本可以分为以下3种：内联式(直接写在开始的style属性里)、嵌入式(将css放在style标签中，并将标签放在head中)和外部式(&lt;link href=\"**base.css**\" rel=\"stylesheet\" type=\"text/css\" /&gt;)三种.\n\n三者的优先级：内联式 &gt; 嵌入式 &gt; 外部式---&gt;总结来说，就是--就近原则（离被设置元素越近优先级别越高）。\n\n* * *\n\n选择器：\n\n类选择器在css样式编码中是最常用到的。\n\n语法：\n\n.类选器名称{css样式代码;}\n\n使用的时候，在标签内加class=\"类选择器名称\".注意设置类选择器的时候，名字前面要用英文的\".\"\n\nid选择器：#id选择器名称{...}\n\n在使用的时候，加上id=\"id选择器名称\"\n\n### id选择器和类选择器的异同点：\n\n**相同点：**可以应用于任何元素\n**不同点：**\n\n1、**ID选择器只能在文档中使用一次**。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而类选择器可以使用多次。\n\n2、**可以使用类选择器词列表方法为一个元素同时设置多个样式。**我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（**不能使用 ID 词列表）。**\n\n### 子选择器：（直接后代）\n\n即大于符号(&gt;),用于选择指定标签元素的**第一代子元素。**如右侧代码编辑器中的代码：\n\n.food&gt;li{border:1px solid red;}\n这行代码会使class名为food下的子元素li加入红色实线边框。\n\n### 包含选择器：\n\n即加入空格,用于选择指定标签元素下的**后辈元素。**\n\n请注意这个选择器与子选择器的区别，子选择器（child selector）仅是指它的直接后代，或者你可以理解为作用于子元素的第一代后代。而后代选择器是作用于所有子后代元素。\n\n通用选择器：*{..}，应用于所有html标签内容\n\n### 伪类选择符：\n\n它允许给html不存在的标签（标签的某种状态）设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色：\n\n<pre class=\"code\">a:hover{color:red;}</pre>\n上面一行代码就是为 a 标签鼠标滑过的状态设置字体颜色变红。这样就会使第一段文字内容中的“胆小如鼠”文字加入**鼠标滑过**字体颜色变为红色特效。 一般伪类选择符是a:hover的用法\n\n&nbsp;\n\n* * *\n\n浏览器会根据权值来判断使用哪种css样式：**标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100**\n\n* * *\n\ncss的格式化排版：\n\n字体：font-family\n\n字号：font-size\n\n粗体：font-weight:bold\n\n斜体：font-style:italic\n\n下划线：text-decoration:underline\n\n删除线：text-decoration:lint-through\n\n缩进：text-indent:2em\n\n行高/行间距：line-height:2em\n\n字间距：word-spacing:50px\n\n对齐：text-align:center\n\n* * *\n\n元素分类：<span style=\"color: #ff0000;\">块状元素、内联元素、内联块状元素</span>。可以通过display属性来设置分别是：block/inline/inline-block\n\n<span style=\"color: #ff0000;\">块状元素（&lt;div&gt;、 &lt;p&gt;、&lt;h1&gt;、&lt;form&gt;、&lt;ul&gt; 和 &lt;li&gt;）</span>的特点：在不设置宽度的情况下，显示为父容器的100%、元素的高度、宽度、行高、顶和底边距都可以设置\n\n<span style=\"color: #ff0000;\">内联元素（&lt;span&gt;、&lt;a&gt;、&lt;label&gt;、 &lt;strong&gt; 和&lt;em&gt;）</span>的特点：和其他元素都在一行上；元素的高度、宽度及顶部和底部边距<span style=\"color: #ff0000;\">**不可**</span>设置；元素的宽度就是它包含的文字或图片的宽度，<span style=\"color: #ff0000;\">不可</span>改变。\n\n<span style=\"color: #ff0000;\">内联块状元素（&lt;img&gt;、&lt;input&gt;）</span>的特点：和其他元素都在一行上；<span style=\"color: #ff0000;\">元素的高度、宽度、行高以及顶和底边距都可设置。</span>\n\n盒子模型：块状标签都具有盒子模型的特征。[http://zh.learnlayout.com/](http://zh.learnlayout.com/)\n\n&nbsp;\n\n内填充padding\n\n外边距margin\n\n边框border\n\n它们都是有方向的：\n\n![](http://www.alanpro.win/wp-content/uploads/2017/08/padding-1024x615.png)\n\n同padding，margin和border也有上下左右四个方向\n\n盒模型的元素的实际宽度（盒子的宽度）：![](http://www.alanpro.win/wp-content/uploads/2017/08/盒模型的宽度图.jpg)\n\n总结一下：padding和margin的区别，padding在边框里，margin在边框外。\n\n* * *\n\n在网页中，元素有三种布局模型：\n1、流动模型（Flow）默认的网页布局模式。a)**块状元素**都会在所处的**包含元素内**自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为**100%。b)内联 元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行）(em/a/span/strong都是内联元素)**\n2、浮动模型 (Float)可以在选择器中设置float属性来让块状元素浮动，让它们不占有一行\n3、层模型（Layer）三种形式：**绝对定位**(position: absolute)、**相对定位**(position: relative)、**固定定位**(position: fixed)\n\nrelative和absolute可以组合使用，不过relative需要是absolute的父标签。\n\n* * *\n\n适当的运用css代码缩写，占用更少的带宽。盒模型、颜色、字体都可以缩写\n\n长度值：目前比较常用到px（像素）、em、% 百分比，要注意其实这三种单位都是相对单位。px是相对于显示器的小点、em是相对于设置的font-size、行高行间距也是以font-size为参照的\n\n* * *\n\n水平居中：\n\n行内元素：当被设置的元素是文本、图片等行内元素时，水平居中通过父元素设置：text-align:center;\n\n如果被设置的元素不是行内元素，而是块状元素的话，就不能用这个方法了：\n\n定宽块状元素：可以指定宽度width,将它设置为固定值。满足定宽和块状两个条件的元素是可以通过设置“左右margin”值为“auto”来实现居中的。\n\n<span style=\"color: #ff0000;\">不定宽块状元素</span>：网页上的分页导航，因为分页的数量是不确定的，所以我们不能通过设置宽度来限制它的弹性。<span lang=\"EN-US\">(</span>不定宽块状元素：块状元素的宽度<span lang=\"EN-US\">width</span>不固定)\n\n1.  方法1：加入table标签，因为它是长度自适应性的，长度是根据其内文本长度决定，用margin:0px auto;上下外边距为0，左右自动\n2.  方法2：改变元素的display类型为inline，就变成了行内元素，然后用text-align:center来设置居中效果。\n3.  方法3：通过给父元素设置<span lang=\"EN-US\"> float</span>，然后给父元素设置 <span lang=\"EN-US\">position:relative</span><span lang=\"EN-US\"> </span>和<span lang=\"EN-US\"> left:50%</span>，子元素设置<span lang=\"EN-US\"> position:relative </span>和<span lang=\"EN-US\"> left: </span><span lang=\"EN-US\">-50%</span><span lang=\"EN-US\"> </span>来实现水平居中。","slug":"e5-89-8d-e7-ab-af-e7-ac-94-e8-ae-b0","published":1,"updated":"2017-12-09T17:06:50.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec0t0018iwtwwj3grs5n","content":"<p>css 样式由<strong>选择符</strong>和<strong>声明</strong>组成，而<strong>声明</strong>又由<strong>属性</strong>和<strong>值</strong>组成:<img src=\"http://www.alanpro.win/wp-content/uploads/2017/08/css.png\" alt=\"\"></p>\n<p><strong>选择符：</strong>又称选择器，指明网页中要应用样式规则的元素，如本例中是网页中所有的段（p）的文字将变成蓝色，而其他的元素（如ol）不会受到影响。</p>\n<p><strong>声明：</strong>在英文大括号“｛｝”中的的就是声明，属性和值之间用英文冒号“：”分隔。当有多条声明时，中间可以英文分号“;”分隔，如下所示：<a id=\"more\"></a></p>\n<p>p{</p>\n<p>font-size:12px;</p>\n<p>color:red;</p>\n<p>}</p>\n<p>CSS样式可以写在哪些地方呢？从CSS 样式代码插入的形式来看基本可以分为以下3种：内联式(直接写在开始的style属性里)、嵌入式(将css放在style标签中，并将标签放在head中)和外部式(&lt;link href=”<strong>base.css</strong>“ rel=”stylesheet” type=”text/css” /&gt;)三种.</p>\n<p>三者的优先级：内联式 &gt; 嵌入式 &gt; 外部式—&gt;总结来说，就是–就近原则（离被设置元素越近优先级别越高）。</p>\n<hr>\n<p>选择器：</p>\n<p>类选择器在css样式编码中是最常用到的。</p>\n<p>语法：</p>\n<p>.类选器名称{css样式代码;}</p>\n<p>使用的时候，在标签内加class=”类选择器名称”.注意设置类选择器的时候，名字前面要用英文的”.”</p>\n<p>id选择器：#id选择器名称{…}</p>\n<p>在使用的时候，加上id=”id选择器名称”</p>\n<h3 id=\"id选择器和类选择器的异同点：\"><a href=\"#id选择器和类选择器的异同点：\" class=\"headerlink\" title=\"id选择器和类选择器的异同点：\"></a>id选择器和类选择器的异同点：</h3><p><strong>相同点：</strong>可以应用于任何元素<br><strong>不同点：</strong></p>\n<p>1、<strong>ID选择器只能在文档中使用一次</strong>。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而类选择器可以使用多次。</p>\n<p>2、<strong>可以使用类选择器词列表方法为一个元素同时设置多个样式。</strong>我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（<strong>不能使用 ID 词列表）。</strong></p>\n<h3 id=\"子选择器：（直接后代）\"><a href=\"#子选择器：（直接后代）\" class=\"headerlink\" title=\"子选择器：（直接后代）\"></a>子选择器：（直接后代）</h3><p>即大于符号(&gt;),用于选择指定标签元素的<strong>第一代子元素。</strong>如右侧代码编辑器中的代码：</p>\n<p>.food&gt;li{border:1px solid red;}<br>这行代码会使class名为food下的子元素li加入红色实线边框。</p>\n<h3 id=\"包含选择器：\"><a href=\"#包含选择器：\" class=\"headerlink\" title=\"包含选择器：\"></a>包含选择器：</h3><p>即加入空格,用于选择指定标签元素下的<strong>后辈元素。</strong></p>\n<p>请注意这个选择器与子选择器的区别，子选择器（child selector）仅是指它的直接后代，或者你可以理解为作用于子元素的第一代后代。而后代选择器是作用于所有子后代元素。</p>\n<p>通用选择器：*{..}，应用于所有html标签内容</p>\n<h3 id=\"伪类选择符：\"><a href=\"#伪类选择符：\" class=\"headerlink\" title=\"伪类选择符：\"></a>伪类选择符：</h3><p>它允许给html不存在的标签（标签的某种状态）设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色：</p>\n<p><pre class=\"code\">a:hover{color:red;}</pre><br>上面一行代码就是为 a 标签鼠标滑过的状态设置字体颜色变红。这样就会使第一段文字内容中的“胆小如鼠”文字加入<strong>鼠标滑过</strong>字体颜色变为红色特效。 一般伪类选择符是a:hover的用法</p>\n<p>&nbsp;</p>\n<hr>\n<p>浏览器会根据权值来判断使用哪种css样式：<strong>标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100</strong></p>\n<hr>\n<p>css的格式化排版：</p>\n<p>字体：font-family</p>\n<p>字号：font-size</p>\n<p>粗体：font-weight:bold</p>\n<p>斜体：font-style:italic</p>\n<p>下划线：text-decoration:underline</p>\n<p>删除线：text-decoration:lint-through</p>\n<p>缩进：text-indent:2em</p>\n<p>行高/行间距：line-height:2em</p>\n<p>字间距：word-spacing:50px</p>\n<p>对齐：text-align:center</p>\n<hr>\n<p>元素分类：<span style=\"color: #ff0000;\">块状元素、内联元素、内联块状元素</span>。可以通过display属性来设置分别是：block/inline/inline-block</p>\n<p><span style=\"color: #ff0000;\">块状元素（&lt;div&gt;、 &lt;p&gt;、&lt;h1&gt;、&lt;form&gt;、&lt;ul&gt; 和 &lt;li&gt;）</span>的特点：在不设置宽度的情况下，显示为父容器的100%、元素的高度、宽度、行高、顶和底边距都可以设置</p>\n<p><span style=\"color: #ff0000;\">内联元素（&lt;span&gt;、&lt;a&gt;、&lt;label&gt;、 &lt;strong&gt; 和&lt;em&gt;）</span>的特点：和其他元素都在一行上；元素的高度、宽度及顶部和底部边距<span style=\"color: #ff0000;\"><strong>不可</strong></span>设置；元素的宽度就是它包含的文字或图片的宽度，<span style=\"color: #ff0000;\">不可</span>改变。</p>\n<p><span style=\"color: #ff0000;\">内联块状元素（&lt;img&gt;、&lt;input&gt;）</span>的特点：和其他元素都在一行上；<span style=\"color: #ff0000;\">元素的高度、宽度、行高以及顶和底边距都可设置。</span></p>\n<p>盒子模型：块状标签都具有盒子模型的特征。<a href=\"http://zh.learnlayout.com/\" target=\"_blank\" rel=\"noopener\">http://zh.learnlayout.com/</a></p>\n<p>&nbsp;</p>\n<p>内填充padding</p>\n<p>外边距margin</p>\n<p>边框border</p>\n<p>它们都是有方向的：</p>\n<p><img src=\"http://www.alanpro.win/wp-content/uploads/2017/08/padding-1024x615.png\" alt=\"\"></p>\n<p>同padding，margin和border也有上下左右四个方向</p>\n<p>盒模型的元素的实际宽度（盒子的宽度）：<img src=\"http://www.alanpro.win/wp-content/uploads/2017/08/盒模型的宽度图.jpg\" alt=\"\"></p>\n<p>总结一下：padding和margin的区别，padding在边框里，margin在边框外。</p>\n<hr>\n<p>在网页中，元素有三种布局模型：<br>1、流动模型（Flow）默认的网页布局模式。a)<strong>块状元素</strong>都会在所处的<strong>包含元素内</strong>自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为<strong>100%。b)内联 元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行）(em/a/span/strong都是内联元素)</strong><br>2、浮动模型 (Float)可以在选择器中设置float属性来让块状元素浮动，让它们不占有一行<br>3、层模型（Layer）三种形式：<strong>绝对定位</strong>(position: absolute)、<strong>相对定位</strong>(position: relative)、<strong>固定定位</strong>(position: fixed)</p>\n<p>relative和absolute可以组合使用，不过relative需要是absolute的父标签。</p>\n<hr>\n<p>适当的运用css代码缩写，占用更少的带宽。盒模型、颜色、字体都可以缩写</p>\n<p>长度值：目前比较常用到px（像素）、em、% 百分比，要注意其实这三种单位都是相对单位。px是相对于显示器的小点、em是相对于设置的font-size、行高行间距也是以font-size为参照的</p>\n<hr>\n<p>水平居中：</p>\n<p>行内元素：当被设置的元素是文本、图片等行内元素时，水平居中通过父元素设置：text-align:center;</p>\n<p>如果被设置的元素不是行内元素，而是块状元素的话，就不能用这个方法了：</p>\n<p>定宽块状元素：可以指定宽度width,将它设置为固定值。满足定宽和块状两个条件的元素是可以通过设置“左右margin”值为“auto”来实现居中的。</p>\n<p><span style=\"color: #ff0000;\">不定宽块状元素</span>：网页上的分页导航，因为分页的数量是不确定的，所以我们不能通过设置宽度来限制它的弹性。<span lang=\"EN-US\">(</span>不定宽块状元素：块状元素的宽度<span lang=\"EN-US\">width</span>不固定)</p>\n<ol>\n<li>方法1：加入table标签，因为它是长度自适应性的，长度是根据其内文本长度决定，用margin:0px auto;上下外边距为0，左右自动</li>\n<li>方法2：改变元素的display类型为inline，就变成了行内元素，然后用text-align:center来设置居中效果。</li>\n<li>方法3：通过给父元素设置<span lang=\"EN-US\"> float</span>，然后给父元素设置 <span lang=\"EN-US\">position:relative</span><span lang=\"EN-US\"> </span>和<span lang=\"EN-US\"> left:50%</span>，子元素设置<span lang=\"EN-US\"> position:relative </span>和<span lang=\"EN-US\"> left: </span><span lang=\"EN-US\">-50%</span><span lang=\"EN-US\"> </span>来实现水平居中。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>css 样式由<strong>选择符</strong>和<strong>声明</strong>组成，而<strong>声明</strong>又由<strong>属性</strong>和<strong>值</strong>组成:<img src=\"http://www.alanpro.win/wp-content/uploads/2017/08/css.png\" alt=\"\"></p>\n<p><strong>选择符：</strong>又称选择器，指明网页中要应用样式规则的元素，如本例中是网页中所有的段（p）的文字将变成蓝色，而其他的元素（如ol）不会受到影响。</p>\n<p><strong>声明：</strong>在英文大括号“｛｝”中的的就是声明，属性和值之间用英文冒号“：”分隔。当有多条声明时，中间可以英文分号“;”分隔，如下所示：","more":"</p>\n<p>p{</p>\n<p>font-size:12px;</p>\n<p>color:red;</p>\n<p>}</p>\n<p>CSS样式可以写在哪些地方呢？从CSS 样式代码插入的形式来看基本可以分为以下3种：内联式(直接写在开始的style属性里)、嵌入式(将css放在style标签中，并将标签放在head中)和外部式(&lt;link href=”<strong>base.css</strong>“ rel=”stylesheet” type=”text/css” /&gt;)三种.</p>\n<p>三者的优先级：内联式 &gt; 嵌入式 &gt; 外部式—&gt;总结来说，就是–就近原则（离被设置元素越近优先级别越高）。</p>\n<hr>\n<p>选择器：</p>\n<p>类选择器在css样式编码中是最常用到的。</p>\n<p>语法：</p>\n<p>.类选器名称{css样式代码;}</p>\n<p>使用的时候，在标签内加class=”类选择器名称”.注意设置类选择器的时候，名字前面要用英文的”.”</p>\n<p>id选择器：#id选择器名称{…}</p>\n<p>在使用的时候，加上id=”id选择器名称”</p>\n<h3 id=\"id选择器和类选择器的异同点：\"><a href=\"#id选择器和类选择器的异同点：\" class=\"headerlink\" title=\"id选择器和类选择器的异同点：\"></a>id选择器和类选择器的异同点：</h3><p><strong>相同点：</strong>可以应用于任何元素<br><strong>不同点：</strong></p>\n<p>1、<strong>ID选择器只能在文档中使用一次</strong>。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而类选择器可以使用多次。</p>\n<p>2、<strong>可以使用类选择器词列表方法为一个元素同时设置多个样式。</strong>我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（<strong>不能使用 ID 词列表）。</strong></p>\n<h3 id=\"子选择器：（直接后代）\"><a href=\"#子选择器：（直接后代）\" class=\"headerlink\" title=\"子选择器：（直接后代）\"></a>子选择器：（直接后代）</h3><p>即大于符号(&gt;),用于选择指定标签元素的<strong>第一代子元素。</strong>如右侧代码编辑器中的代码：</p>\n<p>.food&gt;li{border:1px solid red;}<br>这行代码会使class名为food下的子元素li加入红色实线边框。</p>\n<h3 id=\"包含选择器：\"><a href=\"#包含选择器：\" class=\"headerlink\" title=\"包含选择器：\"></a>包含选择器：</h3><p>即加入空格,用于选择指定标签元素下的<strong>后辈元素。</strong></p>\n<p>请注意这个选择器与子选择器的区别，子选择器（child selector）仅是指它的直接后代，或者你可以理解为作用于子元素的第一代后代。而后代选择器是作用于所有子后代元素。</p>\n<p>通用选择器：*{..}，应用于所有html标签内容</p>\n<h3 id=\"伪类选择符：\"><a href=\"#伪类选择符：\" class=\"headerlink\" title=\"伪类选择符：\"></a>伪类选择符：</h3><p>它允许给html不存在的标签（标签的某种状态）设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色：</p>\n<p><pre class=\"code\">a:hover{color:red;}</pre><br>上面一行代码就是为 a 标签鼠标滑过的状态设置字体颜色变红。这样就会使第一段文字内容中的“胆小如鼠”文字加入<strong>鼠标滑过</strong>字体颜色变为红色特效。 一般伪类选择符是a:hover的用法</p>\n<p>&nbsp;</p>\n<hr>\n<p>浏览器会根据权值来判断使用哪种css样式：<strong>标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100</strong></p>\n<hr>\n<p>css的格式化排版：</p>\n<p>字体：font-family</p>\n<p>字号：font-size</p>\n<p>粗体：font-weight:bold</p>\n<p>斜体：font-style:italic</p>\n<p>下划线：text-decoration:underline</p>\n<p>删除线：text-decoration:lint-through</p>\n<p>缩进：text-indent:2em</p>\n<p>行高/行间距：line-height:2em</p>\n<p>字间距：word-spacing:50px</p>\n<p>对齐：text-align:center</p>\n<hr>\n<p>元素分类：<span style=\"color: #ff0000;\">块状元素、内联元素、内联块状元素</span>。可以通过display属性来设置分别是：block/inline/inline-block</p>\n<p><span style=\"color: #ff0000;\">块状元素（&lt;div&gt;、 &lt;p&gt;、&lt;h1&gt;、&lt;form&gt;、&lt;ul&gt; 和 &lt;li&gt;）</span>的特点：在不设置宽度的情况下，显示为父容器的100%、元素的高度、宽度、行高、顶和底边距都可以设置</p>\n<p><span style=\"color: #ff0000;\">内联元素（&lt;span&gt;、&lt;a&gt;、&lt;label&gt;、 &lt;strong&gt; 和&lt;em&gt;）</span>的特点：和其他元素都在一行上；元素的高度、宽度及顶部和底部边距<span style=\"color: #ff0000;\"><strong>不可</strong></span>设置；元素的宽度就是它包含的文字或图片的宽度，<span style=\"color: #ff0000;\">不可</span>改变。</p>\n<p><span style=\"color: #ff0000;\">内联块状元素（&lt;img&gt;、&lt;input&gt;）</span>的特点：和其他元素都在一行上；<span style=\"color: #ff0000;\">元素的高度、宽度、行高以及顶和底边距都可设置。</span></p>\n<p>盒子模型：块状标签都具有盒子模型的特征。<a href=\"http://zh.learnlayout.com/\" target=\"_blank\" rel=\"noopener\">http://zh.learnlayout.com/</a></p>\n<p>&nbsp;</p>\n<p>内填充padding</p>\n<p>外边距margin</p>\n<p>边框border</p>\n<p>它们都是有方向的：</p>\n<p><img src=\"http://www.alanpro.win/wp-content/uploads/2017/08/padding-1024x615.png\" alt=\"\"></p>\n<p>同padding，margin和border也有上下左右四个方向</p>\n<p>盒模型的元素的实际宽度（盒子的宽度）：<img src=\"http://www.alanpro.win/wp-content/uploads/2017/08/盒模型的宽度图.jpg\" alt=\"\"></p>\n<p>总结一下：padding和margin的区别，padding在边框里，margin在边框外。</p>\n<hr>\n<p>在网页中，元素有三种布局模型：<br>1、流动模型（Flow）默认的网页布局模式。a)<strong>块状元素</strong>都会在所处的<strong>包含元素内</strong>自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为<strong>100%。b)内联 元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行）(em/a/span/strong都是内联元素)</strong><br>2、浮动模型 (Float)可以在选择器中设置float属性来让块状元素浮动，让它们不占有一行<br>3、层模型（Layer）三种形式：<strong>绝对定位</strong>(position: absolute)、<strong>相对定位</strong>(position: relative)、<strong>固定定位</strong>(position: fixed)</p>\n<p>relative和absolute可以组合使用，不过relative需要是absolute的父标签。</p>\n<hr>\n<p>适当的运用css代码缩写，占用更少的带宽。盒模型、颜色、字体都可以缩写</p>\n<p>长度值：目前比较常用到px（像素）、em、% 百分比，要注意其实这三种单位都是相对单位。px是相对于显示器的小点、em是相对于设置的font-size、行高行间距也是以font-size为参照的</p>\n<hr>\n<p>水平居中：</p>\n<p>行内元素：当被设置的元素是文本、图片等行内元素时，水平居中通过父元素设置：text-align:center;</p>\n<p>如果被设置的元素不是行内元素，而是块状元素的话，就不能用这个方法了：</p>\n<p>定宽块状元素：可以指定宽度width,将它设置为固定值。满足定宽和块状两个条件的元素是可以通过设置“左右margin”值为“auto”来实现居中的。</p>\n<p><span style=\"color: #ff0000;\">不定宽块状元素</span>：网页上的分页导航，因为分页的数量是不确定的，所以我们不能通过设置宽度来限制它的弹性。<span lang=\"EN-US\">(</span>不定宽块状元素：块状元素的宽度<span lang=\"EN-US\">width</span>不固定)</p>\n<ol>\n<li>方法1：加入table标签，因为它是长度自适应性的，长度是根据其内文本长度决定，用margin:0px auto;上下外边距为0，左右自动</li>\n<li>方法2：改变元素的display类型为inline，就变成了行内元素，然后用text-align:center来设置居中效果。</li>\n<li>方法3：通过给父元素设置<span lang=\"EN-US\"> float</span>，然后给父元素设置 <span lang=\"EN-US\">position:relative</span><span lang=\"EN-US\"> </span>和<span lang=\"EN-US\"> left:50%</span>，子元素设置<span lang=\"EN-US\"> position:relative </span>和<span lang=\"EN-US\"> left: </span><span lang=\"EN-US\">-50%</span><span lang=\"EN-US\"> </span>来实现水平居中。</li>\n</ol>"},{"title":"我记不住的单词们  F*CK","id":"181","date":"2017-06-26T14:43:47.000Z","_content":"\n[table id=1 /]","source":"_posts/e6-88-91-e8-ae-b0-e4-b8-8d-e4-bd-8f-e7-9a-84-e5-8d-95-e8-af-8d-e4-bb-ac-fck.md","raw":"---\ntitle: 我记不住的单词们  F*CK\nid: 181\ncategories:\n  - 语言\ndate: 2017-06-26 22:43:47\ntags:\n---\n\n[table id=1 /]","slug":"e6-88-91-e8-ae-b0-e4-b8-8d-e4-bd-8f-e7-9a-84-e5-8d-95-e8-af-8d-e4-bb-ac-fck","published":1,"updated":"2017-12-09T17:06:50.786Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec0t001biwtwy70ier4z","content":"<p>[table id=1 /]</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[table id=1 /]</p>\n"},{"title":"前端笔记之网页布局","id":"308","date":"2017-08-11T09:27:46.000Z","_content":"\n## 什么叫做布局？\n\n又叫做板式布局，UI设计师将有限的视觉元素进行有机的排列组合。将理性的思维和感性的视觉相结合的体现。是一种特色的视觉传达的效果。\n\n## 网页设计的特点：\n\n宽度自适应（随显示器的大小自适应）、理论上长度可以无限延长<!--more-->\n\n## 常见的布局：\n\n![](http://www.alanpro.win/wp-content/uploads/2017/08/layout.png)![](http://www.alanpro.win/wp-content/uploads/2017/08/layout1.png)\n\n&nbsp;\n\n## 网页设计的原则：\n\n制作过程中，要把握“结构、表现、行为”分离的思想。\n\n先别过多的考虑样式。首先重点考虑的是<span style=\"color: #ff0000;\">HTML结构</span>和<span style=\"color: #ff0000;\">语义化</span>。","source":"_posts/e5-89-8d-e7-ab-af-e7-ac-94-e8-ae-b0-e4-b9-8b-e7-bd-91-e9-a1-b5-e5-b8-83-e5-b1-80.md","raw":"---\ntitle: 前端笔记之网页布局\ntags:\n  - 前端\nid: 308\ncategories:\n  - web学习整理\ndate: 2017-08-11 17:27:46\n---\n\n## 什么叫做布局？\n\n又叫做板式布局，UI设计师将有限的视觉元素进行有机的排列组合。将理性的思维和感性的视觉相结合的体现。是一种特色的视觉传达的效果。\n\n## 网页设计的特点：\n\n宽度自适应（随显示器的大小自适应）、理论上长度可以无限延长<!--more-->\n\n## 常见的布局：\n\n![](http://www.alanpro.win/wp-content/uploads/2017/08/layout.png)![](http://www.alanpro.win/wp-content/uploads/2017/08/layout1.png)\n\n&nbsp;\n\n## 网页设计的原则：\n\n制作过程中，要把握“结构、表现、行为”分离的思想。\n\n先别过多的考虑样式。首先重点考虑的是<span style=\"color: #ff0000;\">HTML结构</span>和<span style=\"color: #ff0000;\">语义化</span>。","slug":"e5-89-8d-e7-ab-af-e7-ac-94-e8-ae-b0-e4-b9-8b-e7-bd-91-e9-a1-b5-e5-b8-83-e5-b1-80","published":1,"updated":"2017-12-09T17:06:50.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec13001fiwtwj39qs3u8","content":"<h2 id=\"什么叫做布局？\"><a href=\"#什么叫做布局？\" class=\"headerlink\" title=\"什么叫做布局？\"></a>什么叫做布局？</h2><p>又叫做板式布局，UI设计师将有限的视觉元素进行有机的排列组合。将理性的思维和感性的视觉相结合的体现。是一种特色的视觉传达的效果。</p>\n<h2 id=\"网页设计的特点：\"><a href=\"#网页设计的特点：\" class=\"headerlink\" title=\"网页设计的特点：\"></a>网页设计的特点：</h2><p>宽度自适应（随显示器的大小自适应）、理论上长度可以无限延长<a id=\"more\"></a></p>\n<h2 id=\"常见的布局：\"><a href=\"#常见的布局：\" class=\"headerlink\" title=\"常见的布局：\"></a>常见的布局：</h2><p><img src=\"http://www.alanpro.win/wp-content/uploads/2017/08/layout.png\" alt=\"\"><img src=\"http://www.alanpro.win/wp-content/uploads/2017/08/layout1.png\" alt=\"\"></p>\n<p>&nbsp;</p>\n<h2 id=\"网页设计的原则：\"><a href=\"#网页设计的原则：\" class=\"headerlink\" title=\"网页设计的原则：\"></a>网页设计的原则：</h2><p>制作过程中，要把握“结构、表现、行为”分离的思想。</p>\n<p>先别过多的考虑样式。首先重点考虑的是<span style=\"color: #ff0000;\">HTML结构</span>和<span style=\"color: #ff0000;\">语义化</span>。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么叫做布局？\"><a href=\"#什么叫做布局？\" class=\"headerlink\" title=\"什么叫做布局？\"></a>什么叫做布局？</h2><p>又叫做板式布局，UI设计师将有限的视觉元素进行有机的排列组合。将理性的思维和感性的视觉相结合的体现。是一种特色的视觉传达的效果。</p>\n<h2 id=\"网页设计的特点：\"><a href=\"#网页设计的特点：\" class=\"headerlink\" title=\"网页设计的特点：\"></a>网页设计的特点：</h2><p>宽度自适应（随显示器的大小自适应）、理论上长度可以无限延长","more":"</p>\n<h2 id=\"常见的布局：\"><a href=\"#常见的布局：\" class=\"headerlink\" title=\"常见的布局：\"></a>常见的布局：</h2><p><img src=\"http://www.alanpro.win/wp-content/uploads/2017/08/layout.png\" alt=\"\"><img src=\"http://www.alanpro.win/wp-content/uploads/2017/08/layout1.png\" alt=\"\"></p>\n<p>&nbsp;</p>\n<h2 id=\"网页设计的原则：\"><a href=\"#网页设计的原则：\" class=\"headerlink\" title=\"网页设计的原则：\"></a>网页设计的原则：</h2><p>制作过程中，要把握“结构、表现、行为”分离的思想。</p>\n<p>先别过多的考虑样式。首先重点考虑的是<span style=\"color: #ff0000;\">HTML结构</span>和<span style=\"color: #ff0000;\">语义化</span>。</p>"},{"title":"图形学复习文档","id":"114","date":"2017-04-26T03:39:27.000Z","_content":"\n1：计算机绘图方式：\n屏幕显示、打印机打印屏幕上的图样和绘图机输出图样\n2：像素：\n像素是组成图形的基本元素，一般称为“点”。\n通过点亮一些像素，灭掉一些像素，即在屏幕上产生图形。在光栅显示器上显示任何一种图形，在显示器的相应像素点上画上所需的像素点，即具有一种或多种颜色的像素集合 构成图形。\n确定最佳逼近图形的像素集合，并用指定属性写像素的过程称为 扫描转换或者光栅化。\n对于一维图形，在不考虑线宽时，用一个像素宽的直、曲线来显示图形。\n二维图形光栅化必须确定区域对应的像素集合，并用指定的属性和图案进行显示，即区域填充。<!--more-->\n3：直线算法：\n数值微分法（DDA）：DDA算法主要是根据直线公式y = kx + b来推导出来的，其关键之处在于如何设定单位步进，即一个方向的步进为单位步进，另一个方向的步进必然是小于1\n[dda和bresenham算法的区别](http://blog.csdn.net/clever101/article/details/6076841)\nBresenham算法是DDA算法画线算法的一种改进算法。本质上它也是采取了步进的思想。不过它比DDA算法作了优化，避免了步进时浮点数运算，同时为选取符合直线方程的点提供了一个好思路\n算法的基本原理：类似于中点法，由误差项符号决定下一个像素取右边点还是右上点。\n该算法的巧妙之处就在于：采用了增量计算，使得对每一列，只要检查一个误差项的符号，就可以确定该列所求像素。\n\n4：圆\n在进行扫描转换之前，假设圆的圆心位于坐标原点（如果圆心不在原点，可以通过坐标平移使其与原点重合），半径为R。以原点为圆心的圆C有四条对称轴：x = 0, y = 0, x = y和x = -y。若已知圆弧上一点P1＝C（x, y），利用其对称性便可以得到关于四条对称轴的其它7个点，即：\nP2＝C（x,－y），\nP3＝C（－x, y），\nP4＝C（－x,－y），\nP5＝C（y，x），\nP6＝C（－y，x），\nP7＝C（y，－x），\nP8＝C（－y，－x）。\n这种性质称为八对称性。\n因此，只要扫描转换八分之一圆弧，就可以通过圆弧的八对称性得到整个圆。[bresenham和中点画圆法](http://blog.csdn.net/bagboy_taobao_com/article/details/5774628)\n中点画圆法：中点画圆算法就是每部单位间隔取样并且计算离圆最近的位置\nbresenham画圆：是对中点画圆法的改进，减少了浮点运算，提高了运算效率\n算法原理：中点画圆法中，计算判别式d使用了浮点运算，影响了圆的生成效率。如果能将判别式规约到整数运算，则可以简化计算，提高效率。于是人们针对中点画圆法进行了多种改进，其中一种方式是将d的初始值由1.25 – R改成1 – R，考虑到圆的半径R总是大于2，因此这个修改不会响d的初始值的符号，同时可以避免浮点运算。还有一种方法是将d的计算放大两倍，同时将初始值改成3 – 2R，这样避免了浮点运算，乘二运算也可以用移位快速代替，采用3 – 2R为初始值的改进算法，又称为Bresenham算法\n\n5：多边形的扫描转换：\n矩形是特殊的多边形，但一般多边形扫描算法要用到复杂的数据结构，效率不高，而矩形常用而且经常会用到，所以一般图形软件包把它作为一类基本土元加以设计\nQ:共享边会重复绘制，那么边界属于谁？\nA:处理规则，左闭右开，下闭上开（左下原则）\n多边形的两种表示方法：顶点表示：用多边形的顶点序列（P0，P1...PN)来表示多边形）特点：直观，几何意义强。但是没有指明哪些像素在多边形内部\n点阵表示：用位于多边形内的像素集合来刻画多边形。丢失了几何信息。\n光栅图形的一个基本问题：把多边形的顶点表示转换为点阵表示。这种转换成为 多边形的扫描转换\n凸多边形任意两顶点间的：任意两顶点之间的连线均在多边形内\n凹多边形：任意两顶点间的连线有不在多边形内部的\n\n扫描线算法：对不自交多边形\n扫描线多边形区域填充算法：\n按扫描线顺序，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间的像素，即完成填充。区间的端点可以通过计算扫描线和多边形边界线的交点获得。\n算法描述：1：求交，计算扫描线与多边形边界的交点\n2：排序，把所有交点按x递增的顺序排序\n3：配对，第一个与第二个，第三个与第四个。。。每对交点代表扫描线与多边形的一个相交区间\n4：填色，把相交区间内的像素置成多边形颜色，把相交区间外的像素置成背景色\n关键问题：求交，为了减少求交的计算量，可以利用边的连贯性：相邻扫描线与边的交点的坐标有连贯性。\n\n种子填充算法：\n6：4向连通和8向连通区域填充的算法：假设在多边形内有一像素（种子）已知，由此出发利用连通性找到区域内的所有像素。利用栈实现\n\n7：字符：\n字符编码：8位或16位\n字符存储：点阵形式如8*8,16*8,24*24等形式表示的字库\n存储了每个字符的形状信息，方便在显示器等输出设备上输出。字库中分为矢量型和点阵型\n\n点阵字符：每个字符由一个位图表示。该位位1表示画笔经过此位，对应于此位的像素应置为字符的颜色。该位位0表示不经过，对应于此位的像素应该置为背景颜色\n矢量字符：矢量字符记录字符的画笔信息而不是整个位图，具有存储空间小、美观、变换方便等优点。\n对于字符的变换需要表示字符位图中的每一个像素进行；而矢量字符只要对其笔画端点进行变换就ok\n显示：矢量字符和点阵字符的显示都分为两步：首先要从字库中将字符的位图检索出来。然后将检索到的位图写到帧缓冲器去/取出端点坐标，对其进行适当的几何变换，再根据各端点的标志显示出字符。\n\n8：线性插值：\n內插是数学领域数值分析中的通过已知的离散数据求未知数据的过程或方法。\n根据若干离散的数据数据，得到一个连续的函数（也就是曲线）或者更加密集的离散方程与已知数据相吻合。这个过程叫做拟合。內插是曲线必须通过已知点的拟合。","source":"_posts/e5-9b-be-e5-bd-a2-e5-ad-a6-e5-a4-8d-e4-b9-a0-e6-96-87-e6-a1-a3.md","raw":"---\ntitle: 图形学复习文档\ntags:\n  - 图形学\nid: 114\ncategories:\n  - web学习整理\ndate: 2017-04-26 11:39:27\n---\n\n1：计算机绘图方式：\n屏幕显示、打印机打印屏幕上的图样和绘图机输出图样\n2：像素：\n像素是组成图形的基本元素，一般称为“点”。\n通过点亮一些像素，灭掉一些像素，即在屏幕上产生图形。在光栅显示器上显示任何一种图形，在显示器的相应像素点上画上所需的像素点，即具有一种或多种颜色的像素集合 构成图形。\n确定最佳逼近图形的像素集合，并用指定属性写像素的过程称为 扫描转换或者光栅化。\n对于一维图形，在不考虑线宽时，用一个像素宽的直、曲线来显示图形。\n二维图形光栅化必须确定区域对应的像素集合，并用指定的属性和图案进行显示，即区域填充。<!--more-->\n3：直线算法：\n数值微分法（DDA）：DDA算法主要是根据直线公式y = kx + b来推导出来的，其关键之处在于如何设定单位步进，即一个方向的步进为单位步进，另一个方向的步进必然是小于1\n[dda和bresenham算法的区别](http://blog.csdn.net/clever101/article/details/6076841)\nBresenham算法是DDA算法画线算法的一种改进算法。本质上它也是采取了步进的思想。不过它比DDA算法作了优化，避免了步进时浮点数运算，同时为选取符合直线方程的点提供了一个好思路\n算法的基本原理：类似于中点法，由误差项符号决定下一个像素取右边点还是右上点。\n该算法的巧妙之处就在于：采用了增量计算，使得对每一列，只要检查一个误差项的符号，就可以确定该列所求像素。\n\n4：圆\n在进行扫描转换之前，假设圆的圆心位于坐标原点（如果圆心不在原点，可以通过坐标平移使其与原点重合），半径为R。以原点为圆心的圆C有四条对称轴：x = 0, y = 0, x = y和x = -y。若已知圆弧上一点P1＝C（x, y），利用其对称性便可以得到关于四条对称轴的其它7个点，即：\nP2＝C（x,－y），\nP3＝C（－x, y），\nP4＝C（－x,－y），\nP5＝C（y，x），\nP6＝C（－y，x），\nP7＝C（y，－x），\nP8＝C（－y，－x）。\n这种性质称为八对称性。\n因此，只要扫描转换八分之一圆弧，就可以通过圆弧的八对称性得到整个圆。[bresenham和中点画圆法](http://blog.csdn.net/bagboy_taobao_com/article/details/5774628)\n中点画圆法：中点画圆算法就是每部单位间隔取样并且计算离圆最近的位置\nbresenham画圆：是对中点画圆法的改进，减少了浮点运算，提高了运算效率\n算法原理：中点画圆法中，计算判别式d使用了浮点运算，影响了圆的生成效率。如果能将判别式规约到整数运算，则可以简化计算，提高效率。于是人们针对中点画圆法进行了多种改进，其中一种方式是将d的初始值由1.25 – R改成1 – R，考虑到圆的半径R总是大于2，因此这个修改不会响d的初始值的符号，同时可以避免浮点运算。还有一种方法是将d的计算放大两倍，同时将初始值改成3 – 2R，这样避免了浮点运算，乘二运算也可以用移位快速代替，采用3 – 2R为初始值的改进算法，又称为Bresenham算法\n\n5：多边形的扫描转换：\n矩形是特殊的多边形，但一般多边形扫描算法要用到复杂的数据结构，效率不高，而矩形常用而且经常会用到，所以一般图形软件包把它作为一类基本土元加以设计\nQ:共享边会重复绘制，那么边界属于谁？\nA:处理规则，左闭右开，下闭上开（左下原则）\n多边形的两种表示方法：顶点表示：用多边形的顶点序列（P0，P1...PN)来表示多边形）特点：直观，几何意义强。但是没有指明哪些像素在多边形内部\n点阵表示：用位于多边形内的像素集合来刻画多边形。丢失了几何信息。\n光栅图形的一个基本问题：把多边形的顶点表示转换为点阵表示。这种转换成为 多边形的扫描转换\n凸多边形任意两顶点间的：任意两顶点之间的连线均在多边形内\n凹多边形：任意两顶点间的连线有不在多边形内部的\n\n扫描线算法：对不自交多边形\n扫描线多边形区域填充算法：\n按扫描线顺序，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间的像素，即完成填充。区间的端点可以通过计算扫描线和多边形边界线的交点获得。\n算法描述：1：求交，计算扫描线与多边形边界的交点\n2：排序，把所有交点按x递增的顺序排序\n3：配对，第一个与第二个，第三个与第四个。。。每对交点代表扫描线与多边形的一个相交区间\n4：填色，把相交区间内的像素置成多边形颜色，把相交区间外的像素置成背景色\n关键问题：求交，为了减少求交的计算量，可以利用边的连贯性：相邻扫描线与边的交点的坐标有连贯性。\n\n种子填充算法：\n6：4向连通和8向连通区域填充的算法：假设在多边形内有一像素（种子）已知，由此出发利用连通性找到区域内的所有像素。利用栈实现\n\n7：字符：\n字符编码：8位或16位\n字符存储：点阵形式如8*8,16*8,24*24等形式表示的字库\n存储了每个字符的形状信息，方便在显示器等输出设备上输出。字库中分为矢量型和点阵型\n\n点阵字符：每个字符由一个位图表示。该位位1表示画笔经过此位，对应于此位的像素应置为字符的颜色。该位位0表示不经过，对应于此位的像素应该置为背景颜色\n矢量字符：矢量字符记录字符的画笔信息而不是整个位图，具有存储空间小、美观、变换方便等优点。\n对于字符的变换需要表示字符位图中的每一个像素进行；而矢量字符只要对其笔画端点进行变换就ok\n显示：矢量字符和点阵字符的显示都分为两步：首先要从字库中将字符的位图检索出来。然后将检索到的位图写到帧缓冲器去/取出端点坐标，对其进行适当的几何变换，再根据各端点的标志显示出字符。\n\n8：线性插值：\n內插是数学领域数值分析中的通过已知的离散数据求未知数据的过程或方法。\n根据若干离散的数据数据，得到一个连续的函数（也就是曲线）或者更加密集的离散方程与已知数据相吻合。这个过程叫做拟合。內插是曲线必须通过已知点的拟合。","slug":"e5-9b-be-e5-bd-a2-e5-ad-a6-e5-a4-8d-e4-b9-a0-e6-96-87-e6-a1-a3","published":1,"updated":"2017-12-09T17:06:50.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec13001hiwtwqmpnwe5c","content":"<p>1：计算机绘图方式：<br>屏幕显示、打印机打印屏幕上的图样和绘图机输出图样<br>2：像素：<br>像素是组成图形的基本元素，一般称为“点”。<br>通过点亮一些像素，灭掉一些像素，即在屏幕上产生图形。在光栅显示器上显示任何一种图形，在显示器的相应像素点上画上所需的像素点，即具有一种或多种颜色的像素集合 构成图形。<br>确定最佳逼近图形的像素集合，并用指定属性写像素的过程称为 扫描转换或者光栅化。<br>对于一维图形，在不考虑线宽时，用一个像素宽的直、曲线来显示图形。<br>二维图形光栅化必须确定区域对应的像素集合，并用指定的属性和图案进行显示，即区域填充。<a id=\"more\"></a><br>3：直线算法：<br>数值微分法（DDA）：DDA算法主要是根据直线公式y = kx + b来推导出来的，其关键之处在于如何设定单位步进，即一个方向的步进为单位步进，另一个方向的步进必然是小于1<br><a href=\"http://blog.csdn.net/clever101/article/details/6076841\" target=\"_blank\" rel=\"noopener\">dda和bresenham算法的区别</a><br>Bresenham算法是DDA算法画线算法的一种改进算法。本质上它也是采取了步进的思想。不过它比DDA算法作了优化，避免了步进时浮点数运算，同时为选取符合直线方程的点提供了一个好思路<br>算法的基本原理：类似于中点法，由误差项符号决定下一个像素取右边点还是右上点。<br>该算法的巧妙之处就在于：采用了增量计算，使得对每一列，只要检查一个误差项的符号，就可以确定该列所求像素。</p>\n<p>4：圆<br>在进行扫描转换之前，假设圆的圆心位于坐标原点（如果圆心不在原点，可以通过坐标平移使其与原点重合），半径为R。以原点为圆心的圆C有四条对称轴：x = 0, y = 0, x = y和x = -y。若已知圆弧上一点P1＝C（x, y），利用其对称性便可以得到关于四条对称轴的其它7个点，即：<br>P2＝C（x,－y），<br>P3＝C（－x, y），<br>P4＝C（－x,－y），<br>P5＝C（y，x），<br>P6＝C（－y，x），<br>P7＝C（y，－x），<br>P8＝C（－y，－x）。<br>这种性质称为八对称性。<br>因此，只要扫描转换八分之一圆弧，就可以通过圆弧的八对称性得到整个圆。<a href=\"http://blog.csdn.net/bagboy_taobao_com/article/details/5774628\" target=\"_blank\" rel=\"noopener\">bresenham和中点画圆法</a><br>中点画圆法：中点画圆算法就是每部单位间隔取样并且计算离圆最近的位置<br>bresenham画圆：是对中点画圆法的改进，减少了浮点运算，提高了运算效率<br>算法原理：中点画圆法中，计算判别式d使用了浮点运算，影响了圆的生成效率。如果能将判别式规约到整数运算，则可以简化计算，提高效率。于是人们针对中点画圆法进行了多种改进，其中一种方式是将d的初始值由1.25 – R改成1 – R，考虑到圆的半径R总是大于2，因此这个修改不会响d的初始值的符号，同时可以避免浮点运算。还有一种方法是将d的计算放大两倍，同时将初始值改成3 – 2R，这样避免了浮点运算，乘二运算也可以用移位快速代替，采用3 – 2R为初始值的改进算法，又称为Bresenham算法</p>\n<p>5：多边形的扫描转换：<br>矩形是特殊的多边形，但一般多边形扫描算法要用到复杂的数据结构，效率不高，而矩形常用而且经常会用到，所以一般图形软件包把它作为一类基本土元加以设计<br>Q:共享边会重复绘制，那么边界属于谁？<br>A:处理规则，左闭右开，下闭上开（左下原则）<br>多边形的两种表示方法：顶点表示：用多边形的顶点序列（P0，P1…PN)来表示多边形）特点：直观，几何意义强。但是没有指明哪些像素在多边形内部<br>点阵表示：用位于多边形内的像素集合来刻画多边形。丢失了几何信息。<br>光栅图形的一个基本问题：把多边形的顶点表示转换为点阵表示。这种转换成为 多边形的扫描转换<br>凸多边形任意两顶点间的：任意两顶点之间的连线均在多边形内<br>凹多边形：任意两顶点间的连线有不在多边形内部的</p>\n<p>扫描线算法：对不自交多边形<br>扫描线多边形区域填充算法：<br>按扫描线顺序，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间的像素，即完成填充。区间的端点可以通过计算扫描线和多边形边界线的交点获得。<br>算法描述：1：求交，计算扫描线与多边形边界的交点<br>2：排序，把所有交点按x递增的顺序排序<br>3：配对，第一个与第二个，第三个与第四个。。。每对交点代表扫描线与多边形的一个相交区间<br>4：填色，把相交区间内的像素置成多边形颜色，把相交区间外的像素置成背景色<br>关键问题：求交，为了减少求交的计算量，可以利用边的连贯性：相邻扫描线与边的交点的坐标有连贯性。</p>\n<p>种子填充算法：<br>6：4向连通和8向连通区域填充的算法：假设在多边形内有一像素（种子）已知，由此出发利用连通性找到区域内的所有像素。利用栈实现</p>\n<p>7：字符：<br>字符编码：8位或16位<br>字符存储：点阵形式如8<em>8,16</em>8,24*24等形式表示的字库<br>存储了每个字符的形状信息，方便在显示器等输出设备上输出。字库中分为矢量型和点阵型</p>\n<p>点阵字符：每个字符由一个位图表示。该位位1表示画笔经过此位，对应于此位的像素应置为字符的颜色。该位位0表示不经过，对应于此位的像素应该置为背景颜色<br>矢量字符：矢量字符记录字符的画笔信息而不是整个位图，具有存储空间小、美观、变换方便等优点。<br>对于字符的变换需要表示字符位图中的每一个像素进行；而矢量字符只要对其笔画端点进行变换就ok<br>显示：矢量字符和点阵字符的显示都分为两步：首先要从字库中将字符的位图检索出来。然后将检索到的位图写到帧缓冲器去/取出端点坐标，对其进行适当的几何变换，再根据各端点的标志显示出字符。</p>\n<p>8：线性插值：<br>內插是数学领域数值分析中的通过已知的离散数据求未知数据的过程或方法。<br>根据若干离散的数据数据，得到一个连续的函数（也就是曲线）或者更加密集的离散方程与已知数据相吻合。这个过程叫做拟合。內插是曲线必须通过已知点的拟合。</p>\n","site":{"data":{}},"excerpt":"<p>1：计算机绘图方式：<br>屏幕显示、打印机打印屏幕上的图样和绘图机输出图样<br>2：像素：<br>像素是组成图形的基本元素，一般称为“点”。<br>通过点亮一些像素，灭掉一些像素，即在屏幕上产生图形。在光栅显示器上显示任何一种图形，在显示器的相应像素点上画上所需的像素点，即具有一种或多种颜色的像素集合 构成图形。<br>确定最佳逼近图形的像素集合，并用指定属性写像素的过程称为 扫描转换或者光栅化。<br>对于一维图形，在不考虑线宽时，用一个像素宽的直、曲线来显示图形。<br>二维图形光栅化必须确定区域对应的像素集合，并用指定的属性和图案进行显示，即区域填充。","more":"<br>3：直线算法：<br>数值微分法（DDA）：DDA算法主要是根据直线公式y = kx + b来推导出来的，其关键之处在于如何设定单位步进，即一个方向的步进为单位步进，另一个方向的步进必然是小于1<br><a href=\"http://blog.csdn.net/clever101/article/details/6076841\" target=\"_blank\" rel=\"noopener\">dda和bresenham算法的区别</a><br>Bresenham算法是DDA算法画线算法的一种改进算法。本质上它也是采取了步进的思想。不过它比DDA算法作了优化，避免了步进时浮点数运算，同时为选取符合直线方程的点提供了一个好思路<br>算法的基本原理：类似于中点法，由误差项符号决定下一个像素取右边点还是右上点。<br>该算法的巧妙之处就在于：采用了增量计算，使得对每一列，只要检查一个误差项的符号，就可以确定该列所求像素。</p>\n<p>4：圆<br>在进行扫描转换之前，假设圆的圆心位于坐标原点（如果圆心不在原点，可以通过坐标平移使其与原点重合），半径为R。以原点为圆心的圆C有四条对称轴：x = 0, y = 0, x = y和x = -y。若已知圆弧上一点P1＝C（x, y），利用其对称性便可以得到关于四条对称轴的其它7个点，即：<br>P2＝C（x,－y），<br>P3＝C（－x, y），<br>P4＝C（－x,－y），<br>P5＝C（y，x），<br>P6＝C（－y，x），<br>P7＝C（y，－x），<br>P8＝C（－y，－x）。<br>这种性质称为八对称性。<br>因此，只要扫描转换八分之一圆弧，就可以通过圆弧的八对称性得到整个圆。<a href=\"http://blog.csdn.net/bagboy_taobao_com/article/details/5774628\" target=\"_blank\" rel=\"noopener\">bresenham和中点画圆法</a><br>中点画圆法：中点画圆算法就是每部单位间隔取样并且计算离圆最近的位置<br>bresenham画圆：是对中点画圆法的改进，减少了浮点运算，提高了运算效率<br>算法原理：中点画圆法中，计算判别式d使用了浮点运算，影响了圆的生成效率。如果能将判别式规约到整数运算，则可以简化计算，提高效率。于是人们针对中点画圆法进行了多种改进，其中一种方式是将d的初始值由1.25 – R改成1 – R，考虑到圆的半径R总是大于2，因此这个修改不会响d的初始值的符号，同时可以避免浮点运算。还有一种方法是将d的计算放大两倍，同时将初始值改成3 – 2R，这样避免了浮点运算，乘二运算也可以用移位快速代替，采用3 – 2R为初始值的改进算法，又称为Bresenham算法</p>\n<p>5：多边形的扫描转换：<br>矩形是特殊的多边形，但一般多边形扫描算法要用到复杂的数据结构，效率不高，而矩形常用而且经常会用到，所以一般图形软件包把它作为一类基本土元加以设计<br>Q:共享边会重复绘制，那么边界属于谁？<br>A:处理规则，左闭右开，下闭上开（左下原则）<br>多边形的两种表示方法：顶点表示：用多边形的顶点序列（P0，P1…PN)来表示多边形）特点：直观，几何意义强。但是没有指明哪些像素在多边形内部<br>点阵表示：用位于多边形内的像素集合来刻画多边形。丢失了几何信息。<br>光栅图形的一个基本问题：把多边形的顶点表示转换为点阵表示。这种转换成为 多边形的扫描转换<br>凸多边形任意两顶点间的：任意两顶点之间的连线均在多边形内<br>凹多边形：任意两顶点间的连线有不在多边形内部的</p>\n<p>扫描线算法：对不自交多边形<br>扫描线多边形区域填充算法：<br>按扫描线顺序，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间的像素，即完成填充。区间的端点可以通过计算扫描线和多边形边界线的交点获得。<br>算法描述：1：求交，计算扫描线与多边形边界的交点<br>2：排序，把所有交点按x递增的顺序排序<br>3：配对，第一个与第二个，第三个与第四个。。。每对交点代表扫描线与多边形的一个相交区间<br>4：填色，把相交区间内的像素置成多边形颜色，把相交区间外的像素置成背景色<br>关键问题：求交，为了减少求交的计算量，可以利用边的连贯性：相邻扫描线与边的交点的坐标有连贯性。</p>\n<p>种子填充算法：<br>6：4向连通和8向连通区域填充的算法：假设在多边形内有一像素（种子）已知，由此出发利用连通性找到区域内的所有像素。利用栈实现</p>\n<p>7：字符：<br>字符编码：8位或16位<br>字符存储：点阵形式如8<em>8,16</em>8,24*24等形式表示的字库<br>存储了每个字符的形状信息，方便在显示器等输出设备上输出。字库中分为矢量型和点阵型</p>\n<p>点阵字符：每个字符由一个位图表示。该位位1表示画笔经过此位，对应于此位的像素应置为字符的颜色。该位位0表示不经过，对应于此位的像素应该置为背景颜色<br>矢量字符：矢量字符记录字符的画笔信息而不是整个位图，具有存储空间小、美观、变换方便等优点。<br>对于字符的变换需要表示字符位图中的每一个像素进行；而矢量字符只要对其笔画端点进行变换就ok<br>显示：矢量字符和点阵字符的显示都分为两步：首先要从字库中将字符的位图检索出来。然后将检索到的位图写到帧缓冲器去/取出端点坐标，对其进行适当的几何变换，再根据各端点的标志显示出字符。</p>\n<p>8：线性插值：<br>內插是数学领域数值分析中的通过已知的离散数据求未知数据的过程或方法。<br>根据若干离散的数据数据，得到一个连续的函数（也就是曲线）或者更加密集的离散方程与已知数据相吻合。这个过程叫做拟合。內插是曲线必须通过已知点的拟合。</p>"},{"title":"欲望和时间","id":"119","date":"2017-05-03T23:16:45.000Z","_content":"\n对于个人来说，欲望既是美好的，又是可怕的。\n\n李宗盛的《写给自己的歌》唱到：当你发现时间是贼了，他早已偷光你的选择\n这两天在学专业课的时候，很多数学知识，英语单词都不会。以前在学这些东西的时候，图了一时快乐，于是被时间偷光了自己的选择。于是得：人生早期的努力，决定了后期的发展~","source":"_posts/e6-ac-b2-e6-9c-9b-e5-92-8c-e6-97-b6-e9-97-b4.md","raw":"---\ntitle: 欲望和时间\ntags:\n  - 生活记录\n  - 瞎想\nid: 119\ncategories:\n  - python学习\ndate: 2017-05-04 07:16:45\n---\n\n对于个人来说，欲望既是美好的，又是可怕的。\n\n李宗盛的《写给自己的歌》唱到：当你发现时间是贼了，他早已偷光你的选择\n这两天在学专业课的时候，很多数学知识，英语单词都不会。以前在学这些东西的时候，图了一时快乐，于是被时间偷光了自己的选择。于是得：人生早期的努力，决定了后期的发展~","slug":"e6-ac-b2-e6-9c-9b-e5-92-8c-e6-97-b6-e9-97-b4","published":1,"updated":"2017-12-09T17:06:50.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec13001kiwtwsvitgy0v","content":"<p>对于个人来说，欲望既是美好的，又是可怕的。</p>\n<p>李宗盛的《写给自己的歌》唱到：当你发现时间是贼了，他早已偷光你的选择<br>这两天在学专业课的时候，很多数学知识，英语单词都不会。以前在学这些东西的时候，图了一时快乐，于是被时间偷光了自己的选择。于是得：人生早期的努力，决定了后期的发展~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>对于个人来说，欲望既是美好的，又是可怕的。</p>\n<p>李宗盛的《写给自己的歌》唱到：当你发现时间是贼了，他早已偷光你的选择<br>这两天在学专业课的时候，很多数学知识，英语单词都不会。以前在学这些东西的时候，图了一时快乐，于是被时间偷光了自己的选择。于是得：人生早期的努力，决定了后期的发展~</p>\n"},{"title":"操作系统考点复习","id":"155","date":"2017-06-18T09:30:46.000Z","_content":"\n&nbsp;\n\n*   什么是操作系统\n\n    *   本质：是一个大型的程序系统软件，处于裸机之上，其他软件系统之下。\n    *   特点：并发性、共享性、不确定性、虚拟性（分时技术相当于虚拟出多个cpu）、异步性（进程的执行并不是一气呵成，而是走走停停）\n    *   宗旨：\n\n            1.  管理所有的软硬件资源，提高资源利用率\n        2.  提供良好的用户界面，方便用户使用\n<!--more-->\n\n*   *   分时技术\n\n            *   概念：把处理机（cpu）时间划分成很短的时间片轮流地分配给各个用户程序使用，如果某个用户程序在分配的时间片用完之前还未计算完，就程序就暂停执行，等待下一轮继续计算，此时cpu的时间片分配给另一个用户程序使用。\n        *   分时操作系统中，响应时间是衡量系统的重要指标\n        *   两个问题分析：\n\n                    1.  时间片过大：退化为“先来先服务”（FCFS）\n            2.  时间片过小：保存现场调用的时间消耗成了主要，进程切换过于频繁，每一次切换都要消耗时间，系统效率急剧下降。\n\n        *   多道程序设计：\n\n            *   概念：在计算机主存中同时存放几道相互独立的程序，它们在操作系统的控制之下，相互地穿插地运行。\n        *   特点：\n\n                    *   **宏观上并行**（同时进入系统的几道程序都处于运行的过程中，它们都开始运行，但都没有运行完毕）\n            *   **微观上串行**（主存中的多道程序轮流或分时地占有处理机，交替执行）\n            *   **多道性**\n\n                *   _补充：批处理系统：_\n\n                    *   缺点：和用户的交互性差（用户不能参与程序的运行）\n            *   优点：吞吐率高。\n\n                *   分时操作系统：一般采用分时技术，使一台计算机同时为多个终端用户服务。该系统对每个用户都能保证足够快的响应时间，并提供交互会话的功能。\n\n                    *   特点：并行性、独占性、交互性。\n\n                *   批处理操作系统和分时操作系统的出现标志着操作系统的形成\n\n        *   处理机（cpu）的特权级：\n\n            *   管态：又称系统态。操作系统的管理程序执行时cpu所处的状态。可以使用全部指令、全部系统资源、访问整个存储区\n        *   目态：又称用户态。用户程序执行时cpu所处的状态。在此状态下禁止使用特权指令。不能直接取用系统资源改变机器状态，只允许使用自己的空间。\n        *   特权级是为了保护系统本身不被破坏。\n        *   **在下列情况下，由目态自动转成管态：**\n\n                    1.  用户进程访问操作系统，要求操作系统的某种服务，这种访问成为系统功能调用。\n            2.  在用户程序执行时，发生一次中断（如I/O完成中断）。\n            3.  在一个用户进程中产生一个错误状态，这种状态被处理为程序性中断。\n            4.  在目态下企图执行一条特权指令，作为一种特殊类型的错误。按照第3条情况处理\n\n        *   作业与作业步：\n\n            *   作业：计算机按照一定步骤执行某一任务\n        *   作业步：每个作业步运行的结果产生下一个作业步所需的文件；步步相承\n\n        *   用户接口：\n\n            *   操作系统提供给用户和计算机打交道的外部机制，用户能够借助这种机制和系统提供的手段来控制用户所在的系统。\n        *   操作系统的用户接口分为两个方面：\n\n                    1.  操作接口：通过该接口来组织自己的工作流程和控制程序的执行\n            2.  程序接口：任何一个用户程序在运行过程中，可以使用操作系统提供的功能调用来请求操作系统的服务。（如申请主存、使用各种外设、创建进程fork、线程等等）\n\n                *   不论哪类操作系统都要同时提供操作接口和程序接口。\n\n        *   顺序程序的特点：顺序性、封闭性、可再现性\n    *   程序的并发执行：若干个程序同时在系统中运行，这些程序的执行时间是重叠的，一个程序的执行尚未结束，另一个程序的执行已经开始，称这几个程序是并发执行的。**题型：给几个程序的计算时间和I/O操作，计算并发执行和顺序执行的时间**\n    *   程序的并发可以用如下语句描述：\n<pre>cobegin:\n      S1,S2...Sn;\ncoend</pre>\n\n*   *   并发程序的特点：失去程序的封闭性、程序和计算不再一一对应、程序并发执行时的相互制约关系（竞争系统资源、进程之间相互合作）\n    *   与时间有关的错误：程序并发执行时如果共享了公共变量，其执行结果将与并发程序执行的相对速度有关，即给定相同的初始条件，也可能会得到不同的结果，此为与时间有关的错误。\n    *   **进程：是一个程序在给定_活动空间_和_初始环境_下，在一个处理机上的执行过程。也可以解释为：一个具有一定独立功能的程序关于某个数据集合的一次运行活动。**\n    *   进程和程序是既有联系又有区别：\n\n            1.  程序是指令的有序集合，是一个静态概念，它本身并没有任何运行的含义。而进程是程序在处理机上的一次执行过程，是一个动态的概念。程序可以作为一种软件资料长期保存，而进程是有生命周期的，它能够动态地产生和消亡。进程可由“创建”而产生，由调度而执行，因得不到资源而暂停，以致最后由“撤销”而消亡\n        2.  进程是一个能独立运行的单位，能与其他进程并发地活动\n        3.  进程是竞争计算机系统有限资源的基本单位，也是进行处理机调度的基本单位。\n        4.  没有建立进程的程序，不能作为独立的单位进行运行。\n\n        *   **进程和程序又是有联系的。在支持多任务运行的操作系统中，活动的最小单位是进程。进程_一定至少_包含一个程序，因为程序是进程应完成功能的逻辑描述；而一个程序可以对应多个进程。如果同一程序同时运行于若干个不同的数据集合上，它将属于若干个不同的进程。或者说，若干个不同的进程可以包含同一个程序。**\n    *   状态变迁图：![](http://www.alanpro.win/wp-content/uploads/2017/06/状态变迁图.png)\n\n            *   就绪：当进程获得了除cpu以外的所有资源，它已经准备就绪，一旦得到cpu的控制权，就可以立即运行\n        *   **状态变迁易错题：在操作系统中用户进程本身启动的唯一状态转换是：阻塞（用户程序可以自己阻塞自己）**\n        *   不可能自己唤醒自己，只能由系统进程或事件发生进程来唤醒。\n\n        *   进程控制块（pcb）：就是一个数据结构，当系统创建一个进程时，必须为它设置一个pcb。为了描述一个进程和其他进程以及系统资源的关系，刻画一个进程在各个不同时期所处的状态。\n\n            *   特点：pcb与进程一一对应，同生同灭。是os感知进程的唯一存在实体（实际排队的）\n\n        *   同步关系：**多个并发进程，在一些关键点上可能需要相互等待与互通消息**\n\n            *   互斥规则（同步关系的特例）：都要公用一个资源（一次只能一个进程使用的资源：临界资源） **互斥产生的原因是？临界资源本身特性决定的**\n        *   临界资源：一次仅允许一个进程使用的资源\n        *   临界区：在每个进程中，访问临界资源的那段程序，进入临界区的进程必须互斥。\n\n        *   同步机构的信号灯是一个（s,q）的二元组。s&gt;=0，表示可用的临界资源数（绿灯，进程执行）。s&lt;0,表示等待使用该邻接资源的进程个数。（s的初始值不能小于0）\n    *   v操作中，如果s+1&lt;=0,说明s的初始值&lt;=-1，唤醒等待进程：释放（s+1）后仍然小于等于0，那么这个释放的1个资源就给了阻塞的进程。\n<pre>main(){\n  int mutex=1;//互斥信号灯\n  cobegin:\n   Pa();\n   Pb();\n  coend;\n}\nPa()\n{\n  P(mutex);\n    CSa;//临界区\n  V(mutex);\n}\nPb()\n{\n  P(mutex);\n    CSa;//临界区\n  V(mutex);\n}\n</pre>\n分析：初始mutex=1，Pa()开始，做了一次P操作，mutex-1=0，进入a临界区，此时Pb开始执行，mutex-1=-1&lt;0,挂入阻塞队列。当a临界区使用完后，Pa进行V操作，mutex+1=0，唤醒阻塞中的进程，继续Pb的执行过程。\n\n&nbsp;\n\n![](http://www.alanpro.win/wp-content/uploads/2017/06/进程流图-300x214.png)进程流图（好丑）\n\n对应的程序:\n\n<pre>cobegin:\n P1();\n P2();\n P3();\n P4();\n P5();\ncoend;\n//信号量：\ns12=s13=s14=s35=s45=0;\nP1(){\n...\nV(s12);\nV(s13);\nV(s14);\n}\nP2(){\nP(s12);\n...\n}\n\nP3(){\nP(s13);\n...\nV(s35);\n}\n\nP4(){\nP(s14);\n...\nV(s45);\n}\n\nP5(){\nP(s35);\nP(s45);\n...\n}\n</pre>\n总结：有前驱，则进行P操作（等前驱做完）。有后继，则进行V操作。\n\n*   生产者-消费者问题引入：\n\n    *   共享缓冲区的合作进程的同步：\n    *   ![](http://www.alanpro.win/wp-content/uploads/2017/06/共享缓冲区-1024x652.png)\n    *   当cp进程把计算结果送入到缓冲区内，iop才能够从缓冲区中取出，进行打印。那么这就形成了一个同步问题，并且是一个特殊的同步问题，即互斥问题（因为只有一个缓冲区作为临界资源）\n    *   在这里 设置一个表示临界资源的信号量Sa = 1（只有一个空间位置，故为1）,设置一个表示缓冲区是否已经装入计算值的信号量Sb=0.那么他们的同步关系可以描述成：![](http://www.alanpro.win/wp-content/uploads/2017/06/同步描述-1024x407.png)\n    *   根据这个图，程序也就呼之欲出了~\n    *   从这个例子可以看出，cp相当于是生产者，生产了数据。iop是消费者，打印了数据。那么如果说有多个cp和多个iop呢？问题又将会变成怎样结局？如果缓冲区buf的个数也变多了呢？下面来阐述经典的生产者消费者问题\n\n*   ![](http://www.alanpro.win/wp-content/uploads/2017/06/生产者消费者.png)\n\n    *   生产者与消费者的同步关系：\n\n            *   生产者：\n\n                    *   当缓冲区满了，需要等待\n            *   缓冲区还有空间时，向缓冲区放入值\n\n                *   消费者：\n\n                    *   当缓冲区为空，需要等待\n            *   缓冲区有值时，从缓冲区取出值\n\n        *   由于缓冲区有多个空间，用Sb表示缓冲区空间的大小，初值为Sb=n；Sa表示缓冲区当前的值的多少，初值为Sa=0(初始没有一个值，为0)\n    *   由于缓冲区是临界资源，一次只能由一个进程操作，所以需要给“放入缓冲区”和“从缓冲区中取出”这两个动作加上锁，即设置互斥信号量，mutex=0;这里有一个考点：\n    *   _**分析上下两个PV操作的顺序能不能颠倒：**_\n\n            *   P操作颠倒：当Sb为0的时候（即缓冲区满了时），先做P(mutex)操作，再做P(Sb)，此时CPi进程会阻塞；而IOPi进程也因为mutex为0，也是阻塞，无法将缓冲区的数据读出来再做V(Sb)的操作，会产生死锁现象\n        *   V操作颠倒：因为P操作会阻塞进程，V操作是释放（唤醒）进程，不会产生死锁问题。\n\n        *   ![](http://www.alanpro.win/wp-content/uploads/2017/06/生产者消费者-同步描述.png)\n    *   建议看一下：阅览室读书的问题 和 卡片机打印机问题。\n\n*   进程通信：是一个和另一个进程之间共享消息的一种方式\n\n    *   低级通信：pv操作是低级进程通信原语。\n    *   高级通信：\n\n            *   直接通信\n        *   间接通信\n\n*   进程的同步和互斥也是一种进程通信，是低级通信机构\n*   调度方式：在优先调度策略下还要确定调度方式。 就是：如有优先级更高的进程转变为就绪状态时，如何分配处理机。分为：\n\n    *   **非剥夺方式**：当优先级更高的进程转成就绪状态，仍然让正在执行的进程继续执行，直到该进程完成或者发生某事件（如提出I/O请求）而进入“完成”或“阻塞”状态时，才把处理机分配给重要的进程\n    *   **可剥夺方式**：当有优先级更高的进程转变成就绪状态时，便暂停正在执行的进程，立即把处理机分配给高优先级的进程，这种方式称为可剥夺方式。（可称为：可抢占的调度策略）采用可剥夺调度方式时，系统中正在运行的进程的优先级一定是最高的。可剥夺的调度方式的缺点是 系统的开销比非剥夺的调度方式要大，因为可能增加处理机切换的次数。\n&nbsp;\n\n*   处理机调度分为：\n\n    *   作业调度（宏观）\n    *   进程调度（微观）\n![](http://www.alanpro.win/wp-content/uploads/2017/06/作业和进程调度图.png)\n\n&nbsp;\n\n*   常见的作业调度算法：\n\n    *   FCFS（按先后次序）\n    *   SJF（短作业优先）吞吐量大\n    *   高响应比优先，每次都更新\n\n*   作业的三个状态：\n\n    *   后备状态：作业存放在磁盘上，等待调度\n    *   执行状态：作业进入主存，开始运行\n    *   完成状态：作业计算完成开始，退出系统\n\n*   几个重要的计算：\n\n    *   周转时间 = 当前等待时间+运行时间\n    *   带权周转时间 = 周转时间/执行时间 = 1+当前等待时间/执行时间\n    *   响应比 = 带权周转时间（高响应比优先调度算法的衡量标准）\n\n*   死锁问题：\n\n    *   死锁：两个或多个进程的相互阻塞，一个进程只能称为阻塞；\n    *   根本原因：资源有限（不够）\n    *   进程的推进顺序非法\n\n*   造成死锁的条件：\n\n    *   互斥条件\n    *   不剥夺条件（非抢占）\n    *   占有并等待（部分分配）\n    *   环路条件（循环等待）\n\n*   死锁的解决办法\n\n    *   预防：在并发进程开始之前破坏4个条件\n    *   避免；银行家算法\n    *   检测\n    *   恢复\n\n*   **重点：银行家算法：在资源动态分配的过程中，使用某种方法去避免 系统造成资源的浪费。**\n\n    *   先算当前状态下的need矩阵\n    *   用available矩阵来看哪些先分配。（分配后计算收回后的资源值）\n    *   request的3个步骤：\n\n            1.  判断：request&lt;=available\n        2.  判断：request&lt;=need\n        3.  试探性分配：看新的系统状态是否满足。\n\n        *   保证每次分配都能满足有安全序列；（期中考试、ppt例题）\n\n*   算最少  m (k-1)+1 （m是进程，k是每个进程需要的资源）\n*   主存管理：\n\n    *   分页：逻辑1维，用户地址1维\n    *   分段：逻辑2维，用户地址2维\n    *   段页式：逻辑3维，用户地址2维\n\n* * *\n\n*   局部性特征：（大多数程序执行时，都有局部性特征）高速缓存与局部性特征有关\n\n    *   时间：某一指令被执行了，它可能在不久的将来会再次被执行\n    *   空间：一旦一个存储单元被访问，那么它邻近存储单元也将很快被访问\n\n* * *\n\n*   主存管理的功能：\n\n    *   地址映射（地址转换/_**重定位**_）：LA-&gt;PA(logic address -&gt; physical address)\n    *   主存分配和回收\n    *   逻辑容量由主存和辅存容量之和决定，其运行速度接近于主存\n    *   存储器容量：\n\n            *   &lt;=辅存\n        *   &lt;2^L Bytes（L是程序地址长度）\n\n* * *\n\n*   分区存储管理（预先划分，内存浪费）\n\n    *   可变区分配：无需预先分配。作业进入内存时划分，动态地划分\n    *   内存的放置策略：\n\n            *   首次适应算法：尽量利用了低地址资源，快速满足需求\n        *   最佳适应算法：大小按递增顺序组织成空间分区链，在分配时总能将满足需求又最小的分区分配给作业\n        *   最差适应算法：按大小递减的顺序组织分区\n\n*   分页式：提高内存利用率，实现了“连续分配”到“非连续分配”的跳跃，不是完全地解决了“空间浪费”的问题\n\n    *   分页式中，存储管理中：物理地址PA = 块首地址+页内地址\n    *   例子：\n\n            *   逻辑地址：2100\n        *   ![](http://www.alanpro.win/wp-content/uploads/2017/06/页号-150x150.jpg)\n        *   2100%1024=2···52（2是页号，52是页内地址）\n        *   查页表：页号-&gt;块号(2-&gt;4)\n        *   物理地址=块首+页内 ： 4*1024 + 52 = 4096+52=4148\n\n*   碎片问题：\n\n    *   外部碎片：分区式：分段式是把一个程序分成多个小程序，本质是分区式\n    *   内部碎片：分布式存储，页内的零头\n\n*   缺页中断率（大题计算）：页面越大，缺页中断率减少（由于局部性）","source":"_posts/e6-93-8d-e4-bd-9c-e7-b3-bb-e7-bb-9f-e8-80-83-e7-82-b9-e5-a4-8d-e4-b9-a0.md","raw":"---\ntitle: 操作系统考点复习\ntags:\n  - 操作系统\nid: 155\ncategories:\n  - 操作系统\ndate: 2017-06-18 17:30:46\n---\n\n&nbsp;\n\n*   什么是操作系统\n\n    *   本质：是一个大型的程序系统软件，处于裸机之上，其他软件系统之下。\n    *   特点：并发性、共享性、不确定性、虚拟性（分时技术相当于虚拟出多个cpu）、异步性（进程的执行并不是一气呵成，而是走走停停）\n    *   宗旨：\n\n            1.  管理所有的软硬件资源，提高资源利用率\n        2.  提供良好的用户界面，方便用户使用\n<!--more-->\n\n*   *   分时技术\n\n            *   概念：把处理机（cpu）时间划分成很短的时间片轮流地分配给各个用户程序使用，如果某个用户程序在分配的时间片用完之前还未计算完，就程序就暂停执行，等待下一轮继续计算，此时cpu的时间片分配给另一个用户程序使用。\n        *   分时操作系统中，响应时间是衡量系统的重要指标\n        *   两个问题分析：\n\n                    1.  时间片过大：退化为“先来先服务”（FCFS）\n            2.  时间片过小：保存现场调用的时间消耗成了主要，进程切换过于频繁，每一次切换都要消耗时间，系统效率急剧下降。\n\n        *   多道程序设计：\n\n            *   概念：在计算机主存中同时存放几道相互独立的程序，它们在操作系统的控制之下，相互地穿插地运行。\n        *   特点：\n\n                    *   **宏观上并行**（同时进入系统的几道程序都处于运行的过程中，它们都开始运行，但都没有运行完毕）\n            *   **微观上串行**（主存中的多道程序轮流或分时地占有处理机，交替执行）\n            *   **多道性**\n\n                *   _补充：批处理系统：_\n\n                    *   缺点：和用户的交互性差（用户不能参与程序的运行）\n            *   优点：吞吐率高。\n\n                *   分时操作系统：一般采用分时技术，使一台计算机同时为多个终端用户服务。该系统对每个用户都能保证足够快的响应时间，并提供交互会话的功能。\n\n                    *   特点：并行性、独占性、交互性。\n\n                *   批处理操作系统和分时操作系统的出现标志着操作系统的形成\n\n        *   处理机（cpu）的特权级：\n\n            *   管态：又称系统态。操作系统的管理程序执行时cpu所处的状态。可以使用全部指令、全部系统资源、访问整个存储区\n        *   目态：又称用户态。用户程序执行时cpu所处的状态。在此状态下禁止使用特权指令。不能直接取用系统资源改变机器状态，只允许使用自己的空间。\n        *   特权级是为了保护系统本身不被破坏。\n        *   **在下列情况下，由目态自动转成管态：**\n\n                    1.  用户进程访问操作系统，要求操作系统的某种服务，这种访问成为系统功能调用。\n            2.  在用户程序执行时，发生一次中断（如I/O完成中断）。\n            3.  在一个用户进程中产生一个错误状态，这种状态被处理为程序性中断。\n            4.  在目态下企图执行一条特权指令，作为一种特殊类型的错误。按照第3条情况处理\n\n        *   作业与作业步：\n\n            *   作业：计算机按照一定步骤执行某一任务\n        *   作业步：每个作业步运行的结果产生下一个作业步所需的文件；步步相承\n\n        *   用户接口：\n\n            *   操作系统提供给用户和计算机打交道的外部机制，用户能够借助这种机制和系统提供的手段来控制用户所在的系统。\n        *   操作系统的用户接口分为两个方面：\n\n                    1.  操作接口：通过该接口来组织自己的工作流程和控制程序的执行\n            2.  程序接口：任何一个用户程序在运行过程中，可以使用操作系统提供的功能调用来请求操作系统的服务。（如申请主存、使用各种外设、创建进程fork、线程等等）\n\n                *   不论哪类操作系统都要同时提供操作接口和程序接口。\n\n        *   顺序程序的特点：顺序性、封闭性、可再现性\n    *   程序的并发执行：若干个程序同时在系统中运行，这些程序的执行时间是重叠的，一个程序的执行尚未结束，另一个程序的执行已经开始，称这几个程序是并发执行的。**题型：给几个程序的计算时间和I/O操作，计算并发执行和顺序执行的时间**\n    *   程序的并发可以用如下语句描述：\n<pre>cobegin:\n      S1,S2...Sn;\ncoend</pre>\n\n*   *   并发程序的特点：失去程序的封闭性、程序和计算不再一一对应、程序并发执行时的相互制约关系（竞争系统资源、进程之间相互合作）\n    *   与时间有关的错误：程序并发执行时如果共享了公共变量，其执行结果将与并发程序执行的相对速度有关，即给定相同的初始条件，也可能会得到不同的结果，此为与时间有关的错误。\n    *   **进程：是一个程序在给定_活动空间_和_初始环境_下，在一个处理机上的执行过程。也可以解释为：一个具有一定独立功能的程序关于某个数据集合的一次运行活动。**\n    *   进程和程序是既有联系又有区别：\n\n            1.  程序是指令的有序集合，是一个静态概念，它本身并没有任何运行的含义。而进程是程序在处理机上的一次执行过程，是一个动态的概念。程序可以作为一种软件资料长期保存，而进程是有生命周期的，它能够动态地产生和消亡。进程可由“创建”而产生，由调度而执行，因得不到资源而暂停，以致最后由“撤销”而消亡\n        2.  进程是一个能独立运行的单位，能与其他进程并发地活动\n        3.  进程是竞争计算机系统有限资源的基本单位，也是进行处理机调度的基本单位。\n        4.  没有建立进程的程序，不能作为独立的单位进行运行。\n\n        *   **进程和程序又是有联系的。在支持多任务运行的操作系统中，活动的最小单位是进程。进程_一定至少_包含一个程序，因为程序是进程应完成功能的逻辑描述；而一个程序可以对应多个进程。如果同一程序同时运行于若干个不同的数据集合上，它将属于若干个不同的进程。或者说，若干个不同的进程可以包含同一个程序。**\n    *   状态变迁图：![](http://www.alanpro.win/wp-content/uploads/2017/06/状态变迁图.png)\n\n            *   就绪：当进程获得了除cpu以外的所有资源，它已经准备就绪，一旦得到cpu的控制权，就可以立即运行\n        *   **状态变迁易错题：在操作系统中用户进程本身启动的唯一状态转换是：阻塞（用户程序可以自己阻塞自己）**\n        *   不可能自己唤醒自己，只能由系统进程或事件发生进程来唤醒。\n\n        *   进程控制块（pcb）：就是一个数据结构，当系统创建一个进程时，必须为它设置一个pcb。为了描述一个进程和其他进程以及系统资源的关系，刻画一个进程在各个不同时期所处的状态。\n\n            *   特点：pcb与进程一一对应，同生同灭。是os感知进程的唯一存在实体（实际排队的）\n\n        *   同步关系：**多个并发进程，在一些关键点上可能需要相互等待与互通消息**\n\n            *   互斥规则（同步关系的特例）：都要公用一个资源（一次只能一个进程使用的资源：临界资源） **互斥产生的原因是？临界资源本身特性决定的**\n        *   临界资源：一次仅允许一个进程使用的资源\n        *   临界区：在每个进程中，访问临界资源的那段程序，进入临界区的进程必须互斥。\n\n        *   同步机构的信号灯是一个（s,q）的二元组。s&gt;=0，表示可用的临界资源数（绿灯，进程执行）。s&lt;0,表示等待使用该邻接资源的进程个数。（s的初始值不能小于0）\n    *   v操作中，如果s+1&lt;=0,说明s的初始值&lt;=-1，唤醒等待进程：释放（s+1）后仍然小于等于0，那么这个释放的1个资源就给了阻塞的进程。\n<pre>main(){\n  int mutex=1;//互斥信号灯\n  cobegin:\n   Pa();\n   Pb();\n  coend;\n}\nPa()\n{\n  P(mutex);\n    CSa;//临界区\n  V(mutex);\n}\nPb()\n{\n  P(mutex);\n    CSa;//临界区\n  V(mutex);\n}\n</pre>\n分析：初始mutex=1，Pa()开始，做了一次P操作，mutex-1=0，进入a临界区，此时Pb开始执行，mutex-1=-1&lt;0,挂入阻塞队列。当a临界区使用完后，Pa进行V操作，mutex+1=0，唤醒阻塞中的进程，继续Pb的执行过程。\n\n&nbsp;\n\n![](http://www.alanpro.win/wp-content/uploads/2017/06/进程流图-300x214.png)进程流图（好丑）\n\n对应的程序:\n\n<pre>cobegin:\n P1();\n P2();\n P3();\n P4();\n P5();\ncoend;\n//信号量：\ns12=s13=s14=s35=s45=0;\nP1(){\n...\nV(s12);\nV(s13);\nV(s14);\n}\nP2(){\nP(s12);\n...\n}\n\nP3(){\nP(s13);\n...\nV(s35);\n}\n\nP4(){\nP(s14);\n...\nV(s45);\n}\n\nP5(){\nP(s35);\nP(s45);\n...\n}\n</pre>\n总结：有前驱，则进行P操作（等前驱做完）。有后继，则进行V操作。\n\n*   生产者-消费者问题引入：\n\n    *   共享缓冲区的合作进程的同步：\n    *   ![](http://www.alanpro.win/wp-content/uploads/2017/06/共享缓冲区-1024x652.png)\n    *   当cp进程把计算结果送入到缓冲区内，iop才能够从缓冲区中取出，进行打印。那么这就形成了一个同步问题，并且是一个特殊的同步问题，即互斥问题（因为只有一个缓冲区作为临界资源）\n    *   在这里 设置一个表示临界资源的信号量Sa = 1（只有一个空间位置，故为1）,设置一个表示缓冲区是否已经装入计算值的信号量Sb=0.那么他们的同步关系可以描述成：![](http://www.alanpro.win/wp-content/uploads/2017/06/同步描述-1024x407.png)\n    *   根据这个图，程序也就呼之欲出了~\n    *   从这个例子可以看出，cp相当于是生产者，生产了数据。iop是消费者，打印了数据。那么如果说有多个cp和多个iop呢？问题又将会变成怎样结局？如果缓冲区buf的个数也变多了呢？下面来阐述经典的生产者消费者问题\n\n*   ![](http://www.alanpro.win/wp-content/uploads/2017/06/生产者消费者.png)\n\n    *   生产者与消费者的同步关系：\n\n            *   生产者：\n\n                    *   当缓冲区满了，需要等待\n            *   缓冲区还有空间时，向缓冲区放入值\n\n                *   消费者：\n\n                    *   当缓冲区为空，需要等待\n            *   缓冲区有值时，从缓冲区取出值\n\n        *   由于缓冲区有多个空间，用Sb表示缓冲区空间的大小，初值为Sb=n；Sa表示缓冲区当前的值的多少，初值为Sa=0(初始没有一个值，为0)\n    *   由于缓冲区是临界资源，一次只能由一个进程操作，所以需要给“放入缓冲区”和“从缓冲区中取出”这两个动作加上锁，即设置互斥信号量，mutex=0;这里有一个考点：\n    *   _**分析上下两个PV操作的顺序能不能颠倒：**_\n\n            *   P操作颠倒：当Sb为0的时候（即缓冲区满了时），先做P(mutex)操作，再做P(Sb)，此时CPi进程会阻塞；而IOPi进程也因为mutex为0，也是阻塞，无法将缓冲区的数据读出来再做V(Sb)的操作，会产生死锁现象\n        *   V操作颠倒：因为P操作会阻塞进程，V操作是释放（唤醒）进程，不会产生死锁问题。\n\n        *   ![](http://www.alanpro.win/wp-content/uploads/2017/06/生产者消费者-同步描述.png)\n    *   建议看一下：阅览室读书的问题 和 卡片机打印机问题。\n\n*   进程通信：是一个和另一个进程之间共享消息的一种方式\n\n    *   低级通信：pv操作是低级进程通信原语。\n    *   高级通信：\n\n            *   直接通信\n        *   间接通信\n\n*   进程的同步和互斥也是一种进程通信，是低级通信机构\n*   调度方式：在优先调度策略下还要确定调度方式。 就是：如有优先级更高的进程转变为就绪状态时，如何分配处理机。分为：\n\n    *   **非剥夺方式**：当优先级更高的进程转成就绪状态，仍然让正在执行的进程继续执行，直到该进程完成或者发生某事件（如提出I/O请求）而进入“完成”或“阻塞”状态时，才把处理机分配给重要的进程\n    *   **可剥夺方式**：当有优先级更高的进程转变成就绪状态时，便暂停正在执行的进程，立即把处理机分配给高优先级的进程，这种方式称为可剥夺方式。（可称为：可抢占的调度策略）采用可剥夺调度方式时，系统中正在运行的进程的优先级一定是最高的。可剥夺的调度方式的缺点是 系统的开销比非剥夺的调度方式要大，因为可能增加处理机切换的次数。\n&nbsp;\n\n*   处理机调度分为：\n\n    *   作业调度（宏观）\n    *   进程调度（微观）\n![](http://www.alanpro.win/wp-content/uploads/2017/06/作业和进程调度图.png)\n\n&nbsp;\n\n*   常见的作业调度算法：\n\n    *   FCFS（按先后次序）\n    *   SJF（短作业优先）吞吐量大\n    *   高响应比优先，每次都更新\n\n*   作业的三个状态：\n\n    *   后备状态：作业存放在磁盘上，等待调度\n    *   执行状态：作业进入主存，开始运行\n    *   完成状态：作业计算完成开始，退出系统\n\n*   几个重要的计算：\n\n    *   周转时间 = 当前等待时间+运行时间\n    *   带权周转时间 = 周转时间/执行时间 = 1+当前等待时间/执行时间\n    *   响应比 = 带权周转时间（高响应比优先调度算法的衡量标准）\n\n*   死锁问题：\n\n    *   死锁：两个或多个进程的相互阻塞，一个进程只能称为阻塞；\n    *   根本原因：资源有限（不够）\n    *   进程的推进顺序非法\n\n*   造成死锁的条件：\n\n    *   互斥条件\n    *   不剥夺条件（非抢占）\n    *   占有并等待（部分分配）\n    *   环路条件（循环等待）\n\n*   死锁的解决办法\n\n    *   预防：在并发进程开始之前破坏4个条件\n    *   避免；银行家算法\n    *   检测\n    *   恢复\n\n*   **重点：银行家算法：在资源动态分配的过程中，使用某种方法去避免 系统造成资源的浪费。**\n\n    *   先算当前状态下的need矩阵\n    *   用available矩阵来看哪些先分配。（分配后计算收回后的资源值）\n    *   request的3个步骤：\n\n            1.  判断：request&lt;=available\n        2.  判断：request&lt;=need\n        3.  试探性分配：看新的系统状态是否满足。\n\n        *   保证每次分配都能满足有安全序列；（期中考试、ppt例题）\n\n*   算最少  m (k-1)+1 （m是进程，k是每个进程需要的资源）\n*   主存管理：\n\n    *   分页：逻辑1维，用户地址1维\n    *   分段：逻辑2维，用户地址2维\n    *   段页式：逻辑3维，用户地址2维\n\n* * *\n\n*   局部性特征：（大多数程序执行时，都有局部性特征）高速缓存与局部性特征有关\n\n    *   时间：某一指令被执行了，它可能在不久的将来会再次被执行\n    *   空间：一旦一个存储单元被访问，那么它邻近存储单元也将很快被访问\n\n* * *\n\n*   主存管理的功能：\n\n    *   地址映射（地址转换/_**重定位**_）：LA-&gt;PA(logic address -&gt; physical address)\n    *   主存分配和回收\n    *   逻辑容量由主存和辅存容量之和决定，其运行速度接近于主存\n    *   存储器容量：\n\n            *   &lt;=辅存\n        *   &lt;2^L Bytes（L是程序地址长度）\n\n* * *\n\n*   分区存储管理（预先划分，内存浪费）\n\n    *   可变区分配：无需预先分配。作业进入内存时划分，动态地划分\n    *   内存的放置策略：\n\n            *   首次适应算法：尽量利用了低地址资源，快速满足需求\n        *   最佳适应算法：大小按递增顺序组织成空间分区链，在分配时总能将满足需求又最小的分区分配给作业\n        *   最差适应算法：按大小递减的顺序组织分区\n\n*   分页式：提高内存利用率，实现了“连续分配”到“非连续分配”的跳跃，不是完全地解决了“空间浪费”的问题\n\n    *   分页式中，存储管理中：物理地址PA = 块首地址+页内地址\n    *   例子：\n\n            *   逻辑地址：2100\n        *   ![](http://www.alanpro.win/wp-content/uploads/2017/06/页号-150x150.jpg)\n        *   2100%1024=2···52（2是页号，52是页内地址）\n        *   查页表：页号-&gt;块号(2-&gt;4)\n        *   物理地址=块首+页内 ： 4*1024 + 52 = 4096+52=4148\n\n*   碎片问题：\n\n    *   外部碎片：分区式：分段式是把一个程序分成多个小程序，本质是分区式\n    *   内部碎片：分布式存储，页内的零头\n\n*   缺页中断率（大题计算）：页面越大，缺页中断率减少（由于局部性）","slug":"e6-93-8d-e4-bd-9c-e7-b3-bb-e7-bb-9f-e8-80-83-e7-82-b9-e5-a4-8d-e4-b9-a0","published":1,"updated":"2017-12-09T17:06:50.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec13001oiwtw6vqizit5","content":"<p>&nbsp;</p>\n<ul>\n<li><p>什么是操作系统</p>\n<ul>\n<li>本质：是一个大型的程序系统软件，处于裸机之上，其他软件系统之下。</li>\n<li>特点：并发性、共享性、不确定性、虚拟性（分时技术相当于虚拟出多个cpu）、异步性（进程的执行并不是一气呵成，而是走走停停）</li>\n<li><p>宗旨：</p>\n<pre><code>1.  管理所有的软硬件资源，提高资源利用率\n</code></pre><ol>\n<li>提供良好的用户界面，方便用户使用<a id=\"more\"></a>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><ul>\n<li><p>分时技术</p>\n<pre><code>*   概念：把处理机（cpu）时间划分成很短的时间片轮流地分配给各个用户程序使用，如果某个用户程序在分配的时间片用完之前还未计算完，就程序就暂停执行，等待下一轮继续计算，此时cpu的时间片分配给另一个用户程序使用。\n</code></pre><ul>\n<li>分时操作系统中，响应时间是衡量系统的重要指标</li>\n<li><p>两个问题分析：</p>\n<pre><code>1.  时间片过大：退化为“先来先服务”（FCFS）\n</code></pre><ol>\n<li>时间片过小：保存现场调用的时间消耗成了主要，进程切换过于频繁，每一次切换都要消耗时间，系统效率急剧下降。</li>\n</ol>\n</li>\n<li><p>多道程序设计：</p>\n<ul>\n<li>概念：在计算机主存中同时存放几道相互独立的程序，它们在操作系统的控制之下，相互地穿插地运行。</li>\n</ul>\n</li>\n<li><p>特点：</p>\n<pre><code>*   **宏观上并行**（同时进入系统的几道程序都处于运行的过程中，它们都开始运行，但都没有运行完毕）\n</code></pre><ul>\n<li><strong>微观上串行</strong>（主存中的多道程序轮流或分时地占有处理机，交替执行）</li>\n<li><p><strong>多道性</strong></p>\n<ul>\n<li><p><em>补充：批处理系统：</em></p>\n<ul>\n<li>缺点：和用户的交互性差（用户不能参与程序的运行）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优点：吞吐率高。</p>\n<ul>\n<li><p>分时操作系统：一般采用分时技术，使一台计算机同时为多个终端用户服务。该系统对每个用户都能保证足够快的响应时间，并提供交互会话的功能。</p>\n<ul>\n<li>特点：并行性、独占性、交互性。</li>\n</ul>\n</li>\n<li><p>批处理操作系统和分时操作系统的出现标志着操作系统的形成</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>处理机（cpu）的特权级：</p>\n<ul>\n<li>管态：又称系统态。操作系统的管理程序执行时cpu所处的状态。可以使用全部指令、全部系统资源、访问整个存储区</li>\n</ul>\n</li>\n<li>目态：又称用户态。用户程序执行时cpu所处的状态。在此状态下禁止使用特权指令。不能直接取用系统资源改变机器状态，只允许使用自己的空间。</li>\n<li>特权级是为了保护系统本身不被破坏。</li>\n<li><p><strong>在下列情况下，由目态自动转成管态：</strong></p>\n<pre><code>1.  用户进程访问操作系统，要求操作系统的某种服务，这种访问成为系统功能调用。\n</code></pre><ol>\n<li>在用户程序执行时，发生一次中断（如I/O完成中断）。</li>\n<li>在一个用户进程中产生一个错误状态，这种状态被处理为程序性中断。</li>\n<li>在目态下企图执行一条特权指令，作为一种特殊类型的错误。按照第3条情况处理</li>\n</ol>\n</li>\n<li><p>作业与作业步：</p>\n<ul>\n<li>作业：计算机按照一定步骤执行某一任务</li>\n</ul>\n</li>\n<li><p>作业步：每个作业步运行的结果产生下一个作业步所需的文件；步步相承</p>\n</li>\n<li><p>用户接口：</p>\n<ul>\n<li>操作系统提供给用户和计算机打交道的外部机制，用户能够借助这种机制和系统提供的手段来控制用户所在的系统。</li>\n</ul>\n</li>\n<li><p>操作系统的用户接口分为两个方面：</p>\n<pre><code>1.  操作接口：通过该接口来组织自己的工作流程和控制程序的执行\n</code></pre><ol>\n<li><p>程序接口：任何一个用户程序在运行过程中，可以使用操作系统提供的功能调用来请求操作系统的服务。（如申请主存、使用各种外设、创建进程fork、线程等等）</p>\n<ul>\n<li>不论哪类操作系统都要同时提供操作接口和程序接口。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>顺序程序的特点：顺序性、封闭性、可再现性</p>\n</li>\n</ul>\n</li>\n<li>程序的并发执行：若干个程序同时在系统中运行，这些程序的执行时间是重叠的，一个程序的执行尚未结束，另一个程序的执行已经开始，称这几个程序是并发执行的。<strong>题型：给几个程序的计算时间和I/O操作，计算并发执行和顺序执行的时间</strong></li>\n<li>程序的并发可以用如下语句描述：<pre>cobegin:\nS1,S2...Sn;\ncoend</pre>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>并发程序的特点：失去程序的封闭性、程序和计算不再一一对应、程序并发执行时的相互制约关系（竞争系统资源、进程之间相互合作）</li>\n<li>与时间有关的错误：程序并发执行时如果共享了公共变量，其执行结果将与并发程序执行的相对速度有关，即给定相同的初始条件，也可能会得到不同的结果，此为与时间有关的错误。</li>\n<li><strong>进程：是一个程序在给定<em>活动空间</em>和<em>初始环境</em>下，在一个处理机上的执行过程。也可以解释为：一个具有一定独立功能的程序关于某个数据集合的一次运行活动。</strong></li>\n<li><p>进程和程序是既有联系又有区别：</p>\n<pre><code>1.  程序是指令的有序集合，是一个静态概念，它本身并没有任何运行的含义。而进程是程序在处理机上的一次执行过程，是一个动态的概念。程序可以作为一种软件资料长期保存，而进程是有生命周期的，它能够动态地产生和消亡。进程可由“创建”而产生，由调度而执行，因得不到资源而暂停，以致最后由“撤销”而消亡\n</code></pre><ol>\n<li>进程是一个能独立运行的单位，能与其他进程并发地活动</li>\n<li>进程是竞争计算机系统有限资源的基本单位，也是进行处理机调度的基本单位。</li>\n<li>没有建立进程的程序，不能作为独立的单位进行运行。</li>\n</ol>\n<ul>\n<li><strong>进程和程序又是有联系的。在支持多任务运行的操作系统中，活动的最小单位是进程。进程<em>一定至少</em>包含一个程序，因为程序是进程应完成功能的逻辑描述；而一个程序可以对应多个进程。如果同一程序同时运行于若干个不同的数据集合上，它将属于若干个不同的进程。或者说，若干个不同的进程可以包含同一个程序。</strong></li>\n</ul>\n</li>\n<li><p>状态变迁图：<img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/状态变迁图.png\" alt=\"\"></p>\n<pre><code>*   就绪：当进程获得了除cpu以外的所有资源，它已经准备就绪，一旦得到cpu的控制权，就可以立即运行\n</code></pre><ul>\n<li><strong>状态变迁易错题：在操作系统中用户进程本身启动的唯一状态转换是：阻塞（用户程序可以自己阻塞自己）</strong></li>\n<li><p>不可能自己唤醒自己，只能由系统进程或事件发生进程来唤醒。</p>\n</li>\n<li><p>进程控制块（pcb）：就是一个数据结构，当系统创建一个进程时，必须为它设置一个pcb。为了描述一个进程和其他进程以及系统资源的关系，刻画一个进程在各个不同时期所处的状态。</p>\n<ul>\n<li>特点：pcb与进程一一对应，同生同灭。是os感知进程的唯一存在实体（实际排队的）</li>\n</ul>\n</li>\n<li><p>同步关系：<strong>多个并发进程，在一些关键点上可能需要相互等待与互通消息</strong></p>\n<ul>\n<li>互斥规则（同步关系的特例）：都要公用一个资源（一次只能一个进程使用的资源：临界资源） <strong>互斥产生的原因是？临界资源本身特性决定的</strong></li>\n</ul>\n</li>\n<li>临界资源：一次仅允许一个进程使用的资源</li>\n<li><p>临界区：在每个进程中，访问临界资源的那段程序，进入临界区的进程必须互斥。</p>\n</li>\n<li><p>同步机构的信号灯是一个（s,q）的二元组。s&gt;=0，表示可用的临界资源数（绿灯，进程执行）。s&lt;0,表示等待使用该邻接资源的进程个数。（s的初始值不能小于0）</p>\n</li>\n</ul>\n</li>\n<li>v操作中，如果s+1&lt;=0,说明s的初始值&lt;=-1，唤醒等待进程：释放（s+1）后仍然小于等于0，那么这个释放的1个资源就给了阻塞的进程。<br><pre>main(){<br>int mutex=1;//互斥信号灯<br>cobegin:<br>Pa();<br>Pb();<br>coend;<br>}<br>Pa()<br>{<br>P(mutex);<br>CSa;//临界区<br>V(mutex);<br>}<br>Pb()<br>{<br>P(mutex);<br>CSa;//临界区<br>V(mutex);<br>}<br></pre><br>分析：初始mutex=1，Pa()开始，做了一次P操作，mutex-1=0，进入a临界区，此时Pb开始执行，mutex-1=-1&lt;0,挂入阻塞队列。当a临界区使用完后，Pa进行V操作，mutex+1=0，唤醒阻塞中的进程，继续Pb的执行过程。</li>\n</ul>\n</li>\n</ul>\n<p>&nbsp;</p>\n<p><img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/进程流图-300x214.png\" alt=\"\">进程流图（好丑）</p>\n<p>对应的程序:</p>\n<p><pre>cobegin:<br> P1();<br> P2();<br> P3();<br> P4();<br> P5();<br>coend;<br>//信号量：<br>s12=s13=s14=s35=s45=0;<br>P1(){<br>…<br>V(s12);<br>V(s13);<br>V(s14);<br>}<br>P2(){<br>P(s12);<br>…<br>}</pre></p>\n<p>P3(){<br>P(s13);<br>…<br>V(s35);<br>}</p>\n<p>P4(){<br>P(s14);<br>…<br>V(s45);<br>}</p>\n<p>P5(){<br>P(s35);<br>P(s45);<br>…<br>}<br><br>总结：有前驱，则进行P操作（等前驱做完）。有后继，则进行V操作。</p>\n<ul>\n<li><p>生产者-消费者问题引入：</p>\n<ul>\n<li>共享缓冲区的合作进程的同步：</li>\n<li><img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/共享缓冲区-1024x652.png\" alt=\"\"></li>\n<li>当cp进程把计算结果送入到缓冲区内，iop才能够从缓冲区中取出，进行打印。那么这就形成了一个同步问题，并且是一个特殊的同步问题，即互斥问题（因为只有一个缓冲区作为临界资源）</li>\n<li>在这里 设置一个表示临界资源的信号量Sa = 1（只有一个空间位置，故为1）,设置一个表示缓冲区是否已经装入计算值的信号量Sb=0.那么他们的同步关系可以描述成：<img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/同步描述-1024x407.png\" alt=\"\"></li>\n<li>根据这个图，程序也就呼之欲出了~</li>\n<li>从这个例子可以看出，cp相当于是生产者，生产了数据。iop是消费者，打印了数据。那么如果说有多个cp和多个iop呢？问题又将会变成怎样结局？如果缓冲区buf的个数也变多了呢？下面来阐述经典的生产者消费者问题</li>\n</ul>\n</li>\n<li><p><img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/生产者消费者.png\" alt=\"\"></p>\n<ul>\n<li><p>生产者与消费者的同步关系：</p>\n<pre><code>*   生产者：\n\n        *   当缓冲区满了，需要等待\n*   缓冲区还有空间时，向缓冲区放入值\n\n    *   消费者：\n\n        *   当缓冲区为空，需要等待\n*   缓冲区有值时，从缓冲区取出值\n</code></pre><ul>\n<li>由于缓冲区有多个空间，用Sb表示缓冲区空间的大小，初值为Sb=n；Sa表示缓冲区当前的值的多少，初值为Sa=0(初始没有一个值，为0)</li>\n</ul>\n</li>\n<li>由于缓冲区是临界资源，一次只能由一个进程操作，所以需要给“放入缓冲区”和“从缓冲区中取出”这两个动作加上锁，即设置互斥信号量，mutex=0;这里有一个考点：</li>\n<li><p><em><strong>分析上下两个PV操作的顺序能不能颠倒：</strong></em></p>\n<pre><code>*   P操作颠倒：当Sb为0的时候（即缓冲区满了时），先做P(mutex)操作，再做P(Sb)，此时CPi进程会阻塞；而IOPi进程也因为mutex为0，也是阻塞，无法将缓冲区的数据读出来再做V(Sb)的操作，会产生死锁现象\n</code></pre><ul>\n<li><p>V操作颠倒：因为P操作会阻塞进程，V操作是释放（唤醒）进程，不会产生死锁问题。</p>\n</li>\n<li><p><img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/生产者消费者-同步描述.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n<li>建议看一下：阅览室读书的问题 和 卡片机打印机问题。</li>\n</ul>\n</li>\n<li><p>进程通信：是一个和另一个进程之间共享消息的一种方式</p>\n<ul>\n<li>低级通信：pv操作是低级进程通信原语。</li>\n<li><p>高级通信：</p>\n<pre><code>*   直接通信\n</code></pre><ul>\n<li>间接通信</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进程的同步和互斥也是一种进程通信，是低级通信机构</p>\n</li>\n<li><p>调度方式：在优先调度策略下还要确定调度方式。 就是：如有优先级更高的进程转变为就绪状态时，如何分配处理机。分为：</p>\n<ul>\n<li><strong>非剥夺方式</strong>：当优先级更高的进程转成就绪状态，仍然让正在执行的进程继续执行，直到该进程完成或者发生某事件（如提出I/O请求）而进入“完成”或“阻塞”状态时，才把处理机分配给重要的进程</li>\n<li><strong>可剥夺方式</strong>：当有优先级更高的进程转变成就绪状态时，便暂停正在执行的进程，立即把处理机分配给高优先级的进程，这种方式称为可剥夺方式。（可称为：可抢占的调度策略）采用可剥夺调度方式时，系统中正在运行的进程的优先级一定是最高的。可剥夺的调度方式的缺点是 系统的开销比非剥夺的调度方式要大，因为可能增加处理机切换的次数。<br>&nbsp;</li>\n</ul>\n</li>\n<li><p>处理机调度分为：</p>\n<ul>\n<li>作业调度（宏观）</li>\n<li>进程调度（微观）<br><img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/作业和进程调度图.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<p>&nbsp;</p>\n<ul>\n<li><p>常见的作业调度算法：</p>\n<ul>\n<li>FCFS（按先后次序）</li>\n<li>SJF（短作业优先）吞吐量大</li>\n<li>高响应比优先，每次都更新</li>\n</ul>\n</li>\n<li><p>作业的三个状态：</p>\n<ul>\n<li>后备状态：作业存放在磁盘上，等待调度</li>\n<li>执行状态：作业进入主存，开始运行</li>\n<li>完成状态：作业计算完成开始，退出系统</li>\n</ul>\n</li>\n<li><p>几个重要的计算：</p>\n<ul>\n<li>周转时间 = 当前等待时间+运行时间</li>\n<li>带权周转时间 = 周转时间/执行时间 = 1+当前等待时间/执行时间</li>\n<li>响应比 = 带权周转时间（高响应比优先调度算法的衡量标准）</li>\n</ul>\n</li>\n<li><p>死锁问题：</p>\n<ul>\n<li>死锁：两个或多个进程的相互阻塞，一个进程只能称为阻塞；</li>\n<li>根本原因：资源有限（不够）</li>\n<li>进程的推进顺序非法</li>\n</ul>\n</li>\n<li><p>造成死锁的条件：</p>\n<ul>\n<li>互斥条件</li>\n<li>不剥夺条件（非抢占）</li>\n<li>占有并等待（部分分配）</li>\n<li>环路条件（循环等待）</li>\n</ul>\n</li>\n<li><p>死锁的解决办法</p>\n<ul>\n<li>预防：在并发进程开始之前破坏4个条件</li>\n<li>避免；银行家算法</li>\n<li>检测</li>\n<li>恢复</li>\n</ul>\n</li>\n<li><p><strong>重点：银行家算法：在资源动态分配的过程中，使用某种方法去避免 系统造成资源的浪费。</strong></p>\n<ul>\n<li>先算当前状态下的need矩阵</li>\n<li>用available矩阵来看哪些先分配。（分配后计算收回后的资源值）</li>\n<li><p>request的3个步骤：</p>\n<pre><code>1.  判断：request&amp;lt;=available\n</code></pre><ol>\n<li>判断：request&lt;=need</li>\n<li>试探性分配：看新的系统状态是否满足。</li>\n</ol>\n<ul>\n<li>保证每次分配都能满足有安全序列；（期中考试、ppt例题）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>算最少  m (k-1)+1 （m是进程，k是每个进程需要的资源）</p>\n</li>\n<li><p>主存管理：</p>\n<ul>\n<li>分页：逻辑1维，用户地址1维</li>\n<li>分段：逻辑2维，用户地址2维</li>\n<li>段页式：逻辑3维，用户地址2维</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>局部性特征：（大多数程序执行时，都有局部性特征）高速缓存与局部性特征有关</p>\n<ul>\n<li>时间：某一指令被执行了，它可能在不久的将来会再次被执行</li>\n<li>空间：一旦一个存储单元被访问，那么它邻近存储单元也将很快被访问</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>主存管理的功能：</p>\n<ul>\n<li>地址映射（地址转换/<em><strong>重定位</strong></em>）：LA-&gt;PA(logic address -&gt; physical address)</li>\n<li>主存分配和回收</li>\n<li>逻辑容量由主存和辅存容量之和决定，其运行速度接近于主存</li>\n<li><p>存储器容量：</p>\n<pre><code>*   &amp;lt;=辅存\n</code></pre><ul>\n<li>&lt;2^L Bytes（L是程序地址长度）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>分区存储管理（预先划分，内存浪费）</p>\n<ul>\n<li>可变区分配：无需预先分配。作业进入内存时划分，动态地划分</li>\n<li><p>内存的放置策略：</p>\n<pre><code>*   首次适应算法：尽量利用了低地址资源，快速满足需求\n</code></pre><ul>\n<li>最佳适应算法：大小按递增顺序组织成空间分区链，在分配时总能将满足需求又最小的分区分配给作业</li>\n<li>最差适应算法：按大小递减的顺序组织分区</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分页式：提高内存利用率，实现了“连续分配”到“非连续分配”的跳跃，不是完全地解决了“空间浪费”的问题</p>\n<ul>\n<li>分页式中，存储管理中：物理地址PA = 块首地址+页内地址</li>\n<li><p>例子：</p>\n<pre><code>*   逻辑地址：2100\n</code></pre><ul>\n<li><img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/页号-150x150.jpg\" alt=\"\"></li>\n<li>2100%1024=2···52（2是页号，52是页内地址）</li>\n<li>查页表：页号-&gt;块号(2-&gt;4)</li>\n<li>物理地址=块首+页内 ： 4*1024 + 52 = 4096+52=4148</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>碎片问题：</p>\n<ul>\n<li>外部碎片：分区式：分段式是把一个程序分成多个小程序，本质是分区式</li>\n<li>内部碎片：分布式存储，页内的零头</li>\n</ul>\n</li>\n<li><p>缺页中断率（大题计算）：页面越大，缺页中断率减少（由于局部性）</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>&nbsp;</p>\n<ul>\n<li><p>什么是操作系统</p>\n<ul>\n<li>本质：是一个大型的程序系统软件，处于裸机之上，其他软件系统之下。</li>\n<li>特点：并发性、共享性、不确定性、虚拟性（分时技术相当于虚拟出多个cpu）、异步性（进程的执行并不是一气呵成，而是走走停停）</li>\n<li><p>宗旨：</p>\n<pre><code>1.  管理所有的软硬件资源，提高资源利用率\n</code></pre><ol>\n<li>提供良好的用户界面，方便用户使用","more":"</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><ul>\n<li><p>分时技术</p>\n<pre><code>*   概念：把处理机（cpu）时间划分成很短的时间片轮流地分配给各个用户程序使用，如果某个用户程序在分配的时间片用完之前还未计算完，就程序就暂停执行，等待下一轮继续计算，此时cpu的时间片分配给另一个用户程序使用。\n</code></pre><ul>\n<li>分时操作系统中，响应时间是衡量系统的重要指标</li>\n<li><p>两个问题分析：</p>\n<pre><code>1.  时间片过大：退化为“先来先服务”（FCFS）\n</code></pre><ol>\n<li>时间片过小：保存现场调用的时间消耗成了主要，进程切换过于频繁，每一次切换都要消耗时间，系统效率急剧下降。</li>\n</ol>\n</li>\n<li><p>多道程序设计：</p>\n<ul>\n<li>概念：在计算机主存中同时存放几道相互独立的程序，它们在操作系统的控制之下，相互地穿插地运行。</li>\n</ul>\n</li>\n<li><p>特点：</p>\n<pre><code>*   **宏观上并行**（同时进入系统的几道程序都处于运行的过程中，它们都开始运行，但都没有运行完毕）\n</code></pre><ul>\n<li><strong>微观上串行</strong>（主存中的多道程序轮流或分时地占有处理机，交替执行）</li>\n<li><p><strong>多道性</strong></p>\n<ul>\n<li><p><em>补充：批处理系统：</em></p>\n<ul>\n<li>缺点：和用户的交互性差（用户不能参与程序的运行）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优点：吞吐率高。</p>\n<ul>\n<li><p>分时操作系统：一般采用分时技术，使一台计算机同时为多个终端用户服务。该系统对每个用户都能保证足够快的响应时间，并提供交互会话的功能。</p>\n<ul>\n<li>特点：并行性、独占性、交互性。</li>\n</ul>\n</li>\n<li><p>批处理操作系统和分时操作系统的出现标志着操作系统的形成</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>处理机（cpu）的特权级：</p>\n<ul>\n<li>管态：又称系统态。操作系统的管理程序执行时cpu所处的状态。可以使用全部指令、全部系统资源、访问整个存储区</li>\n</ul>\n</li>\n<li>目态：又称用户态。用户程序执行时cpu所处的状态。在此状态下禁止使用特权指令。不能直接取用系统资源改变机器状态，只允许使用自己的空间。</li>\n<li>特权级是为了保护系统本身不被破坏。</li>\n<li><p><strong>在下列情况下，由目态自动转成管态：</strong></p>\n<pre><code>1.  用户进程访问操作系统，要求操作系统的某种服务，这种访问成为系统功能调用。\n</code></pre><ol>\n<li>在用户程序执行时，发生一次中断（如I/O完成中断）。</li>\n<li>在一个用户进程中产生一个错误状态，这种状态被处理为程序性中断。</li>\n<li>在目态下企图执行一条特权指令，作为一种特殊类型的错误。按照第3条情况处理</li>\n</ol>\n</li>\n<li><p>作业与作业步：</p>\n<ul>\n<li>作业：计算机按照一定步骤执行某一任务</li>\n</ul>\n</li>\n<li><p>作业步：每个作业步运行的结果产生下一个作业步所需的文件；步步相承</p>\n</li>\n<li><p>用户接口：</p>\n<ul>\n<li>操作系统提供给用户和计算机打交道的外部机制，用户能够借助这种机制和系统提供的手段来控制用户所在的系统。</li>\n</ul>\n</li>\n<li><p>操作系统的用户接口分为两个方面：</p>\n<pre><code>1.  操作接口：通过该接口来组织自己的工作流程和控制程序的执行\n</code></pre><ol>\n<li><p>程序接口：任何一个用户程序在运行过程中，可以使用操作系统提供的功能调用来请求操作系统的服务。（如申请主存、使用各种外设、创建进程fork、线程等等）</p>\n<ul>\n<li>不论哪类操作系统都要同时提供操作接口和程序接口。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>顺序程序的特点：顺序性、封闭性、可再现性</p>\n</li>\n</ul>\n</li>\n<li>程序的并发执行：若干个程序同时在系统中运行，这些程序的执行时间是重叠的，一个程序的执行尚未结束，另一个程序的执行已经开始，称这几个程序是并发执行的。<strong>题型：给几个程序的计算时间和I/O操作，计算并发执行和顺序执行的时间</strong></li>\n<li>程序的并发可以用如下语句描述：<pre>cobegin:\nS1,S2...Sn;\ncoend</pre>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>并发程序的特点：失去程序的封闭性、程序和计算不再一一对应、程序并发执行时的相互制约关系（竞争系统资源、进程之间相互合作）</li>\n<li>与时间有关的错误：程序并发执行时如果共享了公共变量，其执行结果将与并发程序执行的相对速度有关，即给定相同的初始条件，也可能会得到不同的结果，此为与时间有关的错误。</li>\n<li><strong>进程：是一个程序在给定<em>活动空间</em>和<em>初始环境</em>下，在一个处理机上的执行过程。也可以解释为：一个具有一定独立功能的程序关于某个数据集合的一次运行活动。</strong></li>\n<li><p>进程和程序是既有联系又有区别：</p>\n<pre><code>1.  程序是指令的有序集合，是一个静态概念，它本身并没有任何运行的含义。而进程是程序在处理机上的一次执行过程，是一个动态的概念。程序可以作为一种软件资料长期保存，而进程是有生命周期的，它能够动态地产生和消亡。进程可由“创建”而产生，由调度而执行，因得不到资源而暂停，以致最后由“撤销”而消亡\n</code></pre><ol>\n<li>进程是一个能独立运行的单位，能与其他进程并发地活动</li>\n<li>进程是竞争计算机系统有限资源的基本单位，也是进行处理机调度的基本单位。</li>\n<li>没有建立进程的程序，不能作为独立的单位进行运行。</li>\n</ol>\n<ul>\n<li><strong>进程和程序又是有联系的。在支持多任务运行的操作系统中，活动的最小单位是进程。进程<em>一定至少</em>包含一个程序，因为程序是进程应完成功能的逻辑描述；而一个程序可以对应多个进程。如果同一程序同时运行于若干个不同的数据集合上，它将属于若干个不同的进程。或者说，若干个不同的进程可以包含同一个程序。</strong></li>\n</ul>\n</li>\n<li><p>状态变迁图：<img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/状态变迁图.png\" alt=\"\"></p>\n<pre><code>*   就绪：当进程获得了除cpu以外的所有资源，它已经准备就绪，一旦得到cpu的控制权，就可以立即运行\n</code></pre><ul>\n<li><strong>状态变迁易错题：在操作系统中用户进程本身启动的唯一状态转换是：阻塞（用户程序可以自己阻塞自己）</strong></li>\n<li><p>不可能自己唤醒自己，只能由系统进程或事件发生进程来唤醒。</p>\n</li>\n<li><p>进程控制块（pcb）：就是一个数据结构，当系统创建一个进程时，必须为它设置一个pcb。为了描述一个进程和其他进程以及系统资源的关系，刻画一个进程在各个不同时期所处的状态。</p>\n<ul>\n<li>特点：pcb与进程一一对应，同生同灭。是os感知进程的唯一存在实体（实际排队的）</li>\n</ul>\n</li>\n<li><p>同步关系：<strong>多个并发进程，在一些关键点上可能需要相互等待与互通消息</strong></p>\n<ul>\n<li>互斥规则（同步关系的特例）：都要公用一个资源（一次只能一个进程使用的资源：临界资源） <strong>互斥产生的原因是？临界资源本身特性决定的</strong></li>\n</ul>\n</li>\n<li>临界资源：一次仅允许一个进程使用的资源</li>\n<li><p>临界区：在每个进程中，访问临界资源的那段程序，进入临界区的进程必须互斥。</p>\n</li>\n<li><p>同步机构的信号灯是一个（s,q）的二元组。s&gt;=0，表示可用的临界资源数（绿灯，进程执行）。s&lt;0,表示等待使用该邻接资源的进程个数。（s的初始值不能小于0）</p>\n</li>\n</ul>\n</li>\n<li>v操作中，如果s+1&lt;=0,说明s的初始值&lt;=-1，唤醒等待进程：释放（s+1）后仍然小于等于0，那么这个释放的1个资源就给了阻塞的进程。<br><pre>main(){<br>int mutex=1;//互斥信号灯<br>cobegin:<br>Pa();<br>Pb();<br>coend;<br>}<br>Pa()<br>{<br>P(mutex);<br>CSa;//临界区<br>V(mutex);<br>}<br>Pb()<br>{<br>P(mutex);<br>CSa;//临界区<br>V(mutex);<br>}<br></pre><br>分析：初始mutex=1，Pa()开始，做了一次P操作，mutex-1=0，进入a临界区，此时Pb开始执行，mutex-1=-1&lt;0,挂入阻塞队列。当a临界区使用完后，Pa进行V操作，mutex+1=0，唤醒阻塞中的进程，继续Pb的执行过程。</li>\n</ul>\n</li>\n</ul>\n<p>&nbsp;</p>\n<p><img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/进程流图-300x214.png\" alt=\"\">进程流图（好丑）</p>\n<p>对应的程序:</p>\n<p><pre>cobegin:<br> P1();<br> P2();<br> P3();<br> P4();<br> P5();<br>coend;<br>//信号量：<br>s12=s13=s14=s35=s45=0;<br>P1(){<br>…<br>V(s12);<br>V(s13);<br>V(s14);<br>}<br>P2(){<br>P(s12);<br>…<br>}</pre></p>\n<p>P3(){<br>P(s13);<br>…<br>V(s35);<br>}</p>\n<p>P4(){<br>P(s14);<br>…<br>V(s45);<br>}</p>\n<p>P5(){<br>P(s35);<br>P(s45);<br>…<br>}<br><br>总结：有前驱，则进行P操作（等前驱做完）。有后继，则进行V操作。</p>\n<ul>\n<li><p>生产者-消费者问题引入：</p>\n<ul>\n<li>共享缓冲区的合作进程的同步：</li>\n<li><img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/共享缓冲区-1024x652.png\" alt=\"\"></li>\n<li>当cp进程把计算结果送入到缓冲区内，iop才能够从缓冲区中取出，进行打印。那么这就形成了一个同步问题，并且是一个特殊的同步问题，即互斥问题（因为只有一个缓冲区作为临界资源）</li>\n<li>在这里 设置一个表示临界资源的信号量Sa = 1（只有一个空间位置，故为1）,设置一个表示缓冲区是否已经装入计算值的信号量Sb=0.那么他们的同步关系可以描述成：<img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/同步描述-1024x407.png\" alt=\"\"></li>\n<li>根据这个图，程序也就呼之欲出了~</li>\n<li>从这个例子可以看出，cp相当于是生产者，生产了数据。iop是消费者，打印了数据。那么如果说有多个cp和多个iop呢？问题又将会变成怎样结局？如果缓冲区buf的个数也变多了呢？下面来阐述经典的生产者消费者问题</li>\n</ul>\n</li>\n<li><p><img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/生产者消费者.png\" alt=\"\"></p>\n<ul>\n<li><p>生产者与消费者的同步关系：</p>\n<pre><code>*   生产者：\n\n        *   当缓冲区满了，需要等待\n*   缓冲区还有空间时，向缓冲区放入值\n\n    *   消费者：\n\n        *   当缓冲区为空，需要等待\n*   缓冲区有值时，从缓冲区取出值\n</code></pre><ul>\n<li>由于缓冲区有多个空间，用Sb表示缓冲区空间的大小，初值为Sb=n；Sa表示缓冲区当前的值的多少，初值为Sa=0(初始没有一个值，为0)</li>\n</ul>\n</li>\n<li>由于缓冲区是临界资源，一次只能由一个进程操作，所以需要给“放入缓冲区”和“从缓冲区中取出”这两个动作加上锁，即设置互斥信号量，mutex=0;这里有一个考点：</li>\n<li><p><em><strong>分析上下两个PV操作的顺序能不能颠倒：</strong></em></p>\n<pre><code>*   P操作颠倒：当Sb为0的时候（即缓冲区满了时），先做P(mutex)操作，再做P(Sb)，此时CPi进程会阻塞；而IOPi进程也因为mutex为0，也是阻塞，无法将缓冲区的数据读出来再做V(Sb)的操作，会产生死锁现象\n</code></pre><ul>\n<li><p>V操作颠倒：因为P操作会阻塞进程，V操作是释放（唤醒）进程，不会产生死锁问题。</p>\n</li>\n<li><p><img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/生产者消费者-同步描述.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n<li>建议看一下：阅览室读书的问题 和 卡片机打印机问题。</li>\n</ul>\n</li>\n<li><p>进程通信：是一个和另一个进程之间共享消息的一种方式</p>\n<ul>\n<li>低级通信：pv操作是低级进程通信原语。</li>\n<li><p>高级通信：</p>\n<pre><code>*   直接通信\n</code></pre><ul>\n<li>间接通信</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进程的同步和互斥也是一种进程通信，是低级通信机构</p>\n</li>\n<li><p>调度方式：在优先调度策略下还要确定调度方式。 就是：如有优先级更高的进程转变为就绪状态时，如何分配处理机。分为：</p>\n<ul>\n<li><strong>非剥夺方式</strong>：当优先级更高的进程转成就绪状态，仍然让正在执行的进程继续执行，直到该进程完成或者发生某事件（如提出I/O请求）而进入“完成”或“阻塞”状态时，才把处理机分配给重要的进程</li>\n<li><strong>可剥夺方式</strong>：当有优先级更高的进程转变成就绪状态时，便暂停正在执行的进程，立即把处理机分配给高优先级的进程，这种方式称为可剥夺方式。（可称为：可抢占的调度策略）采用可剥夺调度方式时，系统中正在运行的进程的优先级一定是最高的。可剥夺的调度方式的缺点是 系统的开销比非剥夺的调度方式要大，因为可能增加处理机切换的次数。<br>&nbsp;</li>\n</ul>\n</li>\n<li><p>处理机调度分为：</p>\n<ul>\n<li>作业调度（宏观）</li>\n<li>进程调度（微观）<br><img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/作业和进程调度图.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<p>&nbsp;</p>\n<ul>\n<li><p>常见的作业调度算法：</p>\n<ul>\n<li>FCFS（按先后次序）</li>\n<li>SJF（短作业优先）吞吐量大</li>\n<li>高响应比优先，每次都更新</li>\n</ul>\n</li>\n<li><p>作业的三个状态：</p>\n<ul>\n<li>后备状态：作业存放在磁盘上，等待调度</li>\n<li>执行状态：作业进入主存，开始运行</li>\n<li>完成状态：作业计算完成开始，退出系统</li>\n</ul>\n</li>\n<li><p>几个重要的计算：</p>\n<ul>\n<li>周转时间 = 当前等待时间+运行时间</li>\n<li>带权周转时间 = 周转时间/执行时间 = 1+当前等待时间/执行时间</li>\n<li>响应比 = 带权周转时间（高响应比优先调度算法的衡量标准）</li>\n</ul>\n</li>\n<li><p>死锁问题：</p>\n<ul>\n<li>死锁：两个或多个进程的相互阻塞，一个进程只能称为阻塞；</li>\n<li>根本原因：资源有限（不够）</li>\n<li>进程的推进顺序非法</li>\n</ul>\n</li>\n<li><p>造成死锁的条件：</p>\n<ul>\n<li>互斥条件</li>\n<li>不剥夺条件（非抢占）</li>\n<li>占有并等待（部分分配）</li>\n<li>环路条件（循环等待）</li>\n</ul>\n</li>\n<li><p>死锁的解决办法</p>\n<ul>\n<li>预防：在并发进程开始之前破坏4个条件</li>\n<li>避免；银行家算法</li>\n<li>检测</li>\n<li>恢复</li>\n</ul>\n</li>\n<li><p><strong>重点：银行家算法：在资源动态分配的过程中，使用某种方法去避免 系统造成资源的浪费。</strong></p>\n<ul>\n<li>先算当前状态下的need矩阵</li>\n<li>用available矩阵来看哪些先分配。（分配后计算收回后的资源值）</li>\n<li><p>request的3个步骤：</p>\n<pre><code>1.  判断：request&amp;lt;=available\n</code></pre><ol>\n<li>判断：request&lt;=need</li>\n<li>试探性分配：看新的系统状态是否满足。</li>\n</ol>\n<ul>\n<li>保证每次分配都能满足有安全序列；（期中考试、ppt例题）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>算最少  m (k-1)+1 （m是进程，k是每个进程需要的资源）</p>\n</li>\n<li><p>主存管理：</p>\n<ul>\n<li>分页：逻辑1维，用户地址1维</li>\n<li>分段：逻辑2维，用户地址2维</li>\n<li>段页式：逻辑3维，用户地址2维</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>局部性特征：（大多数程序执行时，都有局部性特征）高速缓存与局部性特征有关</p>\n<ul>\n<li>时间：某一指令被执行了，它可能在不久的将来会再次被执行</li>\n<li>空间：一旦一个存储单元被访问，那么它邻近存储单元也将很快被访问</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>主存管理的功能：</p>\n<ul>\n<li>地址映射（地址转换/<em><strong>重定位</strong></em>）：LA-&gt;PA(logic address -&gt; physical address)</li>\n<li>主存分配和回收</li>\n<li>逻辑容量由主存和辅存容量之和决定，其运行速度接近于主存</li>\n<li><p>存储器容量：</p>\n<pre><code>*   &amp;lt;=辅存\n</code></pre><ul>\n<li>&lt;2^L Bytes（L是程序地址长度）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>分区存储管理（预先划分，内存浪费）</p>\n<ul>\n<li>可变区分配：无需预先分配。作业进入内存时划分，动态地划分</li>\n<li><p>内存的放置策略：</p>\n<pre><code>*   首次适应算法：尽量利用了低地址资源，快速满足需求\n</code></pre><ul>\n<li>最佳适应算法：大小按递增顺序组织成空间分区链，在分配时总能将满足需求又最小的分区分配给作业</li>\n<li>最差适应算法：按大小递减的顺序组织分区</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分页式：提高内存利用率，实现了“连续分配”到“非连续分配”的跳跃，不是完全地解决了“空间浪费”的问题</p>\n<ul>\n<li>分页式中，存储管理中：物理地址PA = 块首地址+页内地址</li>\n<li><p>例子：</p>\n<pre><code>*   逻辑地址：2100\n</code></pre><ul>\n<li><img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/页号-150x150.jpg\" alt=\"\"></li>\n<li>2100%1024=2···52（2是页号，52是页内地址）</li>\n<li>查页表：页号-&gt;块号(2-&gt;4)</li>\n<li>物理地址=块首+页内 ： 4*1024 + 52 = 4096+52=4148</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>碎片问题：</p>\n<ul>\n<li>外部碎片：分区式：分段式是把一个程序分成多个小程序，本质是分区式</li>\n<li>内部碎片：分布式存储，页内的零头</li>\n</ul>\n</li>\n<li><p>缺页中断率（大题计算）：页面越大，缺页中断率减少（由于局部性）</p>\n</li>\n</ul>"},{"title":"数组循环右移的O(1)解法","id":"344","date":"2017-09-02T03:25:34.000Z","_content":"\n忘了在哪看到的这个写法，其实很取巧<!--more-->\n\n[cpp]\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main(){\n\tint n, k;\n\tvector&lt;int&gt; a, b;\n\n\tcin &gt;&gt; n &gt;&gt; k;//intput the total number and pivot\n\tint in;\n\n\tfor (size_t i = 0; i != n; ++i){\n\t\tcin &gt;&gt; in;\n\t\tif (i &lt; k){\n\t\t\ta.push_back(in);\n\t\t}\n\t\telse {\n\t\t\tb.push_back(in);\n\t\t}\n\t}\n\n\tfor (size_t i = 0; i != a.size(); ++i){\n\t\tb.push_back(a[i]);\n\t}\n\n\tfor (const auto &amp;i : b)cout &lt;&lt; i &lt;&lt; ' ';\n\n\treturn 0;\n} \n[/cpp]","source":"_posts/e6-95-b0-e7-bb-84-e5-be-aa-e7-8e-af-e5-8f-b3-e7-a7-bb-e7-9a-84o1-e8-a7-a3-e6-b3-95.md","raw":"---\ntitle: 数组循环右移的O(1)解法\ntags:\n  - 算法\nid: 344\ncategories:\n  - c++学习\ndate: 2017-09-02 11:25:34\n---\n\n忘了在哪看到的这个写法，其实很取巧<!--more-->\n\n[cpp]\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main(){\n\tint n, k;\n\tvector&lt;int&gt; a, b;\n\n\tcin &gt;&gt; n &gt;&gt; k;//intput the total number and pivot\n\tint in;\n\n\tfor (size_t i = 0; i != n; ++i){\n\t\tcin &gt;&gt; in;\n\t\tif (i &lt; k){\n\t\t\ta.push_back(in);\n\t\t}\n\t\telse {\n\t\t\tb.push_back(in);\n\t\t}\n\t}\n\n\tfor (size_t i = 0; i != a.size(); ++i){\n\t\tb.push_back(a[i]);\n\t}\n\n\tfor (const auto &amp;i : b)cout &lt;&lt; i &lt;&lt; ' ';\n\n\treturn 0;\n} \n[/cpp]","slug":"e6-95-b0-e7-bb-84-e5-be-aa-e7-8e-af-e5-8f-b3-e7-a7-bb-e7-9a-84o1-e8-a7-a3-e6-b3-95","published":1,"updated":"2017-12-09T17:06:50.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec1d001riwtwk0exbhf0","content":"<p>忘了在哪看到的这个写法，其实很取巧<a id=\"more\"></a></p>\n<p>[cpp]</p>\n<p>#include &lt;iostream&gt;</p>\n<p>#include &lt;vector&gt;<br>using namespace std;</p>\n<p>int main(){<br>    int n, k;<br>    vector&lt;int&gt; a, b;</p>\n<pre><code>cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;//intput the total number and pivot\nint in;\n\nfor (size_t i = 0; i != n; ++i){\n    cin &amp;gt;&amp;gt; in;\n    if (i &amp;lt; k){\n        a.push_back(in);\n    }\n    else {\n        b.push_back(in);\n    }\n}\n\nfor (size_t i = 0; i != a.size(); ++i){\n    b.push_back(a[i]);\n}\n\nfor (const auto &amp;amp;i : b)cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &apos; &apos;;\n\nreturn 0;\n</code></pre><p>}<br>[/cpp]</p>\n","site":{"data":{}},"excerpt":"<p>忘了在哪看到的这个写法，其实很取巧","more":"</p>\n<p>[cpp]</p>\n<p>#include &lt;iostream&gt;</p>\n<p>#include &lt;vector&gt;<br>using namespace std;</p>\n<p>int main(){<br>    int n, k;<br>    vector&lt;int&gt; a, b;</p>\n<pre><code>cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;//intput the total number and pivot\nint in;\n\nfor (size_t i = 0; i != n; ++i){\n    cin &amp;gt;&amp;gt; in;\n    if (i &amp;lt; k){\n        a.push_back(in);\n    }\n    else {\n        b.push_back(in);\n    }\n}\n\nfor (size_t i = 0; i != a.size(); ++i){\n    b.push_back(a[i]);\n}\n\nfor (const auto &amp;amp;i : b)cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &apos; &apos;;\n\nreturn 0;\n</code></pre><p>}<br>[/cpp]</p>"},{"title":"服务器远程访问相关","id":"367","date":"2017-10-19T05:50:13.000Z","_content":"\nubuntu远程访问服务器：\n\n要用ssh远程访问服务器，就需要保证本机安装了ssh，可以先确认是否安装了ssh：\ndpkg -l|grep ssh（如果没有安装，则用sudo apt-get install openssh-client，如果本机开放ssh服务就需要安装openssh-server）<!--more-->\n用命令:ps -e|gerp ssh 查看ssh-server是否启动。\n如果没有启动，需要： service sshd start\n\n登陆ssh（linux）：\nssh username@ip -p port\n例如：ssh root@45.78.31.xx -p 1234（不加-p port 的默认端口号是22）\n\n&nbsp;\n\n&nbsp;","source":"_posts/e6-9c-8d-e5-8a-a1-e5-99-a8-e8-bf-9c-e7-a8-8b-e8-ae-bf-e9-97-ae-e7-9b-b8-e5-85-b3.md","raw":"---\ntitle: 服务器远程访问相关\nid: 367\ncategories:\n  - 工具们\n  - 操作系统\ndate: 2017-10-19 13:50:13\ntags:\n---\n\nubuntu远程访问服务器：\n\n要用ssh远程访问服务器，就需要保证本机安装了ssh，可以先确认是否安装了ssh：\ndpkg -l|grep ssh（如果没有安装，则用sudo apt-get install openssh-client，如果本机开放ssh服务就需要安装openssh-server）<!--more-->\n用命令:ps -e|gerp ssh 查看ssh-server是否启动。\n如果没有启动，需要： service sshd start\n\n登陆ssh（linux）：\nssh username@ip -p port\n例如：ssh root@45.78.31.xx -p 1234（不加-p port 的默认端口号是22）\n\n&nbsp;\n\n&nbsp;","slug":"e6-9c-8d-e5-8a-a1-e5-99-a8-e8-bf-9c-e7-a8-8b-e8-ae-bf-e9-97-ae-e7-9b-b8-e5-85-b3","published":1,"updated":"2017-12-09T17:06:50.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec1d001viwtw87aoy92u","content":"<p>ubuntu远程访问服务器：</p>\n<p>要用ssh远程访问服务器，就需要保证本机安装了ssh，可以先确认是否安装了ssh：<br>dpkg -l|grep ssh（如果没有安装，则用sudo apt-get install openssh-client，如果本机开放ssh服务就需要安装openssh-server）<a id=\"more\"></a><br>用命令:ps -e|gerp ssh 查看ssh-server是否启动。<br>如果没有启动，需要： service sshd start</p>\n<p>登陆ssh（linux）：<br>ssh username@ip -p port<br>例如：ssh root@45.78.31.xx -p 1234（不加-p port 的默认端口号是22）</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n","site":{"data":{}},"excerpt":"<p>ubuntu远程访问服务器：</p>\n<p>要用ssh远程访问服务器，就需要保证本机安装了ssh，可以先确认是否安装了ssh：<br>dpkg -l|grep ssh（如果没有安装，则用sudo apt-get install openssh-client，如果本机开放ssh服务就需要安装openssh-server）","more":"<br>用命令:ps -e|gerp ssh 查看ssh-server是否启动。<br>如果没有启动，需要： service sshd start</p>\n<p>登陆ssh（linux）：<br>ssh username@ip -p port<br>例如：ssh root@45.78.31.xx -p 1234（不加-p port 的默认端口号是22）</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>"},{"title":"算法入门——深搜（depth first search）小结","id":"97","date":"2017-04-13T13:44:59.000Z","_content":"\n深度优先搜索实质上是图算法中的一种，其简要过程是：从顶点开始，对每个可以访问到的分支路径进行访问，直到不能继续往下深入为止，并且每个结点只访问一次\n\n简而言之：深搜（也叫回溯法）采用的是“一直往下走，走不通了就掉头，换一条路再往下走”。<!--more-->\n\n深度优先搜索的简要步骤：\n\n1：访问顶点v\n\n2：从顶点v开始，对未访问过的v的邻接点开始，对图进行深度优先遍历。直到图中有路径相通的顶点都被访问过为止。\n\n事实上，这个步骤是一个递归步骤：访问了v之后，对v未访问的邻接点进行访问（此时该邻接点相当于之前的顶点v，再继续重复这个过程）\n\n&nbsp;\n\n深度优先搜索的实质就是穷举，按照一定的顺序和规则不断地去尝试，直到找到问题的解。\n\n对于一个问题的第一个状态叫做初始状态，最后要求的状态叫做目的状态。\n\n在搜索的过程中，对当前状态进行检测，如果当前状态满足目的状态，那么这个当前状态就是结果之一。\n\n深度优先搜索用一个数组存放产生的所有状态。\n\n（1） 把初始状态放入数组中，设为当前状态；\n\n（2） 扩展当前的状态，产生一个新的状态放入数组中，同时把新产生的状态设为当前状态；\n\n（3） 判断当前状态是否和前面的重复，如果重复则回到上一个状态，产生它的另一状态；\n\n（4） 判断当前状态是否为目标状态，如果是目标，则找到一个解答，结束算法。\n\n（5） 如果数组为空，说明无解。\n\n说了这么干话，来举几个例子：\n\n最经典的深搜例题：走迷宫：\n\nnyoj上的最少步数：\n\n[http://acm.nyist.net/JudgeOnline/problem.php?pid=58](http://acm.nyist.net/JudgeOnline/problem.php?pid=58)\n\n题目描述：\n\n这有一个迷宫，有0~8行和0~8列：\n\n1,1,1,1,1,1,1,1,1\n1,0,0,1,0,0,1,0,1\n1,0,0,1,1,0,0,0,1\n1,0,1,0,1,1,0,1,1\n1,0,0,0,0,1,0,0,1\n1,1,0,1,0,1,0,0,1\n1,1,0,1,0,1,0,0,1\n1,1,0,1,0,0,0,0,1\n1,1,1,1,1,1,1,1,1\n\n0表示道路，1表示墙。\n\n现在输入一个道路的坐标作为起点，再如输入一个道路的坐标作为终点，问最少走几步才能从起点到达终点？\n\n（注：一步是指从一坐标点走到其上下左右相邻坐标点，如：从（3，1）到（4,1）。）\n\n**输入**\n\n第一行输入一个整数n（0&lt;n&lt;=100），表示有n组测试数据;\n随后n行,每行有四个整数a,b,c,d（0&lt;=a,b,c,d&lt;=8）分别表示起点的行、列，终点的行、列。\n\n**输出**\n\n输出最少走几步。\n\n**样例输入**\n\n2\n\n3 1  5 7\n\n3 1  6 7\n\n**样例输出**\n\n12\n\n11\n\n分析：要从起点找到终点，有很多条路，那么可以用深搜的方法来找出所有的路。把每次走到终点的路长与最小长度minx进行比较，如果长度比minx还要小的话，就更新minx，minx的初始值是0x3fff；\n\n&nbsp;\n<pre>#include \nusing namespace std;\n#include //可以用到memset \n#include \n\nint map[9][9] = {\n 1,1,1,1,1,1,1,1,1,\n 1,0,0,1,0,0,1,0,1,\n 1,0,0,1,1,0,0,0,1,\n 1,0,1,0,1,1,0,1,1,\n 1,0,0,0,0,1,0,0,1,\n 1,1,0,1,0,1,0,0,1,\n 1,1,0,1,0,1,0,0,1,\n 1,1,0,1,0,0,0,0,1,\n 1,1,1,1,1,1,1,1,1\n} ;\n\nstruct point{//坐标的结构体声明 \n\tint x;\n\tint y; \n};\n\nint dir[4][2] = {-1,0,0,1,1,0,0,-1};\nvector v;\nint minx = 0x3fff;\n\nbool notRepeat(point x)\n{\n\tfor (int i = 0; i &lt; v.size(); ++i)\n\t{\n\t\tif (x.x==v[i].x&amp;&amp;x.y==v[i].y)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid dfs(point a, point b)\n{\n\tif (a.x == b.x &amp;&amp; a.y == b.y)\n\t{\n\t\t//结束搜索 \n\n\t\tif (v.size() &lt; minx)\n\t\t{\n\t\t\tminx = v.size();\n\t\t}\n\t\treturn ;\n\t}\n\telse\n\t{\n\t\tfor (int i = 0; i &lt; 4; ++i) { point t; t.x = a.x+dir[i][0]; t.y = a.y+dir[i][1]; if (notRepeat(t) &amp;&amp; !map[t.x][t.y] &amp;&amp; t.x&gt;=0 &amp;&amp; t.y&gt;=0 &amp;&amp; t.x&gt; n;\n\tpoint start;//起点 \n\tpoint finish;\n\n\twhile (n--)\n\t{\n\t\tcin &gt;&gt; start.x &gt;&gt; start.y &gt;&gt; finish.x &gt;&gt; finish.y;\n\n\t\tv.push_back(start);\n\t\tdfs(start, finish);\n\n\t\tv.pop_back();\n\t\tcout &lt;&lt; minx-1 &lt;&lt; endl;\n\t\tminx = 0x3fff;\n\t}\n\n\treturn 0;\n}\n\n</pre>\n这道题写完可以明显的发现，深搜有个很明显的特点：出来混都是要还的，所有用过的标记和坐标，在用完之后都需要还原。","source":"_posts/e7-ae-97-e6-b3-95-e5-85-a5-e9-97-a8-e6-b7-b1-e6-90-9c-ef-bc-88depth-first-search-ef-bc-89-e5-b0-8f-e7-bb-93.md","raw":"---\ntitle: 算法入门——深搜（depth first search）小结\ntags:\n  - 算法\n  - 算法学习\nid: 97\ncategories:\n  - web学习整理\ndate: 2017-04-13 21:44:59\n---\n\n深度优先搜索实质上是图算法中的一种，其简要过程是：从顶点开始，对每个可以访问到的分支路径进行访问，直到不能继续往下深入为止，并且每个结点只访问一次\n\n简而言之：深搜（也叫回溯法）采用的是“一直往下走，走不通了就掉头，换一条路再往下走”。<!--more-->\n\n深度优先搜索的简要步骤：\n\n1：访问顶点v\n\n2：从顶点v开始，对未访问过的v的邻接点开始，对图进行深度优先遍历。直到图中有路径相通的顶点都被访问过为止。\n\n事实上，这个步骤是一个递归步骤：访问了v之后，对v未访问的邻接点进行访问（此时该邻接点相当于之前的顶点v，再继续重复这个过程）\n\n&nbsp;\n\n深度优先搜索的实质就是穷举，按照一定的顺序和规则不断地去尝试，直到找到问题的解。\n\n对于一个问题的第一个状态叫做初始状态，最后要求的状态叫做目的状态。\n\n在搜索的过程中，对当前状态进行检测，如果当前状态满足目的状态，那么这个当前状态就是结果之一。\n\n深度优先搜索用一个数组存放产生的所有状态。\n\n（1） 把初始状态放入数组中，设为当前状态；\n\n（2） 扩展当前的状态，产生一个新的状态放入数组中，同时把新产生的状态设为当前状态；\n\n（3） 判断当前状态是否和前面的重复，如果重复则回到上一个状态，产生它的另一状态；\n\n（4） 判断当前状态是否为目标状态，如果是目标，则找到一个解答，结束算法。\n\n（5） 如果数组为空，说明无解。\n\n说了这么干话，来举几个例子：\n\n最经典的深搜例题：走迷宫：\n\nnyoj上的最少步数：\n\n[http://acm.nyist.net/JudgeOnline/problem.php?pid=58](http://acm.nyist.net/JudgeOnline/problem.php?pid=58)\n\n题目描述：\n\n这有一个迷宫，有0~8行和0~8列：\n\n1,1,1,1,1,1,1,1,1\n1,0,0,1,0,0,1,0,1\n1,0,0,1,1,0,0,0,1\n1,0,1,0,1,1,0,1,1\n1,0,0,0,0,1,0,0,1\n1,1,0,1,0,1,0,0,1\n1,1,0,1,0,1,0,0,1\n1,1,0,1,0,0,0,0,1\n1,1,1,1,1,1,1,1,1\n\n0表示道路，1表示墙。\n\n现在输入一个道路的坐标作为起点，再如输入一个道路的坐标作为终点，问最少走几步才能从起点到达终点？\n\n（注：一步是指从一坐标点走到其上下左右相邻坐标点，如：从（3，1）到（4,1）。）\n\n**输入**\n\n第一行输入一个整数n（0&lt;n&lt;=100），表示有n组测试数据;\n随后n行,每行有四个整数a,b,c,d（0&lt;=a,b,c,d&lt;=8）分别表示起点的行、列，终点的行、列。\n\n**输出**\n\n输出最少走几步。\n\n**样例输入**\n\n2\n\n3 1  5 7\n\n3 1  6 7\n\n**样例输出**\n\n12\n\n11\n\n分析：要从起点找到终点，有很多条路，那么可以用深搜的方法来找出所有的路。把每次走到终点的路长与最小长度minx进行比较，如果长度比minx还要小的话，就更新minx，minx的初始值是0x3fff；\n\n&nbsp;\n<pre>#include \nusing namespace std;\n#include //可以用到memset \n#include \n\nint map[9][9] = {\n 1,1,1,1,1,1,1,1,1,\n 1,0,0,1,0,0,1,0,1,\n 1,0,0,1,1,0,0,0,1,\n 1,0,1,0,1,1,0,1,1,\n 1,0,0,0,0,1,0,0,1,\n 1,1,0,1,0,1,0,0,1,\n 1,1,0,1,0,1,0,0,1,\n 1,1,0,1,0,0,0,0,1,\n 1,1,1,1,1,1,1,1,1\n} ;\n\nstruct point{//坐标的结构体声明 \n\tint x;\n\tint y; \n};\n\nint dir[4][2] = {-1,0,0,1,1,0,0,-1};\nvector v;\nint minx = 0x3fff;\n\nbool notRepeat(point x)\n{\n\tfor (int i = 0; i &lt; v.size(); ++i)\n\t{\n\t\tif (x.x==v[i].x&amp;&amp;x.y==v[i].y)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid dfs(point a, point b)\n{\n\tif (a.x == b.x &amp;&amp; a.y == b.y)\n\t{\n\t\t//结束搜索 \n\n\t\tif (v.size() &lt; minx)\n\t\t{\n\t\t\tminx = v.size();\n\t\t}\n\t\treturn ;\n\t}\n\telse\n\t{\n\t\tfor (int i = 0; i &lt; 4; ++i) { point t; t.x = a.x+dir[i][0]; t.y = a.y+dir[i][1]; if (notRepeat(t) &amp;&amp; !map[t.x][t.y] &amp;&amp; t.x&gt;=0 &amp;&amp; t.y&gt;=0 &amp;&amp; t.x&gt; n;\n\tpoint start;//起点 \n\tpoint finish;\n\n\twhile (n--)\n\t{\n\t\tcin &gt;&gt; start.x &gt;&gt; start.y &gt;&gt; finish.x &gt;&gt; finish.y;\n\n\t\tv.push_back(start);\n\t\tdfs(start, finish);\n\n\t\tv.pop_back();\n\t\tcout &lt;&lt; minx-1 &lt;&lt; endl;\n\t\tminx = 0x3fff;\n\t}\n\n\treturn 0;\n}\n\n</pre>\n这道题写完可以明显的发现，深搜有个很明显的特点：出来混都是要还的，所有用过的标记和坐标，在用完之后都需要还原。","slug":"e7-ae-97-e6-b3-95-e5-85-a5-e9-97-a8-e6-b7-b1-e6-90-9c-ef-bc-88depth-first-search-ef-bc-89-e5-b0-8f-e7-bb-93","published":1,"updated":"2017-12-09T17:06:50.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec1d001xiwtwk629fdhq","content":"<p>深度优先搜索实质上是图算法中的一种，其简要过程是：从顶点开始，对每个可以访问到的分支路径进行访问，直到不能继续往下深入为止，并且每个结点只访问一次</p>\n<p>简而言之：深搜（也叫回溯法）采用的是“一直往下走，走不通了就掉头，换一条路再往下走”。<a id=\"more\"></a></p>\n<p>深度优先搜索的简要步骤：</p>\n<p>1：访问顶点v</p>\n<p>2：从顶点v开始，对未访问过的v的邻接点开始，对图进行深度优先遍历。直到图中有路径相通的顶点都被访问过为止。</p>\n<p>事实上，这个步骤是一个递归步骤：访问了v之后，对v未访问的邻接点进行访问（此时该邻接点相当于之前的顶点v，再继续重复这个过程）</p>\n<p>&nbsp;</p>\n<p>深度优先搜索的实质就是穷举，按照一定的顺序和规则不断地去尝试，直到找到问题的解。</p>\n<p>对于一个问题的第一个状态叫做初始状态，最后要求的状态叫做目的状态。</p>\n<p>在搜索的过程中，对当前状态进行检测，如果当前状态满足目的状态，那么这个当前状态就是结果之一。</p>\n<p>深度优先搜索用一个数组存放产生的所有状态。</p>\n<p>（1） 把初始状态放入数组中，设为当前状态；</p>\n<p>（2） 扩展当前的状态，产生一个新的状态放入数组中，同时把新产生的状态设为当前状态；</p>\n<p>（3） 判断当前状态是否和前面的重复，如果重复则回到上一个状态，产生它的另一状态；</p>\n<p>（4） 判断当前状态是否为目标状态，如果是目标，则找到一个解答，结束算法。</p>\n<p>（5） 如果数组为空，说明无解。</p>\n<p>说了这么干话，来举几个例子：</p>\n<p>最经典的深搜例题：走迷宫：</p>\n<p>nyoj上的最少步数：</p>\n<p><a href=\"http://acm.nyist.net/JudgeOnline/problem.php?pid=58\" target=\"_blank\" rel=\"noopener\">http://acm.nyist.net/JudgeOnline/problem.php?pid=58</a></p>\n<p>题目描述：</p>\n<p>这有一个迷宫，有0~8行和0~8列：</p>\n<p>1,1,1,1,1,1,1,1,1<br>1,0,0,1,0,0,1,0,1<br>1,0,0,1,1,0,0,0,1<br>1,0,1,0,1,1,0,1,1<br>1,0,0,0,0,1,0,0,1<br>1,1,0,1,0,1,0,0,1<br>1,1,0,1,0,1,0,0,1<br>1,1,0,1,0,0,0,0,1<br>1,1,1,1,1,1,1,1,1</p>\n<p>0表示道路，1表示墙。</p>\n<p>现在输入一个道路的坐标作为起点，再如输入一个道路的坐标作为终点，问最少走几步才能从起点到达终点？</p>\n<p>（注：一步是指从一坐标点走到其上下左右相邻坐标点，如：从（3，1）到（4,1）。）</p>\n<p><strong>输入</strong></p>\n<p>第一行输入一个整数n（0&lt;n&lt;=100），表示有n组测试数据;<br>随后n行,每行有四个整数a,b,c,d（0&lt;=a,b,c,d&lt;=8）分别表示起点的行、列，终点的行、列。</p>\n<p><strong>输出</strong></p>\n<p>输出最少走几步。</p>\n<p><strong>样例输入</strong></p>\n<p>2</p>\n<p>3 1  5 7</p>\n<p>3 1  6 7</p>\n<p><strong>样例输出</strong></p>\n<p>12</p>\n<p>11</p>\n<p>分析：要从起点找到终点，有很多条路，那么可以用深搜的方法来找出所有的路。把每次走到终点的路长与最小长度minx进行比较，如果长度比minx还要小的话，就更新minx，minx的初始值是0x3fff；</p>\n<p>&nbsp;</p>\n<p><pre>#include<br>using namespace std;</pre></p>\n<p>#include //可以用到memset </p>\n<p>#include </p>\n<p>int map[9][9] = {<br> 1,1,1,1,1,1,1,1,1,<br> 1,0,0,1,0,0,1,0,1,<br> 1,0,0,1,1,0,0,0,1,<br> 1,0,1,0,1,1,0,1,1,<br> 1,0,0,0,0,1,0,0,1,<br> 1,1,0,1,0,1,0,0,1,<br> 1,1,0,1,0,1,0,0,1,<br> 1,1,0,1,0,0,0,0,1,<br> 1,1,1,1,1,1,1,1,1<br>} ;</p>\n<p>struct point{//坐标的结构体声明<br>    int x;<br>    int y;<br>};</p>\n<p>int dir[4][2] = {-1,0,0,1,1,0,0,-1};<br>vector v;<br>int minx = 0x3fff;</p>\n<p>bool notRepeat(point x)<br>{<br>    for (int i = 0; i &lt; v.size(); ++i)<br>    {<br>        if (x.x==v[i].x&amp;&amp;x.y==v[i].y)<br>        {<br>            return false;<br>        }<br>    }<br>    return true;<br>}</p>\n<p>void dfs(point a, point b)<br>{<br>    if (a.x == b.x &amp;&amp; a.y == b.y)<br>    {<br>        //结束搜索 </p>\n<pre><code>    if (v.size() &amp;lt; minx)\n    {\n        minx = v.size();\n    }\n    return ;\n}\nelse\n{\n    for (int i = 0; i &amp;lt; 4; ++i) { point t; t.x = a.x+dir[i][0]; t.y = a.y+dir[i][1]; if (notRepeat(t) &amp;amp;&amp;amp; !map[t.x][t.y] &amp;amp;&amp;amp; t.x&amp;gt;=0 &amp;amp;&amp;amp; t.y&amp;gt;=0 &amp;amp;&amp;amp; t.x&amp;gt; n;\npoint start;//起点 \npoint finish;\n\nwhile (n--)\n{\n    cin &amp;gt;&amp;gt; start.x &amp;gt;&amp;gt; start.y &amp;gt;&amp;gt; finish.x &amp;gt;&amp;gt; finish.y;\n\n    v.push_back(start);\n    dfs(start, finish);\n\n    v.pop_back();\n    cout &amp;lt;&amp;lt; minx-1 &amp;lt;&amp;lt; endl;\n    minx = 0x3fff;\n}\n\nreturn 0;\n</code></pre><p>}</p>\n<p><br>这道题写完可以明显的发现，深搜有个很明显的特点：出来混都是要还的，所有用过的标记和坐标，在用完之后都需要还原。</p>\n","site":{"data":{}},"excerpt":"<p>深度优先搜索实质上是图算法中的一种，其简要过程是：从顶点开始，对每个可以访问到的分支路径进行访问，直到不能继续往下深入为止，并且每个结点只访问一次</p>\n<p>简而言之：深搜（也叫回溯法）采用的是“一直往下走，走不通了就掉头，换一条路再往下走”。","more":"</p>\n<p>深度优先搜索的简要步骤：</p>\n<p>1：访问顶点v</p>\n<p>2：从顶点v开始，对未访问过的v的邻接点开始，对图进行深度优先遍历。直到图中有路径相通的顶点都被访问过为止。</p>\n<p>事实上，这个步骤是一个递归步骤：访问了v之后，对v未访问的邻接点进行访问（此时该邻接点相当于之前的顶点v，再继续重复这个过程）</p>\n<p>&nbsp;</p>\n<p>深度优先搜索的实质就是穷举，按照一定的顺序和规则不断地去尝试，直到找到问题的解。</p>\n<p>对于一个问题的第一个状态叫做初始状态，最后要求的状态叫做目的状态。</p>\n<p>在搜索的过程中，对当前状态进行检测，如果当前状态满足目的状态，那么这个当前状态就是结果之一。</p>\n<p>深度优先搜索用一个数组存放产生的所有状态。</p>\n<p>（1） 把初始状态放入数组中，设为当前状态；</p>\n<p>（2） 扩展当前的状态，产生一个新的状态放入数组中，同时把新产生的状态设为当前状态；</p>\n<p>（3） 判断当前状态是否和前面的重复，如果重复则回到上一个状态，产生它的另一状态；</p>\n<p>（4） 判断当前状态是否为目标状态，如果是目标，则找到一个解答，结束算法。</p>\n<p>（5） 如果数组为空，说明无解。</p>\n<p>说了这么干话，来举几个例子：</p>\n<p>最经典的深搜例题：走迷宫：</p>\n<p>nyoj上的最少步数：</p>\n<p><a href=\"http://acm.nyist.net/JudgeOnline/problem.php?pid=58\" target=\"_blank\" rel=\"noopener\">http://acm.nyist.net/JudgeOnline/problem.php?pid=58</a></p>\n<p>题目描述：</p>\n<p>这有一个迷宫，有0~8行和0~8列：</p>\n<p>1,1,1,1,1,1,1,1,1<br>1,0,0,1,0,0,1,0,1<br>1,0,0,1,1,0,0,0,1<br>1,0,1,0,1,1,0,1,1<br>1,0,0,0,0,1,0,0,1<br>1,1,0,1,0,1,0,0,1<br>1,1,0,1,0,1,0,0,1<br>1,1,0,1,0,0,0,0,1<br>1,1,1,1,1,1,1,1,1</p>\n<p>0表示道路，1表示墙。</p>\n<p>现在输入一个道路的坐标作为起点，再如输入一个道路的坐标作为终点，问最少走几步才能从起点到达终点？</p>\n<p>（注：一步是指从一坐标点走到其上下左右相邻坐标点，如：从（3，1）到（4,1）。）</p>\n<p><strong>输入</strong></p>\n<p>第一行输入一个整数n（0&lt;n&lt;=100），表示有n组测试数据;<br>随后n行,每行有四个整数a,b,c,d（0&lt;=a,b,c,d&lt;=8）分别表示起点的行、列，终点的行、列。</p>\n<p><strong>输出</strong></p>\n<p>输出最少走几步。</p>\n<p><strong>样例输入</strong></p>\n<p>2</p>\n<p>3 1  5 7</p>\n<p>3 1  6 7</p>\n<p><strong>样例输出</strong></p>\n<p>12</p>\n<p>11</p>\n<p>分析：要从起点找到终点，有很多条路，那么可以用深搜的方法来找出所有的路。把每次走到终点的路长与最小长度minx进行比较，如果长度比minx还要小的话，就更新minx，minx的初始值是0x3fff；</p>\n<p>&nbsp;</p>\n<p><pre>#include<br>using namespace std;</pre></p>\n<p>#include //可以用到memset </p>\n<p>#include </p>\n<p>int map[9][9] = {<br> 1,1,1,1,1,1,1,1,1,<br> 1,0,0,1,0,0,1,0,1,<br> 1,0,0,1,1,0,0,0,1,<br> 1,0,1,0,1,1,0,1,1,<br> 1,0,0,0,0,1,0,0,1,<br> 1,1,0,1,0,1,0,0,1,<br> 1,1,0,1,0,1,0,0,1,<br> 1,1,0,1,0,0,0,0,1,<br> 1,1,1,1,1,1,1,1,1<br>} ;</p>\n<p>struct point{//坐标的结构体声明<br>    int x;<br>    int y;<br>};</p>\n<p>int dir[4][2] = {-1,0,0,1,1,0,0,-1};<br>vector v;<br>int minx = 0x3fff;</p>\n<p>bool notRepeat(point x)<br>{<br>    for (int i = 0; i &lt; v.size(); ++i)<br>    {<br>        if (x.x==v[i].x&amp;&amp;x.y==v[i].y)<br>        {<br>            return false;<br>        }<br>    }<br>    return true;<br>}</p>\n<p>void dfs(point a, point b)<br>{<br>    if (a.x == b.x &amp;&amp; a.y == b.y)<br>    {<br>        //结束搜索 </p>\n<pre><code>    if (v.size() &amp;lt; minx)\n    {\n        minx = v.size();\n    }\n    return ;\n}\nelse\n{\n    for (int i = 0; i &amp;lt; 4; ++i) { point t; t.x = a.x+dir[i][0]; t.y = a.y+dir[i][1]; if (notRepeat(t) &amp;amp;&amp;amp; !map[t.x][t.y] &amp;amp;&amp;amp; t.x&amp;gt;=0 &amp;amp;&amp;amp; t.y&amp;gt;=0 &amp;amp;&amp;amp; t.x&amp;gt; n;\npoint start;//起点 \npoint finish;\n\nwhile (n--)\n{\n    cin &amp;gt;&amp;gt; start.x &amp;gt;&amp;gt; start.y &amp;gt;&amp;gt; finish.x &amp;gt;&amp;gt; finish.y;\n\n    v.push_back(start);\n    dfs(start, finish);\n\n    v.pop_back();\n    cout &amp;lt;&amp;lt; minx-1 &amp;lt;&amp;lt; endl;\n    minx = 0x3fff;\n}\n\nreturn 0;\n</code></pre><p>}</p>\n<p><br>这道题写完可以明显的发现，深搜有个很明显的特点：出来混都是要还的，所有用过的标记和坐标，在用完之后都需要还原。</p>"},{"title":"git笔记","id":"198","date":"2017-07-10T08:03:06.000Z","_content":"\n# git学习笔记 精华，摘录自：[http://www.liaoxuefeng.com](http://www.liaoxuefeng.com)\n\n## 创建仓库和提交\n\n初始化git仓库，用git init。会在文件夹中生成.git的文件，不要轻易动这个文件。在linux下，用ls -ah查看隐藏文件\n\n添加文件仓库的两个步骤：\n\n1.  将文件添加到仓库，git add &lt;file name&gt;\n2.  将添加的文件提交到仓库，git commit -m \"your comments\"\n<!--more-->\n\ngit status可以查看工作区的状态。如果是文件被修改过，可以用git diff查看修改了什么内容。确认无误后可以用以上两个步骤来将文件提交到仓库中。\n\n用git log查看历史记录，这个命令可以查看从最近到最远的历史提交日志。如果内容太多可以用git log --pretty=oneline来查看一行的内容\n\n&nbsp;\n\n## 退回版本\n\nHEAD指向的是当前版本，因此，git允许我们在版本的历史之间选择，用命令 git reset --hard commit_id; (commit_id通常是SHA1计算出来的一个非常大的数字，用十六进制表示）\n\n用git log可以查看提交历史，以便确定要退回到哪个版本\n\n用git reflog查看命令历史，以便确定去到哪个“未来”版本（实际上这个命令可以查看之前的所有操作记录）\n\n&nbsp;\n\n## 暂存区和工作区的理解\n\n工作区是在电脑中能够看到的目录，比如新建的learngit文件夹就是一个工作区\n版本库是工作区下面的一个隐藏目录.git，是Git的版本库\n版本库里面存了很多东西，其中最重要的就是stage（暂存区），还有Git为我们创建的第一个分支，master分支，以及指向\nmaster分支的指针HEAD\n\n之前的git add就是吧文件修改添加到暂存区\n然后用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支，因为我们创建git版本库时，Git自动为我们创建了唯一的master分支，所以现在git commit就是往master分支上提交更改。\n可以简单的理解为：用户需要提交的文件统统放在暂存区，然后一次性提交到暂存区的所有修改\n\n&nbsp;\n\n### 管理修改：\n\nGit管理的是修改而不是文件。每次修改，如果不add到暂存区，就不会被commit到分支\n\n### 撤销修改：\n\ngit checkout -- filename 命令可以丢弃工作区的修改，例如：git checkout -- readme.txt把readme.txt文件在工作区的修改全部撤销：\n一种readme.txt自修改后还没有放到暂存区中，现在撤销就会到和版本库一样的状态（git diff HEAD -- readme.txt可以比较工作区的readme.txt文件和版本库里的最新版本的区别）\n一种readme.txt已经添加到暂存区，又做了修改，现在撤回修改就回到添加到暂存区后的状态\n总之就是让这个文件回到最近一次git commit或者git add时的状态\n\ngit checkout -- file命令中--很重要，没有--，就变成了“切换到另一个分支”的命令。\n\n如果修改后提交到暂存区，用git reset HEAD filename可以把暂缓区的修改撤销，重新放回到工作区（git reset命令既可以退回版本，也可以把暂存区的修改退回到工作区）\n\n### 删除文件：\n\n在linux下用rm filename删除了文件，你有两个选择：\n一是确实要从版本库中删除该文件，就用git rm filename删除，并且git commit。\n一是删错了，因为版本库里面还有，所以可以很轻松的把误删的文件恢复到最新版本git checkout -- test.txt\n其实git checkout是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以一键还原\n\n&nbsp;\n\n## 添加远程库：\n\n通过ssh与github配对\n在本地的learngit仓库下运行命令：git remote add origin git@github.com:a1anpro/learngit.git\n（把账户名换成自己的账户名）\n添加后，远程库的名字就是origin。可以用git push -u origin master 命令把本地库的所有内容(master)都推送到远程库中。\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n从现在起，只要本地作了提交，就可以通过命令： git push origin master\n\n## \n\n## 从远程库克隆:\n\n在github上创建仓库gitskills\n在本地用git clone git@github.com:a1anpro/gitskils.git就可以将远程的库克隆到本地使用\nGit支持多种协议，包括https,但是通过ssh支持的原生的git协议速度最快\n\n&nbsp;\n\n## 创建与合并分支：\n\nmaster是一条主线，创建的新分支是master的延续，如果要合并的话，直接修改指针就ok（指针涉及：HEAD,master,dev...)\n创建分支：git checkout -b dev(相当于git branch dev 和 git checkout dev 创建分支和切换分支)\n用git branch 命令查看当前分支\n用git checkout \"branch\"可以切换分支\n将dev分支的工作成果合并到master分支上：\ngit merge dev 这条命令用于合并指定分支到当前分支。\n合并完成后，可以将dev分支删除：git branch -d dev\n#因为创建/合并/删除分支都非常快，所以Git鼓励你使用分支完成某个任务，合并后再删除分支，这和直接在master分支上工作是一样的，但是过程要安全的多\n\n## \n\n## 解决冲突：\n\n当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\n用git log --graph --pretty=oneline --abbrev-commit命令可以看到分支合并图。\n\n&nbsp;\n\n## 分支管理策略：\n\n直接用git merge dev合并分支，使用的是Fast forward模式，这种模式下，删除分支后，会丢掉分支信息\n如果要强制禁用Fast forward模式，Git就会在merge时生成一个commit，这样在分支历史上就可以看到分支信息\n\n关闭Fast forward模式：git merge --no-ff -m 'comments' dev\n这次要合并并创建一个新的commit，所以加上了-m参数\nGit分支十分强大，在团队开发中应该充分应用。\n\n合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。\n\n## bug分支：\n\n当接到一个修复代号为101的bug任务时，要创建另一个分支来修复它，但是当前正在dev进行工作还没有提交\n现在用git stash将当前的工作现场存储起来，等以后恢复现场后继续工作\n\n等到bug修复完成后，切换到dev分支，用git stash list来查看之前的工作现场\nGit把stash内容存在某个地方了，需要恢复一下：\n方法一：git stash apply恢复，这样恢复后，stash内容并不删除，需要用git stash drop来删除\n方法二：用git stash pop，恢复的同时把stash内容也删掉\n\n可以多次stash来保存现场，恢复的时候先用git stash list 查看，然后恢复指定的stash：\ngit stash apply stash@{0}\n\n&nbsp;\n\n&nbsp;","source":"_posts/git-e7-ac-94-e8-ae-b0.md","raw":"---\ntitle: git笔记\ntags:\n  - git\nid: 198\ncategories:\n  - git\ndate: 2017-07-10 16:03:06\n---\n\n# git学习笔记 精华，摘录自：[http://www.liaoxuefeng.com](http://www.liaoxuefeng.com)\n\n## 创建仓库和提交\n\n初始化git仓库，用git init。会在文件夹中生成.git的文件，不要轻易动这个文件。在linux下，用ls -ah查看隐藏文件\n\n添加文件仓库的两个步骤：\n\n1.  将文件添加到仓库，git add &lt;file name&gt;\n2.  将添加的文件提交到仓库，git commit -m \"your comments\"\n<!--more-->\n\ngit status可以查看工作区的状态。如果是文件被修改过，可以用git diff查看修改了什么内容。确认无误后可以用以上两个步骤来将文件提交到仓库中。\n\n用git log查看历史记录，这个命令可以查看从最近到最远的历史提交日志。如果内容太多可以用git log --pretty=oneline来查看一行的内容\n\n&nbsp;\n\n## 退回版本\n\nHEAD指向的是当前版本，因此，git允许我们在版本的历史之间选择，用命令 git reset --hard commit_id; (commit_id通常是SHA1计算出来的一个非常大的数字，用十六进制表示）\n\n用git log可以查看提交历史，以便确定要退回到哪个版本\n\n用git reflog查看命令历史，以便确定去到哪个“未来”版本（实际上这个命令可以查看之前的所有操作记录）\n\n&nbsp;\n\n## 暂存区和工作区的理解\n\n工作区是在电脑中能够看到的目录，比如新建的learngit文件夹就是一个工作区\n版本库是工作区下面的一个隐藏目录.git，是Git的版本库\n版本库里面存了很多东西，其中最重要的就是stage（暂存区），还有Git为我们创建的第一个分支，master分支，以及指向\nmaster分支的指针HEAD\n\n之前的git add就是吧文件修改添加到暂存区\n然后用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支，因为我们创建git版本库时，Git自动为我们创建了唯一的master分支，所以现在git commit就是往master分支上提交更改。\n可以简单的理解为：用户需要提交的文件统统放在暂存区，然后一次性提交到暂存区的所有修改\n\n&nbsp;\n\n### 管理修改：\n\nGit管理的是修改而不是文件。每次修改，如果不add到暂存区，就不会被commit到分支\n\n### 撤销修改：\n\ngit checkout -- filename 命令可以丢弃工作区的修改，例如：git checkout -- readme.txt把readme.txt文件在工作区的修改全部撤销：\n一种readme.txt自修改后还没有放到暂存区中，现在撤销就会到和版本库一样的状态（git diff HEAD -- readme.txt可以比较工作区的readme.txt文件和版本库里的最新版本的区别）\n一种readme.txt已经添加到暂存区，又做了修改，现在撤回修改就回到添加到暂存区后的状态\n总之就是让这个文件回到最近一次git commit或者git add时的状态\n\ngit checkout -- file命令中--很重要，没有--，就变成了“切换到另一个分支”的命令。\n\n如果修改后提交到暂存区，用git reset HEAD filename可以把暂缓区的修改撤销，重新放回到工作区（git reset命令既可以退回版本，也可以把暂存区的修改退回到工作区）\n\n### 删除文件：\n\n在linux下用rm filename删除了文件，你有两个选择：\n一是确实要从版本库中删除该文件，就用git rm filename删除，并且git commit。\n一是删错了，因为版本库里面还有，所以可以很轻松的把误删的文件恢复到最新版本git checkout -- test.txt\n其实git checkout是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以一键还原\n\n&nbsp;\n\n## 添加远程库：\n\n通过ssh与github配对\n在本地的learngit仓库下运行命令：git remote add origin git@github.com:a1anpro/learngit.git\n（把账户名换成自己的账户名）\n添加后，远程库的名字就是origin。可以用git push -u origin master 命令把本地库的所有内容(master)都推送到远程库中。\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n从现在起，只要本地作了提交，就可以通过命令： git push origin master\n\n## \n\n## 从远程库克隆:\n\n在github上创建仓库gitskills\n在本地用git clone git@github.com:a1anpro/gitskils.git就可以将远程的库克隆到本地使用\nGit支持多种协议，包括https,但是通过ssh支持的原生的git协议速度最快\n\n&nbsp;\n\n## 创建与合并分支：\n\nmaster是一条主线，创建的新分支是master的延续，如果要合并的话，直接修改指针就ok（指针涉及：HEAD,master,dev...)\n创建分支：git checkout -b dev(相当于git branch dev 和 git checkout dev 创建分支和切换分支)\n用git branch 命令查看当前分支\n用git checkout \"branch\"可以切换分支\n将dev分支的工作成果合并到master分支上：\ngit merge dev 这条命令用于合并指定分支到当前分支。\n合并完成后，可以将dev分支删除：git branch -d dev\n#因为创建/合并/删除分支都非常快，所以Git鼓励你使用分支完成某个任务，合并后再删除分支，这和直接在master分支上工作是一样的，但是过程要安全的多\n\n## \n\n## 解决冲突：\n\n当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\n用git log --graph --pretty=oneline --abbrev-commit命令可以看到分支合并图。\n\n&nbsp;\n\n## 分支管理策略：\n\n直接用git merge dev合并分支，使用的是Fast forward模式，这种模式下，删除分支后，会丢掉分支信息\n如果要强制禁用Fast forward模式，Git就会在merge时生成一个commit，这样在分支历史上就可以看到分支信息\n\n关闭Fast forward模式：git merge --no-ff -m 'comments' dev\n这次要合并并创建一个新的commit，所以加上了-m参数\nGit分支十分强大，在团队开发中应该充分应用。\n\n合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。\n\n## bug分支：\n\n当接到一个修复代号为101的bug任务时，要创建另一个分支来修复它，但是当前正在dev进行工作还没有提交\n现在用git stash将当前的工作现场存储起来，等以后恢复现场后继续工作\n\n等到bug修复完成后，切换到dev分支，用git stash list来查看之前的工作现场\nGit把stash内容存在某个地方了，需要恢复一下：\n方法一：git stash apply恢复，这样恢复后，stash内容并不删除，需要用git stash drop来删除\n方法二：用git stash pop，恢复的同时把stash内容也删掉\n\n可以多次stash来保存现场，恢复的时候先用git stash list 查看，然后恢复指定的stash：\ngit stash apply stash@{0}\n\n&nbsp;\n\n&nbsp;","slug":"git-e7-ac-94-e8-ae-b0","published":1,"updated":"2017-12-09T17:06:50.786Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec1d0021iwtwgqw8nyu6","content":"<h1 id=\"git学习笔记-精华，摘录自：http-www-liaoxuefeng-com\"><a href=\"#git学习笔记-精华，摘录自：http-www-liaoxuefeng-com\" class=\"headerlink\" title=\"git学习笔记 精华，摘录自：http://www.liaoxuefeng.com\"></a>git学习笔记 精华，摘录自：<a href=\"http://www.liaoxuefeng.com\" target=\"_blank\" rel=\"noopener\">http://www.liaoxuefeng.com</a></h1><h2 id=\"创建仓库和提交\"><a href=\"#创建仓库和提交\" class=\"headerlink\" title=\"创建仓库和提交\"></a>创建仓库和提交</h2><p>初始化git仓库，用git init。会在文件夹中生成.git的文件，不要轻易动这个文件。在linux下，用ls -ah查看隐藏文件</p>\n<p>添加文件仓库的两个步骤：</p>\n<ol>\n<li>将文件添加到仓库，git add &lt;file name&gt;</li>\n<li>将添加的文件提交到仓库，git commit -m “your comments”<a id=\"more\"></a>\n</li>\n</ol>\n<p>git status可以查看工作区的状态。如果是文件被修改过，可以用git diff查看修改了什么内容。确认无误后可以用以上两个步骤来将文件提交到仓库中。</p>\n<p>用git log查看历史记录，这个命令可以查看从最近到最远的历史提交日志。如果内容太多可以用git log –pretty=oneline来查看一行的内容</p>\n<p>&nbsp;</p>\n<h2 id=\"退回版本\"><a href=\"#退回版本\" class=\"headerlink\" title=\"退回版本\"></a>退回版本</h2><p>HEAD指向的是当前版本，因此，git允许我们在版本的历史之间选择，用命令 git reset –hard commit_id; (commit_id通常是SHA1计算出来的一个非常大的数字，用十六进制表示）</p>\n<p>用git log可以查看提交历史，以便确定要退回到哪个版本</p>\n<p>用git reflog查看命令历史，以便确定去到哪个“未来”版本（实际上这个命令可以查看之前的所有操作记录）</p>\n<p>&nbsp;</p>\n<h2 id=\"暂存区和工作区的理解\"><a href=\"#暂存区和工作区的理解\" class=\"headerlink\" title=\"暂存区和工作区的理解\"></a>暂存区和工作区的理解</h2><p>工作区是在电脑中能够看到的目录，比如新建的learngit文件夹就是一个工作区<br>版本库是工作区下面的一个隐藏目录.git，是Git的版本库<br>版本库里面存了很多东西，其中最重要的就是stage（暂存区），还有Git为我们创建的第一个分支，master分支，以及指向<br>master分支的指针HEAD</p>\n<p>之前的git add就是吧文件修改添加到暂存区<br>然后用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支，因为我们创建git版本库时，Git自动为我们创建了唯一的master分支，所以现在git commit就是往master分支上提交更改。<br>可以简单的理解为：用户需要提交的文件统统放在暂存区，然后一次性提交到暂存区的所有修改</p>\n<p>&nbsp;</p>\n<h3 id=\"管理修改：\"><a href=\"#管理修改：\" class=\"headerlink\" title=\"管理修改：\"></a>管理修改：</h3><p>Git管理的是修改而不是文件。每次修改，如果不add到暂存区，就不会被commit到分支</p>\n<h3 id=\"撤销修改：\"><a href=\"#撤销修改：\" class=\"headerlink\" title=\"撤销修改：\"></a>撤销修改：</h3><p>git checkout – filename 命令可以丢弃工作区的修改，例如：git checkout – readme.txt把readme.txt文件在工作区的修改全部撤销：<br>一种readme.txt自修改后还没有放到暂存区中，现在撤销就会到和版本库一样的状态（git diff HEAD – readme.txt可以比较工作区的readme.txt文件和版本库里的最新版本的区别）<br>一种readme.txt已经添加到暂存区，又做了修改，现在撤回修改就回到添加到暂存区后的状态<br>总之就是让这个文件回到最近一次git commit或者git add时的状态</p>\n<p>git checkout – file命令中–很重要，没有–，就变成了“切换到另一个分支”的命令。</p>\n<p>如果修改后提交到暂存区，用git reset HEAD filename可以把暂缓区的修改撤销，重新放回到工作区（git reset命令既可以退回版本，也可以把暂存区的修改退回到工作区）</p>\n<h3 id=\"删除文件：\"><a href=\"#删除文件：\" class=\"headerlink\" title=\"删除文件：\"></a>删除文件：</h3><p>在linux下用rm filename删除了文件，你有两个选择：<br>一是确实要从版本库中删除该文件，就用git rm filename删除，并且git commit。<br>一是删错了，因为版本库里面还有，所以可以很轻松的把误删的文件恢复到最新版本git checkout – test.txt<br>其实git checkout是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以一键还原</p>\n<p>&nbsp;</p>\n<h2 id=\"添加远程库：\"><a href=\"#添加远程库：\" class=\"headerlink\" title=\"添加远程库：\"></a>添加远程库：</h2><p>通过ssh与github配对<br>在本地的learngit仓库下运行命令：git remote add origin git@github.com:a1anpro/learngit.git<br>（把账户名换成自己的账户名）<br>添加后，远程库的名字就是origin。可以用git push -u origin master 命令把本地库的所有内容(master)都推送到远程库中。<br>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。<br>从现在起，只要本地作了提交，就可以通过命令： git push origin master</p>\n<p>## </p>\n<h2 id=\"从远程库克隆\"><a href=\"#从远程库克隆\" class=\"headerlink\" title=\"从远程库克隆:\"></a>从远程库克隆:</h2><p>在github上创建仓库gitskills<br>在本地用git clone git@github.com:a1anpro/gitskils.git就可以将远程的库克隆到本地使用<br>Git支持多种协议，包括https,但是通过ssh支持的原生的git协议速度最快</p>\n<p>&nbsp;</p>\n<h2 id=\"创建与合并分支：\"><a href=\"#创建与合并分支：\" class=\"headerlink\" title=\"创建与合并分支：\"></a>创建与合并分支：</h2><p>master是一条主线，创建的新分支是master的延续，如果要合并的话，直接修改指针就ok（指针涉及：HEAD,master,dev…)<br>创建分支：git checkout -b dev(相当于git branch dev 和 git checkout dev 创建分支和切换分支)<br>用git branch 命令查看当前分支<br>用git checkout “branch”可以切换分支<br>将dev分支的工作成果合并到master分支上：<br>git merge dev 这条命令用于合并指定分支到当前分支。<br>合并完成后，可以将dev分支删除：git branch -d dev</p>\n<p>#因为创建/合并/删除分支都非常快，所以Git鼓励你使用分支完成某个任务，合并后再删除分支，这和直接在master分支上工作是一样的，但是过程要安全的多</p>\n<p>## </p>\n<h2 id=\"解决冲突：\"><a href=\"#解决冲突：\" class=\"headerlink\" title=\"解决冲突：\"></a>解决冲突：</h2><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>用git log –graph –pretty=oneline –abbrev-commit命令可以看到分支合并图。</p>\n<p>&nbsp;</p>\n<h2 id=\"分支管理策略：\"><a href=\"#分支管理策略：\" class=\"headerlink\" title=\"分支管理策略：\"></a>分支管理策略：</h2><p>直接用git merge dev合并分支，使用的是Fast forward模式，这种模式下，删除分支后，会丢掉分支信息<br>如果要强制禁用Fast forward模式，Git就会在merge时生成一个commit，这样在分支历史上就可以看到分支信息</p>\n<p>关闭Fast forward模式：git merge –no-ff -m ‘comments’ dev<br>这次要合并并创建一个新的commit，所以加上了-m参数<br>Git分支十分强大，在团队开发中应该充分应用。</p>\n<p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>\n<h2 id=\"bug分支：\"><a href=\"#bug分支：\" class=\"headerlink\" title=\"bug分支：\"></a>bug分支：</h2><p>当接到一个修复代号为101的bug任务时，要创建另一个分支来修复它，但是当前正在dev进行工作还没有提交<br>现在用git stash将当前的工作现场存储起来，等以后恢复现场后继续工作</p>\n<p>等到bug修复完成后，切换到dev分支，用git stash list来查看之前的工作现场<br>Git把stash内容存在某个地方了，需要恢复一下：<br>方法一：git stash apply恢复，这样恢复后，stash内容并不删除，需要用git stash drop来删除<br>方法二：用git stash pop，恢复的同时把stash内容也删掉</p>\n<p>可以多次stash来保存现场，恢复的时候先用git stash list 查看，然后恢复指定的stash：<br>git stash apply stash@{0}</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"git学习笔记-精华，摘录自：http-www-liaoxuefeng-com\"><a href=\"#git学习笔记-精华，摘录自：http-www-liaoxuefeng-com\" class=\"headerlink\" title=\"git学习笔记 精华，摘录自：http://www.liaoxuefeng.com\"></a>git学习笔记 精华，摘录自：<a href=\"http://www.liaoxuefeng.com\" target=\"_blank\" rel=\"noopener\">http://www.liaoxuefeng.com</a></h1><h2 id=\"创建仓库和提交\"><a href=\"#创建仓库和提交\" class=\"headerlink\" title=\"创建仓库和提交\"></a>创建仓库和提交</h2><p>初始化git仓库，用git init。会在文件夹中生成.git的文件，不要轻易动这个文件。在linux下，用ls -ah查看隐藏文件</p>\n<p>添加文件仓库的两个步骤：</p>\n<ol>\n<li>将文件添加到仓库，git add &lt;file name&gt;</li>\n<li>将添加的文件提交到仓库，git commit -m “your comments”","more":"</li>\n</ol>\n<p>git status可以查看工作区的状态。如果是文件被修改过，可以用git diff查看修改了什么内容。确认无误后可以用以上两个步骤来将文件提交到仓库中。</p>\n<p>用git log查看历史记录，这个命令可以查看从最近到最远的历史提交日志。如果内容太多可以用git log –pretty=oneline来查看一行的内容</p>\n<p>&nbsp;</p>\n<h2 id=\"退回版本\"><a href=\"#退回版本\" class=\"headerlink\" title=\"退回版本\"></a>退回版本</h2><p>HEAD指向的是当前版本，因此，git允许我们在版本的历史之间选择，用命令 git reset –hard commit_id; (commit_id通常是SHA1计算出来的一个非常大的数字，用十六进制表示）</p>\n<p>用git log可以查看提交历史，以便确定要退回到哪个版本</p>\n<p>用git reflog查看命令历史，以便确定去到哪个“未来”版本（实际上这个命令可以查看之前的所有操作记录）</p>\n<p>&nbsp;</p>\n<h2 id=\"暂存区和工作区的理解\"><a href=\"#暂存区和工作区的理解\" class=\"headerlink\" title=\"暂存区和工作区的理解\"></a>暂存区和工作区的理解</h2><p>工作区是在电脑中能够看到的目录，比如新建的learngit文件夹就是一个工作区<br>版本库是工作区下面的一个隐藏目录.git，是Git的版本库<br>版本库里面存了很多东西，其中最重要的就是stage（暂存区），还有Git为我们创建的第一个分支，master分支，以及指向<br>master分支的指针HEAD</p>\n<p>之前的git add就是吧文件修改添加到暂存区<br>然后用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支，因为我们创建git版本库时，Git自动为我们创建了唯一的master分支，所以现在git commit就是往master分支上提交更改。<br>可以简单的理解为：用户需要提交的文件统统放在暂存区，然后一次性提交到暂存区的所有修改</p>\n<p>&nbsp;</p>\n<h3 id=\"管理修改：\"><a href=\"#管理修改：\" class=\"headerlink\" title=\"管理修改：\"></a>管理修改：</h3><p>Git管理的是修改而不是文件。每次修改，如果不add到暂存区，就不会被commit到分支</p>\n<h3 id=\"撤销修改：\"><a href=\"#撤销修改：\" class=\"headerlink\" title=\"撤销修改：\"></a>撤销修改：</h3><p>git checkout – filename 命令可以丢弃工作区的修改，例如：git checkout – readme.txt把readme.txt文件在工作区的修改全部撤销：<br>一种readme.txt自修改后还没有放到暂存区中，现在撤销就会到和版本库一样的状态（git diff HEAD – readme.txt可以比较工作区的readme.txt文件和版本库里的最新版本的区别）<br>一种readme.txt已经添加到暂存区，又做了修改，现在撤回修改就回到添加到暂存区后的状态<br>总之就是让这个文件回到最近一次git commit或者git add时的状态</p>\n<p>git checkout – file命令中–很重要，没有–，就变成了“切换到另一个分支”的命令。</p>\n<p>如果修改后提交到暂存区，用git reset HEAD filename可以把暂缓区的修改撤销，重新放回到工作区（git reset命令既可以退回版本，也可以把暂存区的修改退回到工作区）</p>\n<h3 id=\"删除文件：\"><a href=\"#删除文件：\" class=\"headerlink\" title=\"删除文件：\"></a>删除文件：</h3><p>在linux下用rm filename删除了文件，你有两个选择：<br>一是确实要从版本库中删除该文件，就用git rm filename删除，并且git commit。<br>一是删错了，因为版本库里面还有，所以可以很轻松的把误删的文件恢复到最新版本git checkout – test.txt<br>其实git checkout是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以一键还原</p>\n<p>&nbsp;</p>\n<h2 id=\"添加远程库：\"><a href=\"#添加远程库：\" class=\"headerlink\" title=\"添加远程库：\"></a>添加远程库：</h2><p>通过ssh与github配对<br>在本地的learngit仓库下运行命令：git remote add origin git@github.com:a1anpro/learngit.git<br>（把账户名换成自己的账户名）<br>添加后，远程库的名字就是origin。可以用git push -u origin master 命令把本地库的所有内容(master)都推送到远程库中。<br>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。<br>从现在起，只要本地作了提交，就可以通过命令： git push origin master</p>\n<p>## </p>\n<h2 id=\"从远程库克隆\"><a href=\"#从远程库克隆\" class=\"headerlink\" title=\"从远程库克隆:\"></a>从远程库克隆:</h2><p>在github上创建仓库gitskills<br>在本地用git clone git@github.com:a1anpro/gitskils.git就可以将远程的库克隆到本地使用<br>Git支持多种协议，包括https,但是通过ssh支持的原生的git协议速度最快</p>\n<p>&nbsp;</p>\n<h2 id=\"创建与合并分支：\"><a href=\"#创建与合并分支：\" class=\"headerlink\" title=\"创建与合并分支：\"></a>创建与合并分支：</h2><p>master是一条主线，创建的新分支是master的延续，如果要合并的话，直接修改指针就ok（指针涉及：HEAD,master,dev…)<br>创建分支：git checkout -b dev(相当于git branch dev 和 git checkout dev 创建分支和切换分支)<br>用git branch 命令查看当前分支<br>用git checkout “branch”可以切换分支<br>将dev分支的工作成果合并到master分支上：<br>git merge dev 这条命令用于合并指定分支到当前分支。<br>合并完成后，可以将dev分支删除：git branch -d dev</p>\n<p>#因为创建/合并/删除分支都非常快，所以Git鼓励你使用分支完成某个任务，合并后再删除分支，这和直接在master分支上工作是一样的，但是过程要安全的多</p>\n<p>## </p>\n<h2 id=\"解决冲突：\"><a href=\"#解决冲突：\" class=\"headerlink\" title=\"解决冲突：\"></a>解决冲突：</h2><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>用git log –graph –pretty=oneline –abbrev-commit命令可以看到分支合并图。</p>\n<p>&nbsp;</p>\n<h2 id=\"分支管理策略：\"><a href=\"#分支管理策略：\" class=\"headerlink\" title=\"分支管理策略：\"></a>分支管理策略：</h2><p>直接用git merge dev合并分支，使用的是Fast forward模式，这种模式下，删除分支后，会丢掉分支信息<br>如果要强制禁用Fast forward模式，Git就会在merge时生成一个commit，这样在分支历史上就可以看到分支信息</p>\n<p>关闭Fast forward模式：git merge –no-ff -m ‘comments’ dev<br>这次要合并并创建一个新的commit，所以加上了-m参数<br>Git分支十分强大，在团队开发中应该充分应用。</p>\n<p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>\n<h2 id=\"bug分支：\"><a href=\"#bug分支：\" class=\"headerlink\" title=\"bug分支：\"></a>bug分支：</h2><p>当接到一个修复代号为101的bug任务时，要创建另一个分支来修复它，但是当前正在dev进行工作还没有提交<br>现在用git stash将当前的工作现场存储起来，等以后恢复现场后继续工作</p>\n<p>等到bug修复完成后，切换到dev分支，用git stash list来查看之前的工作现场<br>Git把stash内容存在某个地方了，需要恢复一下：<br>方法一：git stash apply恢复，这样恢复后，stash内容并不删除，需要用git stash drop来删除<br>方法二：用git stash pop，恢复的同时把stash内容也删掉</p>\n<p>可以多次stash来保存现场，恢复的时候先用git stash list 查看，然后恢复指定的stash：<br>git stash apply stash@{0}</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>"},{"title":"维基百科六度分隔理论","id":"139","date":"2017-06-07T14:31:40.000Z","_content":"\n**六度分隔理论**（英文：**Six Degrees of Separation**），此理论认为世界上任何互不相识的两人，只需要很少的中间人就能够建立起联系。哈佛大学心理学教授斯坦利·米尔格拉姆于1967年根据这个概念做过一次连锁信实验，尝试证明平均只需要5个中间人就可以联系任何两个互不相识的美国人。\n\n这种现象，并不是说任何人与人之间的联系都必须要通过6个层次才会产生联系，而是表达了这样一个重要的概念：任何两位素不相识的人之间，通过一定的联系方式，总能够产生必然联系或关系。显然，随着联系方式和联系能力的不同，实现个人期望的机遇将产生明显的区别。<!--more-->\n\n不过，超过30年来这个理论所谓的人际连系网，仍然有所争议。\n\n&nbsp;\n\nFacebook 的团队为了宣扬 Facebook 周年纪念的朋友日，研究了目前在其上注册的 15.9 亿人资料，在2016年2月4号时于网站FACEBOOK research公布标题为Three and a half degrees of separation的研究结果，发现这个神奇数字的“网络直径”是 3.57，翻成白话文意味着每个人与其他人间隔为 3.57 人。如果仅考虑美国使用者的话，这个数字会降到平均 3.46 个人。\n\n根据追踪研究发现，这个“分离度”从 2011 年来有持续下降的趋势。2011年，来自美国康乃尔大学、意大利米兰大学的学者与脸书研究团队合作，计算了当时的 7.21 亿使用者资料，发现这个数字是 3.74。现在 Facebook 的人口成长将近 2 倍，这个数字却降低了一些。从研究定义上来看，要在海量资料上计算这个数字其实是一个巨大的挑战。Facebook 研究团队在这个整合、无法回推追踪的大数据上，用了不同学者所发明的一些统计技术与算法，去精确预测了这个距离。","source":"_posts/e7-bb-b4-e5-9f-ba-e7-99-be-e7-a7-91-e5-85-ad-e5-ba-a6-e5-88-86-e9-9a-94-e7-90-86-e8-ae-ba.md","raw":"---\ntitle: 维基百科六度分隔理论\ntags:\n  - 百科\nid: 139\ncategories:\n  - web学习整理\ndate: 2017-06-07 22:31:40\n---\n\n**六度分隔理论**（英文：**Six Degrees of Separation**），此理论认为世界上任何互不相识的两人，只需要很少的中间人就能够建立起联系。哈佛大学心理学教授斯坦利·米尔格拉姆于1967年根据这个概念做过一次连锁信实验，尝试证明平均只需要5个中间人就可以联系任何两个互不相识的美国人。\n\n这种现象，并不是说任何人与人之间的联系都必须要通过6个层次才会产生联系，而是表达了这样一个重要的概念：任何两位素不相识的人之间，通过一定的联系方式，总能够产生必然联系或关系。显然，随着联系方式和联系能力的不同，实现个人期望的机遇将产生明显的区别。<!--more-->\n\n不过，超过30年来这个理论所谓的人际连系网，仍然有所争议。\n\n&nbsp;\n\nFacebook 的团队为了宣扬 Facebook 周年纪念的朋友日，研究了目前在其上注册的 15.9 亿人资料，在2016年2月4号时于网站FACEBOOK research公布标题为Three and a half degrees of separation的研究结果，发现这个神奇数字的“网络直径”是 3.57，翻成白话文意味着每个人与其他人间隔为 3.57 人。如果仅考虑美国使用者的话，这个数字会降到平均 3.46 个人。\n\n根据追踪研究发现，这个“分离度”从 2011 年来有持续下降的趋势。2011年，来自美国康乃尔大学、意大利米兰大学的学者与脸书研究团队合作，计算了当时的 7.21 亿使用者资料，发现这个数字是 3.74。现在 Facebook 的人口成长将近 2 倍，这个数字却降低了一些。从研究定义上来看，要在海量资料上计算这个数字其实是一个巨大的挑战。Facebook 研究团队在这个整合、无法回推追踪的大数据上，用了不同学者所发明的一些统计技术与算法，去精确预测了这个距离。","slug":"e7-bb-b4-e5-9f-ba-e7-99-be-e7-a7-91-e5-85-ad-e5-ba-a6-e5-88-86-e9-9a-94-e7-90-86-e8-ae-ba","published":1,"updated":"2017-12-09T17:06:50.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec1n0024iwtwaxq00s54","content":"<p><strong>六度分隔理论</strong>（英文：<strong>Six Degrees of Separation</strong>），此理论认为世界上任何互不相识的两人，只需要很少的中间人就能够建立起联系。哈佛大学心理学教授斯坦利·米尔格拉姆于1967年根据这个概念做过一次连锁信实验，尝试证明平均只需要5个中间人就可以联系任何两个互不相识的美国人。</p>\n<p>这种现象，并不是说任何人与人之间的联系都必须要通过6个层次才会产生联系，而是表达了这样一个重要的概念：任何两位素不相识的人之间，通过一定的联系方式，总能够产生必然联系或关系。显然，随着联系方式和联系能力的不同，实现个人期望的机遇将产生明显的区别。<a id=\"more\"></a></p>\n<p>不过，超过30年来这个理论所谓的人际连系网，仍然有所争议。</p>\n<p>&nbsp;</p>\n<p>Facebook 的团队为了宣扬 Facebook 周年纪念的朋友日，研究了目前在其上注册的 15.9 亿人资料，在2016年2月4号时于网站FACEBOOK research公布标题为Three and a half degrees of separation的研究结果，发现这个神奇数字的“网络直径”是 3.57，翻成白话文意味着每个人与其他人间隔为 3.57 人。如果仅考虑美国使用者的话，这个数字会降到平均 3.46 个人。</p>\n<p>根据追踪研究发现，这个“分离度”从 2011 年来有持续下降的趋势。2011年，来自美国康乃尔大学、意大利米兰大学的学者与脸书研究团队合作，计算了当时的 7.21 亿使用者资料，发现这个数字是 3.74。现在 Facebook 的人口成长将近 2 倍，这个数字却降低了一些。从研究定义上来看，要在海量资料上计算这个数字其实是一个巨大的挑战。Facebook 研究团队在这个整合、无法回推追踪的大数据上，用了不同学者所发明的一些统计技术与算法，去精确预测了这个距离。</p>\n","site":{"data":{}},"excerpt":"<p><strong>六度分隔理论</strong>（英文：<strong>Six Degrees of Separation</strong>），此理论认为世界上任何互不相识的两人，只需要很少的中间人就能够建立起联系。哈佛大学心理学教授斯坦利·米尔格拉姆于1967年根据这个概念做过一次连锁信实验，尝试证明平均只需要5个中间人就可以联系任何两个互不相识的美国人。</p>\n<p>这种现象，并不是说任何人与人之间的联系都必须要通过6个层次才会产生联系，而是表达了这样一个重要的概念：任何两位素不相识的人之间，通过一定的联系方式，总能够产生必然联系或关系。显然，随着联系方式和联系能力的不同，实现个人期望的机遇将产生明显的区别。","more":"</p>\n<p>不过，超过30年来这个理论所谓的人际连系网，仍然有所争议。</p>\n<p>&nbsp;</p>\n<p>Facebook 的团队为了宣扬 Facebook 周年纪念的朋友日，研究了目前在其上注册的 15.9 亿人资料，在2016年2月4号时于网站FACEBOOK research公布标题为Three and a half degrees of separation的研究结果，发现这个神奇数字的“网络直径”是 3.57，翻成白话文意味着每个人与其他人间隔为 3.57 人。如果仅考虑美国使用者的话，这个数字会降到平均 3.46 个人。</p>\n<p>根据追踪研究发现，这个“分离度”从 2011 年来有持续下降的趋势。2011年，来自美国康乃尔大学、意大利米兰大学的学者与脸书研究团队合作，计算了当时的 7.21 亿使用者资料，发现这个数字是 3.74。现在 Facebook 的人口成长将近 2 倍，这个数字却降低了一些。从研究定义上来看，要在海量资料上计算这个数字其实是一个巨大的挑战。Facebook 研究团队在这个整合、无法回推追踪的大数据上，用了不同学者所发明的一些统计技术与算法，去精确预测了这个距离。</p>"},{"title":"谷歌开源的TensorFlow Object Detection API的使用教程","id":"353","date":"2017-10-10T15:59:48.000Z","_content":"\n## 环境：Ubuntu16.04 / anaconda4.3 + Tensorflow1.3.0 + python3.5\n\n## 介绍：\n\nanaconda是什么：是用于科学计算的python发行版，提供了包管理和 环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。Anaconda利用工具/命令`conda`来进行package和environment的管理，并且已经包含了Python和相关的配套工具。\n\n这里先解释下conda、anaconda这些概念的差别。`conda`可以理解为一个工具，也是一个可执行命令，其核心功能是**包管理**与**环境管理**。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并可以快速切换。Anaconda则是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等等，所以也称为Python的一种发行版。\n\n[摘自：[anaconda使用总结](http://python.jobbole.com/86236/)]\n\n由于anaconda环境可以很好的管理不同的环境，以便我在做错试验后可以重新新建环境，我选择了它，并创建了一个名为tensorflow的环境，并在其中安装了这个api运行的工具。\n\n<!--more-->\n\n## 步骤：\n\n1：搭建环境\n\n安装好anaconda之后，我们开始搭建自己的环境：以下为我搭建的过程\n\n<span class=\"crayon-e\">conda </span><span class=\"crayon-v\">create</span> <span class=\"crayon-o\">--</span><span class=\"crayon-e\">name </span><span class=\"crayon-e\">tensorflow </span><span class=\"crayon-v\">python</span><span class=\"crayon-o\">=3.5 #指定了这个环境中安装的python是3.5版本</span>\n\nsource activate tensorflow #这一步是用来开启tensorflow这个环境，以便在这个环境中做实验\n\ndeactivate tensorflow #这一步是关闭这个环境\n\n（如果要删除这个环境：conda remove --name tensorflow --al）\n\n2：安装tensorflow以及依赖的环境\n\nconda install -c conda-forge tensorflow\n\n在tensorflow这个anaconda环境中用以上命令安装tensorflow（可以用conda search tensorflow来查看可以安装的版本，也可以去anaconda官网查看版本，分为cpu版本和gpu版本）\n\n安装完成后，进入python环境测试：import tensorflow as tf ，如果没有报错则安装成功，可以用tf.__version__来查看安装好的版本\n\n**安装 pillow/lxml/jupyter/matplotlib **\n\n3：下载tensorflow的模型，需要用git\n\ngit clone git@github.com:tensorflow/models.git\n\n4：编译下载的models，\n\n在这里我们需要下载一个protobuf的工具，可以用conda来下载\n\n然后进入下载的models目录找到object_detection所在的父目录，运行编译命令：protoc object_detection/protos/*.proto --python_out=.\n\n5：使用jupyter-notebook运行这个api\n\n进入object_detection文件夹中的object_detection_tutorial.ipynb，点击cell中的run all，可以逐步运行该python代码。（[*]表示正在运行该部分代码）\n\n如果运行过程中出错，请自行百度。\n\n&nbsp;","source":"_posts/e8-b0-b7-e6-ad-8c-e5-bc-80-e6-ba-90-e7-9a-84tensorflow-object-detection-api-e7-9a-84-e4-bd-bf-e7-94-a8.md","raw":"---\ntitle: 谷歌开源的TensorFlow Object Detection API的使用教程\ntags:\n  - python学习\n  - 机器学习\nid: 353\ncategories:\n  - python学习\n  - 机器学习\ndate: 2017-10-10 23:59:48\n---\n\n## 环境：Ubuntu16.04 / anaconda4.3 + Tensorflow1.3.0 + python3.5\n\n## 介绍：\n\nanaconda是什么：是用于科学计算的python发行版，提供了包管理和 环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。Anaconda利用工具/命令`conda`来进行package和environment的管理，并且已经包含了Python和相关的配套工具。\n\n这里先解释下conda、anaconda这些概念的差别。`conda`可以理解为一个工具，也是一个可执行命令，其核心功能是**包管理**与**环境管理**。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并可以快速切换。Anaconda则是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等等，所以也称为Python的一种发行版。\n\n[摘自：[anaconda使用总结](http://python.jobbole.com/86236/)]\n\n由于anaconda环境可以很好的管理不同的环境，以便我在做错试验后可以重新新建环境，我选择了它，并创建了一个名为tensorflow的环境，并在其中安装了这个api运行的工具。\n\n<!--more-->\n\n## 步骤：\n\n1：搭建环境\n\n安装好anaconda之后，我们开始搭建自己的环境：以下为我搭建的过程\n\n<span class=\"crayon-e\">conda </span><span class=\"crayon-v\">create</span> <span class=\"crayon-o\">--</span><span class=\"crayon-e\">name </span><span class=\"crayon-e\">tensorflow </span><span class=\"crayon-v\">python</span><span class=\"crayon-o\">=3.5 #指定了这个环境中安装的python是3.5版本</span>\n\nsource activate tensorflow #这一步是用来开启tensorflow这个环境，以便在这个环境中做实验\n\ndeactivate tensorflow #这一步是关闭这个环境\n\n（如果要删除这个环境：conda remove --name tensorflow --al）\n\n2：安装tensorflow以及依赖的环境\n\nconda install -c conda-forge tensorflow\n\n在tensorflow这个anaconda环境中用以上命令安装tensorflow（可以用conda search tensorflow来查看可以安装的版本，也可以去anaconda官网查看版本，分为cpu版本和gpu版本）\n\n安装完成后，进入python环境测试：import tensorflow as tf ，如果没有报错则安装成功，可以用tf.__version__来查看安装好的版本\n\n**安装 pillow/lxml/jupyter/matplotlib **\n\n3：下载tensorflow的模型，需要用git\n\ngit clone git@github.com:tensorflow/models.git\n\n4：编译下载的models，\n\n在这里我们需要下载一个protobuf的工具，可以用conda来下载\n\n然后进入下载的models目录找到object_detection所在的父目录，运行编译命令：protoc object_detection/protos/*.proto --python_out=.\n\n5：使用jupyter-notebook运行这个api\n\n进入object_detection文件夹中的object_detection_tutorial.ipynb，点击cell中的run all，可以逐步运行该python代码。（[*]表示正在运行该部分代码）\n\n如果运行过程中出错，请自行百度。\n\n&nbsp;","slug":"e8-b0-b7-e6-ad-8c-e5-bc-80-e6-ba-90-e7-9a-84tensorflow-object-detection-api-e7-9a-84-e4-bd-bf-e7-94-a8","published":1,"updated":"2017-12-09T17:06:50.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec1n0028iwtw6k16mknt","content":"<h2 id=\"环境：Ubuntu16-04-anaconda4-3-Tensorflow1-3-0-python3-5\"><a href=\"#环境：Ubuntu16-04-anaconda4-3-Tensorflow1-3-0-python3-5\" class=\"headerlink\" title=\"环境：Ubuntu16.04 / anaconda4.3 + Tensorflow1.3.0 + python3.5\"></a>环境：Ubuntu16.04 / anaconda4.3 + Tensorflow1.3.0 + python3.5</h2><h2 id=\"介绍：\"><a href=\"#介绍：\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h2><p>anaconda是什么：是用于科学计算的python发行版，提供了包管理和 环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。Anaconda利用工具/命令<code>conda</code>来进行package和environment的管理，并且已经包含了Python和相关的配套工具。</p>\n<p>这里先解释下conda、anaconda这些概念的差别。<code>conda</code>可以理解为一个工具，也是一个可执行命令，其核心功能是<strong>包管理</strong>与<strong>环境管理</strong>。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并可以快速切换。Anaconda则是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等等，所以也称为Python的一种发行版。</p>\n<p>[摘自：<a href=\"http://python.jobbole.com/86236/\" target=\"_blank\" rel=\"noopener\">anaconda使用总结</a>]</p>\n<p>由于anaconda环境可以很好的管理不同的环境，以便我在做错试验后可以重新新建环境，我选择了它，并创建了一个名为tensorflow的环境，并在其中安装了这个api运行的工具。</p>\n<a id=\"more\"></a>\n<h2 id=\"步骤：\"><a href=\"#步骤：\" class=\"headerlink\" title=\"步骤：\"></a>步骤：</h2><p>1：搭建环境</p>\n<p>安装好anaconda之后，我们开始搭建自己的环境：以下为我搭建的过程</p>\n<p><span class=\"crayon-e\">conda </span><span class=\"crayon-v\">create</span> <span class=\"crayon-o\">–</span><span class=\"crayon-e\">name </span><span class=\"crayon-e\">tensorflow </span><span class=\"crayon-v\">python</span><span class=\"crayon-o\">=3.5 #指定了这个环境中安装的python是3.5版本</span></p>\n<p>source activate tensorflow #这一步是用来开启tensorflow这个环境，以便在这个环境中做实验</p>\n<p>deactivate tensorflow #这一步是关闭这个环境</p>\n<p>（如果要删除这个环境：conda remove –name tensorflow –al）</p>\n<p>2：安装tensorflow以及依赖的环境</p>\n<p>conda install -c conda-forge tensorflow</p>\n<p>在tensorflow这个anaconda环境中用以上命令安装tensorflow（可以用conda search tensorflow来查看可以安装的版本，也可以去anaconda官网查看版本，分为cpu版本和gpu版本）</p>\n<p>安装完成后，进入python环境测试：import tensorflow as tf ，如果没有报错则安装成功，可以用tf.<strong>version</strong>来查看安装好的版本</p>\n<p><strong>安装 pillow/lxml/jupyter/matplotlib </strong></p>\n<p>3：下载tensorflow的模型，需要用git</p>\n<p>git clone git@github.com:tensorflow/models.git</p>\n<p>4：编译下载的models，</p>\n<p>在这里我们需要下载一个protobuf的工具，可以用conda来下载</p>\n<p>然后进入下载的models目录找到object_detection所在的父目录，运行编译命令：protoc object_detection/protos/*.proto –python_out=.</p>\n<p>5：使用jupyter-notebook运行这个api</p>\n<p>进入object_detection文件夹中的object_detection_tutorial.ipynb，点击cell中的run all，可以逐步运行该python代码。（[*]表示正在运行该部分代码）</p>\n<p>如果运行过程中出错，请自行百度。</p>\n<p>&nbsp;</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"环境：Ubuntu16-04-anaconda4-3-Tensorflow1-3-0-python3-5\"><a href=\"#环境：Ubuntu16-04-anaconda4-3-Tensorflow1-3-0-python3-5\" class=\"headerlink\" title=\"环境：Ubuntu16.04 / anaconda4.3 + Tensorflow1.3.0 + python3.5\"></a>环境：Ubuntu16.04 / anaconda4.3 + Tensorflow1.3.0 + python3.5</h2><h2 id=\"介绍：\"><a href=\"#介绍：\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h2><p>anaconda是什么：是用于科学计算的python发行版，提供了包管理和 环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。Anaconda利用工具/命令<code>conda</code>来进行package和environment的管理，并且已经包含了Python和相关的配套工具。</p>\n<p>这里先解释下conda、anaconda这些概念的差别。<code>conda</code>可以理解为一个工具，也是一个可执行命令，其核心功能是<strong>包管理</strong>与<strong>环境管理</strong>。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并可以快速切换。Anaconda则是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等等，所以也称为Python的一种发行版。</p>\n<p>[摘自：<a href=\"http://python.jobbole.com/86236/\" target=\"_blank\" rel=\"noopener\">anaconda使用总结</a>]</p>\n<p>由于anaconda环境可以很好的管理不同的环境，以便我在做错试验后可以重新新建环境，我选择了它，并创建了一个名为tensorflow的环境，并在其中安装了这个api运行的工具。</p>","more":"<h2 id=\"步骤：\"><a href=\"#步骤：\" class=\"headerlink\" title=\"步骤：\"></a>步骤：</h2><p>1：搭建环境</p>\n<p>安装好anaconda之后，我们开始搭建自己的环境：以下为我搭建的过程</p>\n<p><span class=\"crayon-e\">conda </span><span class=\"crayon-v\">create</span> <span class=\"crayon-o\">–</span><span class=\"crayon-e\">name </span><span class=\"crayon-e\">tensorflow </span><span class=\"crayon-v\">python</span><span class=\"crayon-o\">=3.5 #指定了这个环境中安装的python是3.5版本</span></p>\n<p>source activate tensorflow #这一步是用来开启tensorflow这个环境，以便在这个环境中做实验</p>\n<p>deactivate tensorflow #这一步是关闭这个环境</p>\n<p>（如果要删除这个环境：conda remove –name tensorflow –al）</p>\n<p>2：安装tensorflow以及依赖的环境</p>\n<p>conda install -c conda-forge tensorflow</p>\n<p>在tensorflow这个anaconda环境中用以上命令安装tensorflow（可以用conda search tensorflow来查看可以安装的版本，也可以去anaconda官网查看版本，分为cpu版本和gpu版本）</p>\n<p>安装完成后，进入python环境测试：import tensorflow as tf ，如果没有报错则安装成功，可以用tf.<strong>version</strong>来查看安装好的版本</p>\n<p><strong>安装 pillow/lxml/jupyter/matplotlib </strong></p>\n<p>3：下载tensorflow的模型，需要用git</p>\n<p>git clone git@github.com:tensorflow/models.git</p>\n<p>4：编译下载的models，</p>\n<p>在这里我们需要下载一个protobuf的工具，可以用conda来下载</p>\n<p>然后进入下载的models目录找到object_detection所在的父目录，运行编译命令：protoc object_detection/protos/*.proto –python_out=.</p>\n<p>5：使用jupyter-notebook运行这个api</p>\n<p>进入object_detection文件夹中的object_detection_tutorial.ipynb，点击cell中的run all，可以逐步运行该python代码。（[*]表示正在运行该部分代码）</p>\n<p>如果运行过程中出错，请自行百度。</p>\n<p>&nbsp;</p>"},{"title":"我们所谓的奢望和欲望都是信仰","id":"121","date":"2017-05-09T00:01:22.000Z","_content":"\n这两天看完了王小波的《黄金时代》，里面有一段特别经典的话:(事实上特别经典的话有很多句-王二注，哈哈)\n\n那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。<!--more-->\n\n人的一生不能停止奢望，奢望也就是欲望，也算是信仰。我对信仰的理解就是：某个存在脑子里的想法，这个想法是我们能有快乐生活的一个希翼。\n\n所以有奢望、有欲望是好的，不管是物质上的欲望还是精神上的欲望。","source":"_posts/gold ages.md","raw":"---\ntitle: 我们所谓的奢望和欲望都是信仰\ntags:\n  - 生活记录\n  - 瞎想\nid: 121\ncategories:\n  - python学习\ndate: 2017-05-09 08:01:22\n---\n\n这两天看完了王小波的《黄金时代》，里面有一段特别经典的话:(事实上特别经典的话有很多句-王二注，哈哈)\n\n那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。<!--more-->\n\n人的一生不能停止奢望，奢望也就是欲望，也算是信仰。我对信仰的理解就是：某个存在脑子里的想法，这个想法是我们能有快乐生活的一个希翼。\n\n所以有奢望、有欲望是好的，不管是物质上的欲望还是精神上的欲望。","slug":"gold ages","published":1,"updated":"2017-12-09T17:06:50.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec1n002biwtwpgzfkmop","content":"<p>这两天看完了王小波的《黄金时代》，里面有一段特别经典的话:(事实上特别经典的话有很多句-王二注，哈哈)</p>\n<p>那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。<a id=\"more\"></a></p>\n<p>人的一生不能停止奢望，奢望也就是欲望，也算是信仰。我对信仰的理解就是：某个存在脑子里的想法，这个想法是我们能有快乐生活的一个希翼。</p>\n<p>所以有奢望、有欲望是好的，不管是物质上的欲望还是精神上的欲望。</p>\n","site":{"data":{}},"excerpt":"<p>这两天看完了王小波的《黄金时代》，里面有一段特别经典的话:(事实上特别经典的话有很多句-王二注，哈哈)</p>\n<p>那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。","more":"</p>\n<p>人的一生不能停止奢望，奢望也就是欲望，也算是信仰。我对信仰的理解就是：某个存在脑子里的想法，这个想法是我们能有快乐生活的一个希翼。</p>\n<p>所以有奢望、有欲望是好的，不管是物质上的欲望还是精神上的欲望。</p>"},{"title":"mysql数据库修改密码和忘记密码如何登陆","id":"375","date":"2017-11-02T09:31:20.000Z","_content":"\n在做课程设计的时候，用到了数据库，在修改mysql登陆密码后，忘了刷新权限，导致了登陆不上去。本文介绍如何修改mysql数据库密码，以及忘记密码如何登陆。\n\n1：如何修改mysql数据库密码：\n\n登陆mysql : mysql -u root -p\n\n选用mysql数据库：use mysql;<!--more-->\n\n更改密码：update user set password=password('123456') where user='root' ;\n\n更改密码之后，需要刷新权限，否则登陆不了：flush privileges;\n\n&nbsp;\n\n2：如何忘记密码，如何登陆mysql：\n\n首先，需要关闭MySQL Server服务。在“运行”窗口，输入“services.msc”，进入“服务”窗口。\n\n在服务窗口，可以找到“MySQL”，选定，将其“停止”即可。这样，MySQL Server服务就停止了。\n\n找到mysql client的安装路径，笔者的安装路径是：C:\\Program Files (x86)\\MySQL\\MySQL Server 5.5\n\n知道安装路径是为了访问.ini文件，该文件记录了MySQL的配置信息。\n\n需要注意的是，不同版本的.ini文件的名称不同，在MySQL 5.5时，它是my.ini。而在MySQL 5.6则是my-default.ini\n\n接着，打开命令行窗口，输入如下的命令：**mysqld --defaults-file=\"C:\\Program Files (x86)\\MySQL\\MySQL Server 5.5\\my.ini\" --console --skip-grant-tables**\n\n需要说明的是，此时该窗口不可再写入。这也是检验命令是否正确执行的一个标准。\n\n另外打开一个命令行窗口，输入命令：**mysql -u root -p**，回车即可进入mysql命令行界面。\n\n如此，就已经可以免密登陆mysql了，再用步骤1中的修改密码的方法修改密码，并记住：_**<span style=\"color: #ff0000;\">一定要刷新权限</span>**_。\n\n&nbsp;","source":"_posts/how to login when forget mysql passwd.md","raw":"---\ntitle: mysql数据库修改密码和忘记密码如何登陆\nid: 375\ncategories:\n  - 工具们\ndate: 2017-11-02 17:31:20\ntags:\n---\n\n在做课程设计的时候，用到了数据库，在修改mysql登陆密码后，忘了刷新权限，导致了登陆不上去。本文介绍如何修改mysql数据库密码，以及忘记密码如何登陆。\n\n1：如何修改mysql数据库密码：\n\n登陆mysql : mysql -u root -p\n\n选用mysql数据库：use mysql;<!--more-->\n\n更改密码：update user set password=password('123456') where user='root' ;\n\n更改密码之后，需要刷新权限，否则登陆不了：flush privileges;\n\n&nbsp;\n\n2：如何忘记密码，如何登陆mysql：\n\n首先，需要关闭MySQL Server服务。在“运行”窗口，输入“services.msc”，进入“服务”窗口。\n\n在服务窗口，可以找到“MySQL”，选定，将其“停止”即可。这样，MySQL Server服务就停止了。\n\n找到mysql client的安装路径，笔者的安装路径是：C:\\Program Files (x86)\\MySQL\\MySQL Server 5.5\n\n知道安装路径是为了访问.ini文件，该文件记录了MySQL的配置信息。\n\n需要注意的是，不同版本的.ini文件的名称不同，在MySQL 5.5时，它是my.ini。而在MySQL 5.6则是my-default.ini\n\n接着，打开命令行窗口，输入如下的命令：**mysqld --defaults-file=\"C:\\Program Files (x86)\\MySQL\\MySQL Server 5.5\\my.ini\" --console --skip-grant-tables**\n\n需要说明的是，此时该窗口不可再写入。这也是检验命令是否正确执行的一个标准。\n\n另外打开一个命令行窗口，输入命令：**mysql -u root -p**，回车即可进入mysql命令行界面。\n\n如此，就已经可以免密登陆mysql了，再用步骤1中的修改密码的方法修改密码，并记住：_**<span style=\"color: #ff0000;\">一定要刷新权限</span>**_。\n\n&nbsp;","slug":"how to login when forget mysql passwd","published":1,"updated":"2017-12-09T17:06:50.798Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec1x002giwtwc2x6uyb1","content":"<p>在做课程设计的时候，用到了数据库，在修改mysql登陆密码后，忘了刷新权限，导致了登陆不上去。本文介绍如何修改mysql数据库密码，以及忘记密码如何登陆。</p>\n<p>1：如何修改mysql数据库密码：</p>\n<p>登陆mysql : mysql -u root -p</p>\n<p>选用mysql数据库：use mysql;<a id=\"more\"></a></p>\n<p>更改密码：update user set password=password(‘123456’) where user=’root’ ;</p>\n<p>更改密码之后，需要刷新权限，否则登陆不了：flush privileges;</p>\n<p>&nbsp;</p>\n<p>2：如何忘记密码，如何登陆mysql：</p>\n<p>首先，需要关闭MySQL Server服务。在“运行”窗口，输入“services.msc”，进入“服务”窗口。</p>\n<p>在服务窗口，可以找到“MySQL”，选定，将其“停止”即可。这样，MySQL Server服务就停止了。</p>\n<p>找到mysql client的安装路径，笔者的安装路径是：C:\\Program Files (x86)\\MySQL\\MySQL Server 5.5</p>\n<p>知道安装路径是为了访问.ini文件，该文件记录了MySQL的配置信息。</p>\n<p>需要注意的是，不同版本的.ini文件的名称不同，在MySQL 5.5时，它是my.ini。而在MySQL 5.6则是my-default.ini</p>\n<p>接着，打开命令行窗口，输入如下的命令：<strong>mysqld –defaults-file=”C:\\Program Files (x86)\\MySQL\\MySQL Server 5.5\\my.ini” –console –skip-grant-tables</strong></p>\n<p>需要说明的是，此时该窗口不可再写入。这也是检验命令是否正确执行的一个标准。</p>\n<p>另外打开一个命令行窗口，输入命令：<strong>mysql -u root -p</strong>，回车即可进入mysql命令行界面。</p>\n<p>如此，就已经可以免密登陆mysql了，再用步骤1中的修改密码的方法修改密码，并记住：<em><strong><span style=\"color: #ff0000;\">一定要刷新权限</span></strong></em>。</p>\n<p>&nbsp;</p>\n","site":{"data":{}},"excerpt":"<p>在做课程设计的时候，用到了数据库，在修改mysql登陆密码后，忘了刷新权限，导致了登陆不上去。本文介绍如何修改mysql数据库密码，以及忘记密码如何登陆。</p>\n<p>1：如何修改mysql数据库密码：</p>\n<p>登陆mysql : mysql -u root -p</p>\n<p>选用mysql数据库：use mysql;","more":"</p>\n<p>更改密码：update user set password=password(‘123456’) where user=’root’ ;</p>\n<p>更改密码之后，需要刷新权限，否则登陆不了：flush privileges;</p>\n<p>&nbsp;</p>\n<p>2：如何忘记密码，如何登陆mysql：</p>\n<p>首先，需要关闭MySQL Server服务。在“运行”窗口，输入“services.msc”，进入“服务”窗口。</p>\n<p>在服务窗口，可以找到“MySQL”，选定，将其“停止”即可。这样，MySQL Server服务就停止了。</p>\n<p>找到mysql client的安装路径，笔者的安装路径是：C:\\Program Files (x86)\\MySQL\\MySQL Server 5.5</p>\n<p>知道安装路径是为了访问.ini文件，该文件记录了MySQL的配置信息。</p>\n<p>需要注意的是，不同版本的.ini文件的名称不同，在MySQL 5.5时，它是my.ini。而在MySQL 5.6则是my-default.ini</p>\n<p>接着，打开命令行窗口，输入如下的命令：<strong>mysqld –defaults-file=”C:\\Program Files (x86)\\MySQL\\MySQL Server 5.5\\my.ini” –console –skip-grant-tables</strong></p>\n<p>需要说明的是，此时该窗口不可再写入。这也是检验命令是否正确执行的一个标准。</p>\n<p>另外打开一个命令行窗口，输入命令：<strong>mysql -u root -p</strong>，回车即可进入mysql命令行界面。</p>\n<p>如此，就已经可以免密登陆mysql了，再用步骤1中的修改密码的方法修改密码，并记住：<em><strong><span style=\"color: #ff0000;\">一定要刷新权限</span></strong></em>。</p>\n<p>&nbsp;</p>"},{"title":"[蓝桥杯B组C++/C]第二题：等差素数列","id":"83","date":"2017-04-10T14:56:58.000Z","_content":"\n##### 标题：等差素数列 2,3,5,7,11,13,....是素数序列。 类似：7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。 上边的数列公差为30，长度为6。 2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。 这是数论领域一项惊人的成果！ 有这一理论为基础，请你借助手中的计算机，满怀信心地搜索： 长度为10的等差素数列，其公差最小值是多少？ 注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。\n\n<!--more-->\n\n<span style=\"color: #008000;\">解题思路：</span>\n\n<span style=\"color: #008000;\">用筛法求素数，not_prime[i]数组标记了第i个数是不是素数</span>\n\n<span style=\"color: #008000;\">从第一个素数2，长度为1开始穷举：</span>\n\n<span style=\"color: #008000;\">起始素数2，长度1...2...3....</span>\n\n<span style=\"color: #008000;\">起始素数3，长度1...2...3....</span>\n\n<span style=\"color: #008000;\">起始素数5，长度1...2...3....</span>\n\n<span style=\"color: #008000;\">...</span>\n\n<span style=\"color: #008000;\">起始素数i，长度1...2...3....</span>\n\n<span style=\"color: #008000;\">如果满足10个等差素数，就输出公差d，结束穷举</span>\n\n<pre>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nconst int maxn = 10000;\n\nbool not_prime[maxn];\n\nvoid f()\n{\n\tmemset(not_prime,0,sizeof(not_prime));\n\tnot_prime[0] = not_prime[1] = 1;\n\n\tfor (int i = 2; i &lt; maxn; ++i)\n\t{\n\t\tif (!not_prime[i])\n\t\t{\n\t\t\tfor (int j = i * 2; j &lt; maxn; j += i)\n\t\t\t{\n\t\t\t\tnot_prime[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tf();\n\t//for (int i= 2; i &lt; 100; ++i) if (!not_prime[i]) cout &lt;&lt; i &lt;&lt; \" \";\n\n\tint find = 0;\n\tfor (int i = 2;!find &amp;&amp; i &lt; maxn; ++i)\n\t{\n\t\t//从2开始作为开头\n\t\tfor (int d = 1; &amp;find &amp;&amp; d &lt; 1000; ++d)\n\t\t{\n\t\t\tint len = 0;\n\t\t\tint temp = i;\n\t\t\twhile (!not_prime[temp])\n\t\t\t{\n\t\t\t\t++len;\n\t\t\t\ttemp = temp + d;\n\t\t\t\tif (len == 10)\n\t\t\t\t{\n\t\t\t\t\tcout &lt;&lt; \"d:\" &lt;&lt; d&lt;&lt;endl;\n\t\t\t\t\tfind = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n\n\treturn 0;\n } \n</pre>","source":"_posts/lanqiao B2.md","raw":"---\ntitle: '[蓝桥杯B组C++/C]第二题：等差素数列'\ntags:\n  - 算法\n  - 算法学习\nid: 83\ncategories:\n  - web学习整理\ndate: 2017-04-10 22:56:58\n---\n\n##### 标题：等差素数列 2,3,5,7,11,13,....是素数序列。 类似：7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。 上边的数列公差为30，长度为6。 2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。 这是数论领域一项惊人的成果！ 有这一理论为基础，请你借助手中的计算机，满怀信心地搜索： 长度为10的等差素数列，其公差最小值是多少？ 注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。\n\n<!--more-->\n\n<span style=\"color: #008000;\">解题思路：</span>\n\n<span style=\"color: #008000;\">用筛法求素数，not_prime[i]数组标记了第i个数是不是素数</span>\n\n<span style=\"color: #008000;\">从第一个素数2，长度为1开始穷举：</span>\n\n<span style=\"color: #008000;\">起始素数2，长度1...2...3....</span>\n\n<span style=\"color: #008000;\">起始素数3，长度1...2...3....</span>\n\n<span style=\"color: #008000;\">起始素数5，长度1...2...3....</span>\n\n<span style=\"color: #008000;\">...</span>\n\n<span style=\"color: #008000;\">起始素数i，长度1...2...3....</span>\n\n<span style=\"color: #008000;\">如果满足10个等差素数，就输出公差d，结束穷举</span>\n\n<pre>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nconst int maxn = 10000;\n\nbool not_prime[maxn];\n\nvoid f()\n{\n\tmemset(not_prime,0,sizeof(not_prime));\n\tnot_prime[0] = not_prime[1] = 1;\n\n\tfor (int i = 2; i &lt; maxn; ++i)\n\t{\n\t\tif (!not_prime[i])\n\t\t{\n\t\t\tfor (int j = i * 2; j &lt; maxn; j += i)\n\t\t\t{\n\t\t\t\tnot_prime[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tf();\n\t//for (int i= 2; i &lt; 100; ++i) if (!not_prime[i]) cout &lt;&lt; i &lt;&lt; \" \";\n\n\tint find = 0;\n\tfor (int i = 2;!find &amp;&amp; i &lt; maxn; ++i)\n\t{\n\t\t//从2开始作为开头\n\t\tfor (int d = 1; &amp;find &amp;&amp; d &lt; 1000; ++d)\n\t\t{\n\t\t\tint len = 0;\n\t\t\tint temp = i;\n\t\t\twhile (!not_prime[temp])\n\t\t\t{\n\t\t\t\t++len;\n\t\t\t\ttemp = temp + d;\n\t\t\t\tif (len == 10)\n\t\t\t\t{\n\t\t\t\t\tcout &lt;&lt; \"d:\" &lt;&lt; d&lt;&lt;endl;\n\t\t\t\t\tfind = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n\n\treturn 0;\n } \n</pre>","slug":"lanqiao B2","published":1,"updated":"2017-12-09T17:06:50.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec1x002jiwtwj30snu1g","content":"<h5 id=\"标题：等差素数列-2-3-5-7-11-13-…-是素数序列。-类似：7-37-67-97-127-157-这样完全由素数组成的等差数列，叫等差素数数列。-上边的数列公差为30，长度为6。-2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。-这是数论领域一项惊人的成果！-有这一理论为基础，请你借助手中的计算机，满怀信心地搜索：-长度为10的等差素数列，其公差最小值是多少？-注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。\"><a href=\"#标题：等差素数列-2-3-5-7-11-13-…-是素数序列。-类似：7-37-67-97-127-157-这样完全由素数组成的等差数列，叫等差素数数列。-上边的数列公差为30，长度为6。-2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。-这是数论领域一项惊人的成果！-有这一理论为基础，请你借助手中的计算机，满怀信心地搜索：-长度为10的等差素数列，其公差最小值是多少？-注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。\" class=\"headerlink\" title=\"标题：等差素数列 2,3,5,7,11,13,….是素数序列。 类似：7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。 上边的数列公差为30，长度为6。 2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。 这是数论领域一项惊人的成果！ 有这一理论为基础，请你借助手中的计算机，满怀信心地搜索： 长度为10的等差素数列，其公差最小值是多少？ 注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。\"></a>标题：等差素数列 2,3,5,7,11,13,….是素数序列。 类似：7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。 上边的数列公差为30，长度为6。 2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。 这是数论领域一项惊人的成果！ 有这一理论为基础，请你借助手中的计算机，满怀信心地搜索： 长度为10的等差素数列，其公差最小值是多少？ 注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。</h5><a id=\"more\"></a>\n<p><span style=\"color: #008000;\">解题思路：</span></p>\n<p><span style=\"color: #008000;\">用筛法求素数，not_prime[i]数组标记了第i个数是不是素数</span></p>\n<p><span style=\"color: #008000;\">从第一个素数2，长度为1开始穷举：</span></p>\n<p><span style=\"color: #008000;\">起始素数2，长度1…2…3….</span></p>\n<p><span style=\"color: #008000;\">起始素数3，长度1…2…3….</span></p>\n<p><span style=\"color: #008000;\">起始素数5，长度1…2…3….</span></p>\n<p><span style=\"color: #008000;\">…</span></p>\n<p><span style=\"color: #008000;\">起始素数i，长度1…2…3….</span></p>\n<p><span style=\"color: #008000;\">如果满足10个等差素数，就输出公差d，结束穷举</span></p>\n<pre>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nconst int maxn = 10000;\n\nbool not_prime[maxn];\n\nvoid f()\n{\n    memset(not_prime,0,sizeof(not_prime));\n    not_prime[0] = not_prime[1] = 1;\n\n    for (int i = 2; i &lt; maxn; ++i)\n    {\n        if (!not_prime[i])\n        {\n            for (int j = i * 2; j &lt; maxn; j += i)\n            {\n                not_prime[j] = 1;\n            }\n        }\n    }\n}\n\nint main()\n{\n    f();\n    //for (int i= 2; i &lt; 100; ++i) if (!not_prime[i]) cout &lt;&lt; i &lt;&lt; \" \";\n\n    int find = 0;\n    for (int i = 2;!find &amp;&amp; i &lt; maxn; ++i)\n    {\n        //从2开始作为开头\n        for (int d = 1; &amp;find &amp;&amp; d &lt; 1000; ++d)\n        {\n            int len = 0;\n            int temp = i;\n            while (!not_prime[temp])\n            {\n                ++len;\n                temp = temp + d;\n                if (len == 10)\n                {\n                    cout &lt;&lt; \"d:\" &lt;&lt; d&lt;&lt;endl;\n                    find = 1;\n                    break;\n                }\n            }\n        } \n    }\n\n    return 0;\n } \n</pre>","site":{"data":{}},"excerpt":"<h5 id=\"标题：等差素数列-2-3-5-7-11-13-…-是素数序列。-类似：7-37-67-97-127-157-这样完全由素数组成的等差数列，叫等差素数数列。-上边的数列公差为30，长度为6。-2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。-这是数论领域一项惊人的成果！-有这一理论为基础，请你借助手中的计算机，满怀信心地搜索：-长度为10的等差素数列，其公差最小值是多少？-注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。\"><a href=\"#标题：等差素数列-2-3-5-7-11-13-…-是素数序列。-类似：7-37-67-97-127-157-这样完全由素数组成的等差数列，叫等差素数数列。-上边的数列公差为30，长度为6。-2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。-这是数论领域一项惊人的成果！-有这一理论为基础，请你借助手中的计算机，满怀信心地搜索：-长度为10的等差素数列，其公差最小值是多少？-注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。\" class=\"headerlink\" title=\"标题：等差素数列 2,3,5,7,11,13,….是素数序列。 类似：7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。 上边的数列公差为30，长度为6。 2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。 这是数论领域一项惊人的成果！ 有这一理论为基础，请你借助手中的计算机，满怀信心地搜索： 长度为10的等差素数列，其公差最小值是多少？ 注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。\"></a>标题：等差素数列 2,3,5,7,11,13,….是素数序列。 类似：7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。 上边的数列公差为30，长度为6。 2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。 这是数论领域一项惊人的成果！ 有这一理论为基础，请你借助手中的计算机，满怀信心地搜索： 长度为10的等差素数列，其公差最小值是多少？ 注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。</h5>","more":"<p><span style=\"color: #008000;\">解题思路：</span></p>\n<p><span style=\"color: #008000;\">用筛法求素数，not_prime[i]数组标记了第i个数是不是素数</span></p>\n<p><span style=\"color: #008000;\">从第一个素数2，长度为1开始穷举：</span></p>\n<p><span style=\"color: #008000;\">起始素数2，长度1…2…3….</span></p>\n<p><span style=\"color: #008000;\">起始素数3，长度1…2…3….</span></p>\n<p><span style=\"color: #008000;\">起始素数5，长度1…2…3….</span></p>\n<p><span style=\"color: #008000;\">…</span></p>\n<p><span style=\"color: #008000;\">起始素数i，长度1…2…3….</span></p>\n<p><span style=\"color: #008000;\">如果满足10个等差素数，就输出公差d，结束穷举</span></p>\n<pre>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nconst int maxn = 10000;\n\nbool not_prime[maxn];\n\nvoid f()\n{\n    memset(not_prime,0,sizeof(not_prime));\n    not_prime[0] = not_prime[1] = 1;\n\n    for (int i = 2; i &lt; maxn; ++i)\n    {\n        if (!not_prime[i])\n        {\n            for (int j = i * 2; j &lt; maxn; j += i)\n            {\n                not_prime[j] = 1;\n            }\n        }\n    }\n}\n\nint main()\n{\n    f();\n    //for (int i= 2; i &lt; 100; ++i) if (!not_prime[i]) cout &lt;&lt; i &lt;&lt; \" \";\n\n    int find = 0;\n    for (int i = 2;!find &amp;&amp; i &lt; maxn; ++i)\n    {\n        //从2开始作为开头\n        for (int d = 1; &amp;find &amp;&amp; d &lt; 1000; ++d)\n        {\n            int len = 0;\n            int temp = i;\n            while (!not_prime[temp])\n            {\n                ++len;\n                temp = temp + d;\n                if (len == 10)\n                {\n                    cout &lt;&lt; \"d:\" &lt;&lt; d&lt;&lt;endl;\n                    find = 1;\n                    break;\n                }\n            }\n        } \n    }\n\n    return 0;\n } \n</pre>"},{"title":"Liunx生成ssh 在github中配置","id":"328","date":"2017-08-31T07:56:56.000Z","_content":"\n1.安装git，这个不用说，没有git是不能使用github的，安装方法是：apt install git；\n2.配置git账户：\ngit config --global user.name \"yourname\" #配置用户名，将yourname和下面的邮箱替换成你的\ngit config --global user.email \"youremail@xmail.com\" #配置用户邮箱<!--more-->\n3.生成ssh密钥\nssh-keygen -t rsa -C “youremail@xmail.com” # 后面按提示操作，可以不设置密码，设置密码之后，每次使用这个密钥都是需要输入密码的\n4.第三步会得到id_rsa和id_rsa.pub两个文件，我们需要的是第二个，用cat读取里面的内容：\ncat id_rsa.pub\n5.登录你的github，在settings→SSH and GPG keys里面添加第四步生成的密钥，保存。\n6.验证，在终端中输入ssh git@github.com会得到一大串返回，如果末尾是\nYou’ve successfully authenticated, but GitHub does not provide shell access\nConnection to github.com closed.\n就说明成功了，没成功的话，删除第三步生成的两个文件，从第三步开始重复。","source":"_posts/liunx-e7-94-9f-e6-88-90ssh-e5-9c-a8github-e4-b8-ad-e9-85-8d-e7-bd-ae.md","raw":"---\ntitle: Liunx生成ssh 在github中配置\nid: 328\ncategories:\n  - git\n  - 工具们\ndate: 2017-08-31 15:56:56\ntags:\n---\n\n1.安装git，这个不用说，没有git是不能使用github的，安装方法是：apt install git；\n2.配置git账户：\ngit config --global user.name \"yourname\" #配置用户名，将yourname和下面的邮箱替换成你的\ngit config --global user.email \"youremail@xmail.com\" #配置用户邮箱<!--more-->\n3.生成ssh密钥\nssh-keygen -t rsa -C “youremail@xmail.com” # 后面按提示操作，可以不设置密码，设置密码之后，每次使用这个密钥都是需要输入密码的\n4.第三步会得到id_rsa和id_rsa.pub两个文件，我们需要的是第二个，用cat读取里面的内容：\ncat id_rsa.pub\n5.登录你的github，在settings→SSH and GPG keys里面添加第四步生成的密钥，保存。\n6.验证，在终端中输入ssh git@github.com会得到一大串返回，如果末尾是\nYou’ve successfully authenticated, but GitHub does not provide shell access\nConnection to github.com closed.\n就说明成功了，没成功的话，删除第三步生成的两个文件，从第三步开始重复。","slug":"liunx-e7-94-9f-e6-88-90ssh-e5-9c-a8github-e4-b8-ad-e9-85-8d-e7-bd-ae","published":1,"updated":"2017-12-09T17:06:50.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec1x002niwtwb9wqmt5h","content":"<p>1.安装git，这个不用说，没有git是不能使用github的，安装方法是：apt install git；<br>2.配置git账户：<br>git config –global user.name “yourname” #配置用户名，将yourname和下面的邮箱替换成你的<br>git config –global user.email “youremail@xmail.com” #配置用户邮箱<a id=\"more\"></a><br>3.生成ssh密钥<br>ssh-keygen -t rsa -C “youremail@xmail.com” # 后面按提示操作，可以不设置密码，设置密码之后，每次使用这个密钥都是需要输入密码的<br>4.第三步会得到id_rsa和id_rsa.pub两个文件，我们需要的是第二个，用cat读取里面的内容：<br>cat id_rsa.pub<br>5.登录你的github，在settings→SSH and GPG keys里面添加第四步生成的密钥，保存。<br>6.验证，在终端中输入ssh git@github.com会得到一大串返回，如果末尾是<br>You’ve successfully authenticated, but GitHub does not provide shell access<br>Connection to github.com closed.<br>就说明成功了，没成功的话，删除第三步生成的两个文件，从第三步开始重复。</p>\n","site":{"data":{}},"excerpt":"<p>1.安装git，这个不用说，没有git是不能使用github的，安装方法是：apt install git；<br>2.配置git账户：<br>git config –global user.name “yourname” #配置用户名，将yourname和下面的邮箱替换成你的<br>git config –global user.email “youremail@xmail.com” #配置用户邮箱","more":"<br>3.生成ssh密钥<br>ssh-keygen -t rsa -C “youremail@xmail.com” # 后面按提示操作，可以不设置密码，设置密码之后，每次使用这个密钥都是需要输入密码的<br>4.第三步会得到id_rsa和id_rsa.pub两个文件，我们需要的是第二个，用cat读取里面的内容：<br>cat id_rsa.pub<br>5.登录你的github，在settings→SSH and GPG keys里面添加第四步生成的密钥，保存。<br>6.验证，在终端中输入ssh git@github.com会得到一大串返回，如果末尾是<br>You’ve successfully authenticated, but GitHub does not provide shell access<br>Connection to github.com closed.<br>就说明成功了，没成功的话，删除第三步生成的两个文件，从第三步开始重复。</p>"},{"title":"opencv3.3中基于ssd算法的目标检测示例教程","id":"359","date":"2017-10-12T03:46:37.000Z","_content":"\n环境：Ubuntu16.04 / opencv3.3\n\n**#以下命令在终端运行**\n\n## 环境准备：\n\n1:安装依赖项：\nsudo apt-get install build-essential\nsudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev\nsudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev\n\n2:用git下载github上的opencv3.3：\ngit clone git@github.com:opencv/opencv.git<!--more-->\n\n3:到下载好的opencv文件夹下：\nmkdir build #创建名为build的文件夹,存cmake等的文件\ncd build\n\ncmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. #用cmake安装（编译）opencv相关组件\nmake -j4#用make编译，这是最低配置要求，可以加参数-j8\nsudo make install #最后的安装\n\n至此，opencv安装完毕。\n\nopencv3.3已经将opencv_contrib集成到opencv文件夹，所以我们要用的dnn就在opencv目录中：\n\n## \n步骤：\n\n1：在自己的主目录下建一个test文件夹，将下载的opencv/samples/data/dnn中的rgb.jpg和samples/dnn中的ssd_object_detection.cpp复制到test文件夹\n\n2：到https://github.com/weiliu89/caffe/tree/ssd#models 下载训练模型，我用的是VGG_VOC0712_SSD_300x300_iter_120000.caffemodel\n将下载的模型放到test文件夹，并解压\n\n3：将opencv/samples/dnn/face_detector中的test.prototxt复制到test文件夹\n\n4：修改ssd_object_detection.cpp中的内容：\n\n将：![](http://www.alanpro.win/wp-content/uploads/2017/10/ssd源文件.png)\n\n修改为自己的相关参数(model,image,proto)，我修改后的：![](http://www.alanpro.win/wp-content/uploads/2017/10/ssd_object_detection修改-1024x139.png)\n\n其中min_confidence为最小置信率，检测目标时置信率超过该值才打印出来(认为检测到有效目标)\n\n&nbsp;\n\n5：将opencv/samples/cpp/example_cmake中的CMakeLists.txt复制到test文件夹，这个文件是cmake的编译配置文件，修改其中的example.cpp为ssd_object_detection.cpp\n\n至此，需要的工具准备完成。\n\nlet's start:\n\n5：用cmake编译:\n\n进入test文件夹，并在终端运行\n\ncmake . #编译当前文件夹\n\nmake\n\n./opencv_example #运行生成的可执行文件\n\n&nbsp;\n\n至此所有步骤完。以下是我的运行结果：\n\n![](http://www.alanpro.win/wp-content/uploads/2017/10/ssd结果-1024x589.png)\n\n如以上过程报错，自行百度解决","source":"_posts/opencv3.3 ssd.md","raw":"---\ntitle: opencv3.3中基于ssd算法的目标检测示例教程\ntags:\n  - c++\n  - 机器学习\nid: 359\ncategories:\n  - 机器学习\ndate: 2017-10-12 11:46:37\n---\n\n环境：Ubuntu16.04 / opencv3.3\n\n**#以下命令在终端运行**\n\n## 环境准备：\n\n1:安装依赖项：\nsudo apt-get install build-essential\nsudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev\nsudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev\n\n2:用git下载github上的opencv3.3：\ngit clone git@github.com:opencv/opencv.git<!--more-->\n\n3:到下载好的opencv文件夹下：\nmkdir build #创建名为build的文件夹,存cmake等的文件\ncd build\n\ncmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. #用cmake安装（编译）opencv相关组件\nmake -j4#用make编译，这是最低配置要求，可以加参数-j8\nsudo make install #最后的安装\n\n至此，opencv安装完毕。\n\nopencv3.3已经将opencv_contrib集成到opencv文件夹，所以我们要用的dnn就在opencv目录中：\n\n## \n步骤：\n\n1：在自己的主目录下建一个test文件夹，将下载的opencv/samples/data/dnn中的rgb.jpg和samples/dnn中的ssd_object_detection.cpp复制到test文件夹\n\n2：到https://github.com/weiliu89/caffe/tree/ssd#models 下载训练模型，我用的是VGG_VOC0712_SSD_300x300_iter_120000.caffemodel\n将下载的模型放到test文件夹，并解压\n\n3：将opencv/samples/dnn/face_detector中的test.prototxt复制到test文件夹\n\n4：修改ssd_object_detection.cpp中的内容：\n\n将：![](http://www.alanpro.win/wp-content/uploads/2017/10/ssd源文件.png)\n\n修改为自己的相关参数(model,image,proto)，我修改后的：![](http://www.alanpro.win/wp-content/uploads/2017/10/ssd_object_detection修改-1024x139.png)\n\n其中min_confidence为最小置信率，检测目标时置信率超过该值才打印出来(认为检测到有效目标)\n\n&nbsp;\n\n5：将opencv/samples/cpp/example_cmake中的CMakeLists.txt复制到test文件夹，这个文件是cmake的编译配置文件，修改其中的example.cpp为ssd_object_detection.cpp\n\n至此，需要的工具准备完成。\n\nlet's start:\n\n5：用cmake编译:\n\n进入test文件夹，并在终端运行\n\ncmake . #编译当前文件夹\n\nmake\n\n./opencv_example #运行生成的可执行文件\n\n&nbsp;\n\n至此所有步骤完。以下是我的运行结果：\n\n![](http://www.alanpro.win/wp-content/uploads/2017/10/ssd结果-1024x589.png)\n\n如以上过程报错，自行百度解决","slug":"opencv3.3 ssd","published":1,"updated":"2017-12-09T17:06:50.796Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec1x002riwtwbf4hxcrx","content":"<p>环境：Ubuntu16.04 / opencv3.3</p>\n<p><strong>#以下命令在终端运行</strong></p>\n<h2 id=\"环境准备：\"><a href=\"#环境准备：\" class=\"headerlink\" title=\"环境准备：\"></a>环境准备：</h2><p>1:安装依赖项：<br>sudo apt-get install build-essential<br>sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev<br>sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</p>\n<p>2:用git下载github上的opencv3.3：<br>git clone git@github.com:opencv/opencv.git<a id=\"more\"></a></p>\n<p>3:到下载好的opencv文件夹下：<br>mkdir build #创建名为build的文件夹,存cmake等的文件<br>cd build</p>\n<p>cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. #用cmake安装（编译）opencv相关组件<br>make -j4#用make编译，这是最低配置要求，可以加参数-j8<br>sudo make install #最后的安装</p>\n<p>至此，opencv安装完毕。</p>\n<p>opencv3.3已经将opencv_contrib集成到opencv文件夹，所以我们要用的dnn就在opencv目录中：</p>\n<p>##<br>步骤：</p>\n<p>1：在自己的主目录下建一个test文件夹，将下载的opencv/samples/data/dnn中的rgb.jpg和samples/dnn中的ssd_object_detection.cpp复制到test文件夹</p>\n<p>2：到<a href=\"https://github.com/weiliu89/caffe/tree/ssd#models\" target=\"_blank\" rel=\"noopener\">https://github.com/weiliu89/caffe/tree/ssd#models</a> 下载训练模型，我用的是VGG_VOC0712_SSD_300x300_iter_120000.caffemodel<br>将下载的模型放到test文件夹，并解压</p>\n<p>3：将opencv/samples/dnn/face_detector中的test.prototxt复制到test文件夹</p>\n<p>4：修改ssd_object_detection.cpp中的内容：</p>\n<p>将：<img src=\"http://www.alanpro.win/wp-content/uploads/2017/10/ssd源文件.png\" alt=\"\"></p>\n<p>修改为自己的相关参数(model,image,proto)，我修改后的：<img src=\"http://www.alanpro.win/wp-content/uploads/2017/10/ssd_object_detection修改-1024x139.png\" alt=\"\"></p>\n<p>其中min_confidence为最小置信率，检测目标时置信率超过该值才打印出来(认为检测到有效目标)</p>\n<p>&nbsp;</p>\n<p>5：将opencv/samples/cpp/example_cmake中的CMakeLists.txt复制到test文件夹，这个文件是cmake的编译配置文件，修改其中的example.cpp为ssd_object_detection.cpp</p>\n<p>至此，需要的工具准备完成。</p>\n<p>let’s start:</p>\n<p>5：用cmake编译:</p>\n<p>进入test文件夹，并在终端运行</p>\n<p>cmake . #编译当前文件夹</p>\n<p>make</p>\n<p>./opencv_example #运行生成的可执行文件</p>\n<p>&nbsp;</p>\n<p>至此所有步骤完。以下是我的运行结果：</p>\n<p><img src=\"http://www.alanpro.win/wp-content/uploads/2017/10/ssd结果-1024x589.png\" alt=\"\"></p>\n<p>如以上过程报错，自行百度解决</p>\n","site":{"data":{}},"excerpt":"<p>环境：Ubuntu16.04 / opencv3.3</p>\n<p><strong>#以下命令在终端运行</strong></p>\n<h2 id=\"环境准备：\"><a href=\"#环境准备：\" class=\"headerlink\" title=\"环境准备：\"></a>环境准备：</h2><p>1:安装依赖项：<br>sudo apt-get install build-essential<br>sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev<br>sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</p>\n<p>2:用git下载github上的opencv3.3：<br>git clone git@github.com:opencv/opencv.git","more":"</p>\n<p>3:到下载好的opencv文件夹下：<br>mkdir build #创建名为build的文件夹,存cmake等的文件<br>cd build</p>\n<p>cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. #用cmake安装（编译）opencv相关组件<br>make -j4#用make编译，这是最低配置要求，可以加参数-j8<br>sudo make install #最后的安装</p>\n<p>至此，opencv安装完毕。</p>\n<p>opencv3.3已经将opencv_contrib集成到opencv文件夹，所以我们要用的dnn就在opencv目录中：</p>\n<p>##<br>步骤：</p>\n<p>1：在自己的主目录下建一个test文件夹，将下载的opencv/samples/data/dnn中的rgb.jpg和samples/dnn中的ssd_object_detection.cpp复制到test文件夹</p>\n<p>2：到<a href=\"https://github.com/weiliu89/caffe/tree/ssd#models\" target=\"_blank\" rel=\"noopener\">https://github.com/weiliu89/caffe/tree/ssd#models</a> 下载训练模型，我用的是VGG_VOC0712_SSD_300x300_iter_120000.caffemodel<br>将下载的模型放到test文件夹，并解压</p>\n<p>3：将opencv/samples/dnn/face_detector中的test.prototxt复制到test文件夹</p>\n<p>4：修改ssd_object_detection.cpp中的内容：</p>\n<p>将：<img src=\"http://www.alanpro.win/wp-content/uploads/2017/10/ssd源文件.png\" alt=\"\"></p>\n<p>修改为自己的相关参数(model,image,proto)，我修改后的：<img src=\"http://www.alanpro.win/wp-content/uploads/2017/10/ssd_object_detection修改-1024x139.png\" alt=\"\"></p>\n<p>其中min_confidence为最小置信率，检测目标时置信率超过该值才打印出来(认为检测到有效目标)</p>\n<p>&nbsp;</p>\n<p>5：将opencv/samples/cpp/example_cmake中的CMakeLists.txt复制到test文件夹，这个文件是cmake的编译配置文件，修改其中的example.cpp为ssd_object_detection.cpp</p>\n<p>至此，需要的工具准备完成。</p>\n<p>let’s start:</p>\n<p>5：用cmake编译:</p>\n<p>进入test文件夹，并在终端运行</p>\n<p>cmake . #编译当前文件夹</p>\n<p>make</p>\n<p>./opencv_example #运行生成的可执行文件</p>\n<p>&nbsp;</p>\n<p>至此所有步骤完。以下是我的运行结果：</p>\n<p><img src=\"http://www.alanpro.win/wp-content/uploads/2017/10/ssd结果-1024x589.png\" alt=\"\"></p>\n<p>如以上过程报错，自行百度解决</p>"},{"title":"关于python正则表达式处理的小问题","id":"188","date":"2017-06-30T01:46:26.000Z","_content":"\n*   如何匹配'&lt;br\\&gt;'？\n\n    *   由于字符串中有转义字符(反斜杠‘\\’)，那么这个字符本身要被匹配到的话，必须对它进行转义。代码：\nimport re\npattern = re.compile(r'&lt;br\\\\&gt;')\ns = pattern.search('hello&lt;br\\&gt;world')\nprint(s.group())\n*   为什么反斜杠已经被转义了，还要使用raw string（原生字符串）呢？\n\n    *   后一个反斜杠在前一个的作用下，在正则表达式中成了真正的反斜杠“\\”，而在re模块的解析器中，仍然被当作是转义符号，所以可以用'\\\\\\\\'来让re解析器解析成一个真正的反斜杠。然而我们现在有原生字符串r的功能。就可以少用两个\\\\\n    *   为什么要用原生字符串？\n\n            *   例如：在使用'\\t'的时候，输出的是一个缩进；而加了r之后r'\\t'输出的是'\\t'。也就是说r的作用下，字符串不会被转义\n\n    *","source":"_posts/python regular problems.md","raw":"---\ntitle: 关于python正则表达式处理的小问题\ntags:\n  - python学习\n  - python爬虫\nid: 188\ncategories:\n  - python学习\ndate: 2017-06-30 09:46:26\n---\n\n*   如何匹配'&lt;br\\&gt;'？\n\n    *   由于字符串中有转义字符(反斜杠‘\\’)，那么这个字符本身要被匹配到的话，必须对它进行转义。代码：\nimport re\npattern = re.compile(r'&lt;br\\\\&gt;')\ns = pattern.search('hello&lt;br\\&gt;world')\nprint(s.group())\n*   为什么反斜杠已经被转义了，还要使用raw string（原生字符串）呢？\n\n    *   后一个反斜杠在前一个的作用下，在正则表达式中成了真正的反斜杠“\\”，而在re模块的解析器中，仍然被当作是转义符号，所以可以用'\\\\\\\\'来让re解析器解析成一个真正的反斜杠。然而我们现在有原生字符串r的功能。就可以少用两个\\\\\n    *   为什么要用原生字符串？\n\n            *   例如：在使用'\\t'的时候，输出的是一个缩进；而加了r之后r'\\t'输出的是'\\t'。也就是说r的作用下，字符串不会被转义\n\n    *","slug":"python regular problems","published":1,"updated":"2017-12-09T17:06:50.786Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec27002viwtw23898t7u","content":"<ul>\n<li><p>如何匹配’&lt;br\\&gt;’？</p>\n<ul>\n<li>由于字符串中有转义字符(反斜杠‘\\’)，那么这个字符本身要被匹配到的话，必须对它进行转义。代码：<br>import re<br>pattern = re.compile(r’&lt;br\\&gt;’)<br>s = pattern.search(‘hello&lt;br\\&gt;world’)<br>print(s.group())</li>\n</ul>\n</li>\n<li><p>为什么反斜杠已经被转义了，还要使用raw string（原生字符串）呢？</p>\n<ul>\n<li>后一个反斜杠在前一个的作用下，在正则表达式中成了真正的反斜杠“\\”，而在re模块的解析器中，仍然被当作是转义符号，所以可以用’\\\\‘来让re解析器解析成一个真正的反斜杠。然而我们现在有原生字符串r的功能。就可以少用两个\\</li>\n<li><p>为什么要用原生字符串？</p>\n<pre><code>*   例如：在使用&apos;\\t&apos;的时候，输出的是一个缩进；而加了r之后r&apos;\\t&apos;输出的是&apos;\\t&apos;。也就是说r的作用下，字符串不会被转义\n</code></pre></li>\n</ul>\n<p>*</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>如何匹配’&lt;br\\&gt;’？</p>\n<ul>\n<li>由于字符串中有转义字符(反斜杠‘\\’)，那么这个字符本身要被匹配到的话，必须对它进行转义。代码：<br>import re<br>pattern = re.compile(r’&lt;br\\&gt;’)<br>s = pattern.search(‘hello&lt;br\\&gt;world’)<br>print(s.group())</li>\n</ul>\n</li>\n<li><p>为什么反斜杠已经被转义了，还要使用raw string（原生字符串）呢？</p>\n<ul>\n<li>后一个反斜杠在前一个的作用下，在正则表达式中成了真正的反斜杠“\\”，而在re模块的解析器中，仍然被当作是转义符号，所以可以用’\\\\‘来让re解析器解析成一个真正的反斜杠。然而我们现在有原生字符串r的功能。就可以少用两个\\</li>\n<li><p>为什么要用原生字符串？</p>\n<pre><code>*   例如：在使用&apos;\\t&apos;的时候，输出的是一个缩进；而加了r之后r&apos;\\t&apos;输出的是&apos;\\t&apos;。也就是说r的作用下，字符串不会被转义\n</code></pre></li>\n</ul>\n<p>*</p>\n</li>\n</ul>\n"},{"title":"python爬取维基百科，验证六度分隔定理代码（待完成）","id":"142","date":"2017-06-07T16:17:54.000Z","_content":"\n### 方案一：\n从一个页面开始（Kevin_Bacon的词条），对所有该页面出现的词条进行随机爬取。\n缺点：很可能会对同一个页面进行多次爬取，浪费资源。该例子的应对方案是：用datetime中now()方法获取动态的时间来修改伪随机数的生成函数的种子\n以更大的可能产生不同的随机数，尽可能的爬去更多的不同页面。但是这个方法仍然不靠谱。\n\n<!--more-->\n<pre>from urllib.request import urlopen\nfrom bs4 import BeautifulSoup\nimport re\nimport datetime\nimport  random\n\n#得到所有超链接\n# for link in soup.findAll('a'):#返回的是一个列表href=\"/wiki/BUtterfield_8\"\n#     if 'href' in link.attrs:#a的链接url,有的是该页面内的锚点。所以要进行筛选\n#         print(link.attrs['href'])\n\n# 链接分为两种：词条链接和其他链接\ndef getLinks(articleUrl):\n    # 得到html源码\n    html = urlopen('https://en.wikipedia.org'+articleUrl)\n    # 用BeautifulSoup解析，得到对象.用lxml解析器来解析,很快\n    soup = BeautifulSoup(html, 'lxml')\n    # 直接返回数据集\n    return soup.find('div', {'id':'bodyContent'}).findAll('a',href=re.compile('^(/wiki/)((?!:).)*$'))\n\nlinks = getLinks('/wiki/Kevin_Bacon')\n#print(len(links))\n# for i in range(5):\n#     print(links[i])\nrandom.seed(datetime.datetime.now())\nsum=0\nwhile len(links)&gt;0:\n    newArticle = links[random.randint(0,len(links)-1)].attrs['href']\n    print(newArticle)\n    links = getLinks(newArticle)\n    sum+=1\n\nprint('total:', sum)</pre>\n\n* * *\n\n### 方案二：\n\n构造一个set()，用于存放已经爬过的页面。\n\n从一个页面中获取所有的词条url的相对路径，如果已经出现在set集合内了，就换一个爬。没出现过的话就进去爬。\n<pre>from urllib.request import urlopen\nfrom bs4 import BeautifulSoup\nimport re\n\npages=set()\n# 链接分为两种：词条链接和其他链接\ndef getLinks(pageUrl):\n    global pages#升级为全局变量\n    html = urlopen('https://en.wikipedia.org' + pageUrl)\n    soup = BeautifulSoup(html,'lxml')\n    for link in soup.findAll('a',href=re.compile('^(/wiki/)')):\n        if 'href' in link.attrs:\n            if link.attrs['href'] not in pages:\n                #遇到了新页面\n                newPageUrl = link.attrs['href']\n                print(newPageUrl)\n                pages.add(newPageUrl)\n                getLinks(newPageUrl)\n\ngetLinks('')#空页面，从头开始\n\n**<span style=\"color: #ff0000;\">注意：以上方案都是递归，而python的递归深度有限，到达一定深度程序就会崩溃。需要换一种方法来解决深度问题。\n</span>**</pre>","source":"_posts/python spider wiki.md","raw":"---\ntitle: python爬取维基百科，验证六度分隔定理代码（待完成）\ntags:\n  - python爬虫\nid: 142\ncategories:\n  - python学习\ndate: 2017-06-08 00:17:54\n---\n\n### 方案一：\n从一个页面开始（Kevin_Bacon的词条），对所有该页面出现的词条进行随机爬取。\n缺点：很可能会对同一个页面进行多次爬取，浪费资源。该例子的应对方案是：用datetime中now()方法获取动态的时间来修改伪随机数的生成函数的种子\n以更大的可能产生不同的随机数，尽可能的爬去更多的不同页面。但是这个方法仍然不靠谱。\n\n<!--more-->\n<pre>from urllib.request import urlopen\nfrom bs4 import BeautifulSoup\nimport re\nimport datetime\nimport  random\n\n#得到所有超链接\n# for link in soup.findAll('a'):#返回的是一个列表href=\"/wiki/BUtterfield_8\"\n#     if 'href' in link.attrs:#a的链接url,有的是该页面内的锚点。所以要进行筛选\n#         print(link.attrs['href'])\n\n# 链接分为两种：词条链接和其他链接\ndef getLinks(articleUrl):\n    # 得到html源码\n    html = urlopen('https://en.wikipedia.org'+articleUrl)\n    # 用BeautifulSoup解析，得到对象.用lxml解析器来解析,很快\n    soup = BeautifulSoup(html, 'lxml')\n    # 直接返回数据集\n    return soup.find('div', {'id':'bodyContent'}).findAll('a',href=re.compile('^(/wiki/)((?!:).)*$'))\n\nlinks = getLinks('/wiki/Kevin_Bacon')\n#print(len(links))\n# for i in range(5):\n#     print(links[i])\nrandom.seed(datetime.datetime.now())\nsum=0\nwhile len(links)&gt;0:\n    newArticle = links[random.randint(0,len(links)-1)].attrs['href']\n    print(newArticle)\n    links = getLinks(newArticle)\n    sum+=1\n\nprint('total:', sum)</pre>\n\n* * *\n\n### 方案二：\n\n构造一个set()，用于存放已经爬过的页面。\n\n从一个页面中获取所有的词条url的相对路径，如果已经出现在set集合内了，就换一个爬。没出现过的话就进去爬。\n<pre>from urllib.request import urlopen\nfrom bs4 import BeautifulSoup\nimport re\n\npages=set()\n# 链接分为两种：词条链接和其他链接\ndef getLinks(pageUrl):\n    global pages#升级为全局变量\n    html = urlopen('https://en.wikipedia.org' + pageUrl)\n    soup = BeautifulSoup(html,'lxml')\n    for link in soup.findAll('a',href=re.compile('^(/wiki/)')):\n        if 'href' in link.attrs:\n            if link.attrs['href'] not in pages:\n                #遇到了新页面\n                newPageUrl = link.attrs['href']\n                print(newPageUrl)\n                pages.add(newPageUrl)\n                getLinks(newPageUrl)\n\ngetLinks('')#空页面，从头开始\n\n**<span style=\"color: #ff0000;\">注意：以上方案都是递归，而python的递归深度有限，到达一定深度程序就会崩溃。需要换一种方法来解决深度问题。\n</span>**</pre>","slug":"python spider wiki","published":1,"updated":"2017-12-09T17:06:50.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec27002yiwtwqcfg13o4","content":"<h3 id=\"方案一：\"><a href=\"#方案一：\" class=\"headerlink\" title=\"方案一：\"></a>方案一：</h3><p>从一个页面开始（Kevin_Bacon的词条），对所有该页面出现的词条进行随机爬取。<br>缺点：很可能会对同一个页面进行多次爬取，浪费资源。该例子的应对方案是：用datetime中now()方法获取动态的时间来修改伪随机数的生成函数的种子<br>以更大的可能产生不同的随机数，尽可能的爬去更多的不同页面。但是这个方法仍然不靠谱。</p>\n<a id=\"more\"></a>\n<pre>from urllib.request import urlopen\nfrom bs4 import BeautifulSoup\nimport re\nimport datetime\nimport  random\n\n#得到所有超链接\n# for link in soup.findAll('a'):#返回的是一个列表href=\"/wiki/BUtterfield_8\"\n#     if 'href' in link.attrs:#a的链接url,有的是该页面内的锚点。所以要进行筛选\n#         print(link.attrs['href'])\n\n# 链接分为两种：词条链接和其他链接\ndef getLinks(articleUrl):\n    # 得到html源码\n    html = urlopen('https://en.wikipedia.org'+articleUrl)\n    # 用BeautifulSoup解析，得到对象.用lxml解析器来解析,很快\n    soup = BeautifulSoup(html, 'lxml')\n    # 直接返回数据集\n    return soup.find('div', {'id':'bodyContent'}).findAll('a',href=re.compile('^(/wiki/)((?!:).)*$'))\n\nlinks = getLinks('/wiki/Kevin_Bacon')\n#print(len(links))\n# for i in range(5):\n#     print(links[i])\nrandom.seed(datetime.datetime.now())\nsum=0\nwhile len(links)&gt;0:\n    newArticle = links[random.randint(0,len(links)-1)].attrs['href']\n    print(newArticle)\n    links = getLinks(newArticle)\n    sum+=1\n\nprint('total:', sum)</pre>\n\n<hr>\n<h3 id=\"方案二：\"><a href=\"#方案二：\" class=\"headerlink\" title=\"方案二：\"></a>方案二：</h3><p>构造一个set()，用于存放已经爬过的页面。</p>\n<p>从一个页面中获取所有的词条url的相对路径，如果已经出现在set集合内了，就换一个爬。没出现过的话就进去爬。</p>\n<pre>from urllib.request import urlopen\nfrom bs4 import BeautifulSoup\nimport re\n\npages=set()\n# 链接分为两种：词条链接和其他链接\ndef getLinks(pageUrl):\n    global pages#升级为全局变量\n    html = urlopen('https://en.wikipedia.org' + pageUrl)\n    soup = BeautifulSoup(html,'lxml')\n    for link in soup.findAll('a',href=re.compile('^(/wiki/)')):\n        if 'href' in link.attrs:\n            if link.attrs['href'] not in pages:\n                #遇到了新页面\n                newPageUrl = link.attrs['href']\n                print(newPageUrl)\n                pages.add(newPageUrl)\n                getLinks(newPageUrl)\n\ngetLinks('')#空页面，从头开始\n\n**<span style=\"color: #ff0000;\">注意：以上方案都是递归，而python的递归深度有限，到达一定深度程序就会崩溃。需要换一种方法来解决深度问题。\n</span>**</pre>","site":{"data":{}},"excerpt":"<h3 id=\"方案一：\"><a href=\"#方案一：\" class=\"headerlink\" title=\"方案一：\"></a>方案一：</h3><p>从一个页面开始（Kevin_Bacon的词条），对所有该页面出现的词条进行随机爬取。<br>缺点：很可能会对同一个页面进行多次爬取，浪费资源。该例子的应对方案是：用datetime中now()方法获取动态的时间来修改伪随机数的生成函数的种子<br>以更大的可能产生不同的随机数，尽可能的爬去更多的不同页面。但是这个方法仍然不靠谱。</p>","more":"<pre>from urllib.request import urlopen\nfrom bs4 import BeautifulSoup\nimport re\nimport datetime\nimport  random\n\n#得到所有超链接\n# for link in soup.findAll('a'):#返回的是一个列表href=\"/wiki/BUtterfield_8\"\n#     if 'href' in link.attrs:#a的链接url,有的是该页面内的锚点。所以要进行筛选\n#         print(link.attrs['href'])\n\n# 链接分为两种：词条链接和其他链接\ndef getLinks(articleUrl):\n    # 得到html源码\n    html = urlopen('https://en.wikipedia.org'+articleUrl)\n    # 用BeautifulSoup解析，得到对象.用lxml解析器来解析,很快\n    soup = BeautifulSoup(html, 'lxml')\n    # 直接返回数据集\n    return soup.find('div', {'id':'bodyContent'}).findAll('a',href=re.compile('^(/wiki/)((?!:).)*$'))\n\nlinks = getLinks('/wiki/Kevin_Bacon')\n#print(len(links))\n# for i in range(5):\n#     print(links[i])\nrandom.seed(datetime.datetime.now())\nsum=0\nwhile len(links)&gt;0:\n    newArticle = links[random.randint(0,len(links)-1)].attrs['href']\n    print(newArticle)\n    links = getLinks(newArticle)\n    sum+=1\n\nprint('total:', sum)</pre>\n\n<hr>\n<h3 id=\"方案二：\"><a href=\"#方案二：\" class=\"headerlink\" title=\"方案二：\"></a>方案二：</h3><p>构造一个set()，用于存放已经爬过的页面。</p>\n<p>从一个页面中获取所有的词条url的相对路径，如果已经出现在set集合内了，就换一个爬。没出现过的话就进去爬。</p>\n<pre>from urllib.request import urlopen\nfrom bs4 import BeautifulSoup\nimport re\n\npages=set()\n# 链接分为两种：词条链接和其他链接\ndef getLinks(pageUrl):\n    global pages#升级为全局变量\n    html = urlopen('https://en.wikipedia.org' + pageUrl)\n    soup = BeautifulSoup(html,'lxml')\n    for link in soup.findAll('a',href=re.compile('^(/wiki/)')):\n        if 'href' in link.attrs:\n            if link.attrs['href'] not in pages:\n                #遇到了新页面\n                newPageUrl = link.attrs['href']\n                print(newPageUrl)\n                pages.add(newPageUrl)\n                getLinks(newPageUrl)\n\ngetLinks('')#空页面，从头开始\n\n**<span style=\"color: #ff0000;\">注意：以上方案都是递归，而python的递归深度有限，到达一定深度程序就会崩溃。需要换一种方法来解决深度问题。\n</span>**</pre>"},{"title":"python基础小结","id":"151","date":"2017-06-09T12:25:06.000Z","_content":"\n关于参数的：\npython函数可以传入任意类型的参数。在这里，传入一个可以迭代的对象作为参数\n1:位置参数\n<pre>def test(L):\n\tfor i in L:\n\t\tprint(i)\n</pre>\n例如,调用test(['hello','world',1]),<!--more-->\n输出:\n<pre>hello\nworld\n1\n</pre>\n调用test({'hello':1,'world':2})\n输出:\n<pre>hello\nworld\n</pre>\n2:可变参数\n<pre>def test1(*L):\n\tfor i in L:\n\t\tprint(i)\n</pre>\n调用test1(['hello','world',1])\n输出:\n<pre>['hello','world',1]\n</pre>\n调用:test1('hello','world',1)\n输出\n<pre>hello\nworld\n1\n</pre>\n可变参数的用途是可以传入多个参数，可以是多个迭代对象，必须要在参数前加*。在函数内部，参数接收到的是一个元组tuple.\n如果现在已经构造了一个元组或者序列，例如：l1 = ['hello','world',1],要想把里面的每一个元素当作多个参数传入可变参数的函数，就要在调用的时候，参数前面加*\n例如:\n<pre>l1=['hello','world',1]\ntest1(*l1)\n\n#输出：\nhello\nworld\n1\n</pre>\n也就是说*l1把l1变成可变参数传给了test1","source":"_posts/python-e5-9f-ba-e7-a1-80-e5-b0-8f-e7-bb-93.md","raw":"---\ntitle: python基础小结\ntags:\n  - python学习\nid: 151\ncategories:\n  - python学习\ndate: 2017-06-09 20:25:06\n---\n\n关于参数的：\npython函数可以传入任意类型的参数。在这里，传入一个可以迭代的对象作为参数\n1:位置参数\n<pre>def test(L):\n\tfor i in L:\n\t\tprint(i)\n</pre>\n例如,调用test(['hello','world',1]),<!--more-->\n输出:\n<pre>hello\nworld\n1\n</pre>\n调用test({'hello':1,'world':2})\n输出:\n<pre>hello\nworld\n</pre>\n2:可变参数\n<pre>def test1(*L):\n\tfor i in L:\n\t\tprint(i)\n</pre>\n调用test1(['hello','world',1])\n输出:\n<pre>['hello','world',1]\n</pre>\n调用:test1('hello','world',1)\n输出\n<pre>hello\nworld\n1\n</pre>\n可变参数的用途是可以传入多个参数，可以是多个迭代对象，必须要在参数前加*。在函数内部，参数接收到的是一个元组tuple.\n如果现在已经构造了一个元组或者序列，例如：l1 = ['hello','world',1],要想把里面的每一个元素当作多个参数传入可变参数的函数，就要在调用的时候，参数前面加*\n例如:\n<pre>l1=['hello','world',1]\ntest1(*l1)\n\n#输出：\nhello\nworld\n1\n</pre>\n也就是说*l1把l1变成可变参数传给了test1","slug":"python-e5-9f-ba-e7-a1-80-e5-b0-8f-e7-bb-93","published":1,"updated":"2017-12-09T17:06:50.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec270031iwtwsntzo8ge","content":"<p>关于参数的：<br>python函数可以传入任意类型的参数。在这里，传入一个可以迭代的对象作为参数<br>1:位置参数</p>\n<p><pre>def test(L):<br>    for i in L:<br>        print(i)<br></pre><br>例如,调用test([‘hello’,’world’,1]),<a id=\"more\"></a><br>输出:</p>\n<p><pre>hello<br>world<br>1<br></pre><br>调用test({‘hello’:1,’world’:2})<br>输出:</p>\n<p><pre>hello<br>world<br></pre><br>2:可变参数</p>\n<p><pre>def test1(*L):<br>    for i in L:<br>        print(i)<br></pre><br>调用test1([‘hello’,’world’,1])<br>输出:</p>\n<p><pre>[‘hello’,’world’,1]<br></pre><br>调用:test1(‘hello’,’world’,1)<br>输出</p>\n<p><pre>hello<br>world<br>1<br></pre><br>可变参数的用途是可以传入多个参数，可以是多个迭代对象，必须要在参数前加<em>。在函数内部，参数接收到的是一个元组tuple.<br>如果现在已经构造了一个元组或者序列，例如：l1 = [‘hello’,’world’,1],要想把里面的每一个元素当作多个参数传入可变参数的函数，就要在调用的时候，参数前面加</em><br>例如:</p>\n<p><pre>l1=[‘hello’,’world’,1]<br>test1(*l1)</pre></p>\n<p>#输出：<br>hello<br>world<br>1<br><br>也就是说*l1把l1变成可变参数传给了test1</p>\n","site":{"data":{}},"excerpt":"<p>关于参数的：<br>python函数可以传入任意类型的参数。在这里，传入一个可以迭代的对象作为参数<br>1:位置参数</p>\n<p><pre>def test(L):<br>    for i in L:<br>        print(i)<br></pre><br>例如,调用test([‘hello’,’world’,1]),","more":"<br>输出:</p>\n<p><pre>hello<br>world<br>1<br></pre><br>调用test({‘hello’:1,’world’:2})<br>输出:</p>\n<p><pre>hello<br>world<br></pre><br>2:可变参数</p>\n<p><pre>def test1(*L):<br>    for i in L:<br>        print(i)<br></pre><br>调用test1([‘hello’,’world’,1])<br>输出:</p>\n<p><pre>[‘hello’,’world’,1]<br></pre><br>调用:test1(‘hello’,’world’,1)<br>输出</p>\n<p><pre>hello<br>world<br>1<br></pre><br>可变参数的用途是可以传入多个参数，可以是多个迭代对象，必须要在参数前加<em>。在函数内部，参数接收到的是一个元组tuple.<br>如果现在已经构造了一个元组或者序列，例如：l1 = [‘hello’,’world’,1],要想把里面的每一个元素当作多个参数传入可变参数的函数，就要在调用的时候，参数前面加</em><br>例如:</p>\n<p><pre>l1=[‘hello’,’world’,1]<br>test1(*l1)</pre></p>\n<p>#输出：<br>hello<br>world<br>1<br><br>也就是说*l1把l1变成可变参数传给了test1</p>"},{"title":"Session和Cookie的区别","id":"110","date":"2017-04-21T05:17:00.000Z","_content":"\n[Session和Cookie的区别](http://www.cnblogs.com/wuguanglei/p/4294251.html)","source":"_posts/session-e5-92-8ccookie-e7-9a-84-e5-8c-ba-e5-88-ab.md","raw":"---\ntitle: Session和Cookie的区别\ntags:\n  - web学习整理\nid: 110\ncategories:\n  - web学习整理\ndate: 2017-04-21 13:17:00\n---\n\n[Session和Cookie的区别](http://www.cnblogs.com/wuguanglei/p/4294251.html)","slug":"session-e5-92-8ccookie-e7-9a-84-e5-8c-ba-e5-88-ab","published":1,"updated":"2017-12-09T17:06:50.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec270034iwtwkcgfu1pl","content":"<p><a href=\"http://www.cnblogs.com/wuguanglei/p/4294251.html\" target=\"_blank\" rel=\"noopener\">Session和Cookie的区别</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.cnblogs.com/wuguanglei/p/4294251.html\" target=\"_blank\" rel=\"noopener\">Session和Cookie的区别</a></p>\n"},{"title":"python常用库整理","id":"144","date":"2017-06-08T13:10:27.000Z","_content":"\n[![python logo](http://www.alanpro.win/wp-content/uploads/2017/06/python-logo-300x127.png)](https://docs.python.org/3.5/library/)\n\n# GUI 图形界面\n\nTkinter : [Tkinter](http://link.zhihu.com/?target=https%3A//wiki.python.org/moin/TkInter/)\n\nwxPython: [wxPython](http://link.zhihu.com/?target=https%3A//www.wxpython.org/)\n\nPyGTK: [PyGTK](http://link.zhihu.com/?target=http%3A//www.pygtk.org/)\n\nPyQt: [PyQt](http://link.zhihu.com/?target=https%3A//sourceforge.net/projects/pyqt/)\n\nPySide: [PySide](http://link.zhihu.com/?target=http%3A//wiki.qt.io/Category%3ALanguageBindings%3A%3APySide)<!--more-->\n\n# **Web框架**\n\ndjango： [django](http://link.zhihu.com/?target=https%3A//www.djangoproject.com/)\n\nweb2py：[web2py](http://link.zhihu.com/?target=http%3A//web2py.com/)\n\nflask： [flask](http://link.zhihu.com/?target=http%3A//flask.pocoo.org/)\n\nbottle： [bottle](http://link.zhihu.com/?target=http%3A//www.bottlepy.org/docs/dev/index.html)\n\ntornadoweb ：[tornadoweb](http://link.zhihu.com/?target=http%3A//www.tornadoweb.org/en/stable/)\n\nwebpy： [webpy](http://link.zhihu.com/?target=http%3A//webpy.org/)\n\ncherrypy： [cherrypy](http://link.zhihu.com/?target=http%3A//www.cherrypy.org/)\n\njinjs： [jinja](http://link.zhihu.com/?target=http%3A//docs.jinkan.org/docs/jinja2/)\n\n# 科学计算\n\nnumpy： [numpy](http://link.zhihu.com/?target=http%3A//www.numpy.org/)\n\nSciPy：[scipy](http://link.zhihu.com/?target=http%3A//www.scipy.org/)\n\npandas： [pandas](http://link.zhihu.com/?target=http%3A//pandas.pydata.org/)\n\nblaze： [blaze](http://link.zhihu.com/?target=http%3A//blaze.readthedocs.io/en/latest/index.html)\n\n# 密码学\n\ncryptography：[cryptography](http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/cryptography/)\n\nhashids：[hashids](http://link.zhihu.com/?target=http%3A//www.oschina.net/p/hashids)\n\nParamiko：[Paramiko](http://link.zhihu.com/?target=http%3A//www.paramiko.org/)\n\nPasslib：[Passlib](http://link.zhihu.com/?target=https%3A//pythonhosted.org/passlib/)\n\nPyCrypto：[PyCrypto](http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/pycrypto)\n\nPyNacl：[PyNacl](http://link.zhihu.com/?target=http%3A//pynacl.readthedocs.io/en/latest/)\n\n# 爬虫相关\n\nurllib 、urllib2 、requests\n\nscrapy： [scrapy](http://link.zhihu.com/?target=http%3A//scrapy.org/)\n\npyspider： [pyspider](http://link.zhihu.com/?target=https%3A//github.com/binux/pyspider)\n\nportia： [portia](http://link.zhihu.com/?target=https%3A//github.com/scrapinghub/portia)\n\nhtml2text： [html2text](http://link.zhihu.com/?target=https%3A//github.com/Alir3z4/html2text)\n\nBeautifulSoup： [BeautifulSoup](http://link.zhihu.com/?target=https%3A//www.crummy.com/software/BeautifulSoup/)\n\nlxml： [lxml](http://link.zhihu.com/?target=http%3A//lxml.de/)\n\nselenium：[selenium](http://link.zhihu.com/?target=http%3A//docs.seleniumhq.org/)\n\nmechanize： [mechanize](http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/mechanize)\n\nPyQuery： [pyquery](http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/pyquery/)\n\ncreepy： [creepy](http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/creepy)\n\n# 图像处理\n\nbigmoyan：[scikit-image](http://link.zhihu.com/?target=http%3A//scikit-image.org/) （感谢[@BigMoyan](http://www.zhihu.com/people/b09b100677c266647b48bc2fe789a36f \"@BigMoyan\") 提供信息）\n\nPython Imaging Library (PIL)：[pil](http://link.zhihu.com/?target=http%3A//www.pythonware.com/products/pil/)\n\npillow： [pillow](http://link.zhihu.com/?target=http%3A//pillow.readthedocs.io/en/latest/)\n\npython-qrcode： [python-qrcode](http://link.zhihu.com/?target=https%3A//github.com/lincolnloop/python-qrcode)\n\n# 自然语言处理\n\nnltk： [nltk ](http://link.zhihu.com/?target=http%3A//www.nltk.org/)\n\nsnownlp： [snownlp](http://link.zhihu.com/?target=https%3A//github.com/isnowfy/snownlp)\n\nPattern：[pattern](http://link.zhihu.com/?target=https%3A//github.com/clips/pattern)\n\nTextBlob：[textblob](http://link.zhihu.com/?target=http%3A//textblob.readthedocs.org/en/dev/)\n\nPolyglot：[polyglot](http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/polyglot)\n\njieba： [jieba](http://link.zhihu.com/?target=https%3A//github.com/fxsjy/jieba)\n\n# 数据库驱动\n\nmysql-python： [mysql-python](http://link.zhihu.com/?target=https%3A//sourceforge.net/projects/mysql-python/)\n\nPyMySQL： [PyMySQL](http://link.zhihu.com/?target=https%3A//github.com/PyMySQL/PyMySQL)\n\nPyMongo： [PyMongo](http://link.zhihu.com/?target=https%3A//docs.mongodb.com/ecosystem/drivers/python/)","source":"_posts/python-libraries.md","raw":"---\ntitle: python常用库整理\ntags:\n  - python学习\nid: 144\ncategories:\n  - python学习\ndate: 2017-06-08 21:10:27\n---\n\n[![python logo](http://www.alanpro.win/wp-content/uploads/2017/06/python-logo-300x127.png)](https://docs.python.org/3.5/library/)\n\n# GUI 图形界面\n\nTkinter : [Tkinter](http://link.zhihu.com/?target=https%3A//wiki.python.org/moin/TkInter/)\n\nwxPython: [wxPython](http://link.zhihu.com/?target=https%3A//www.wxpython.org/)\n\nPyGTK: [PyGTK](http://link.zhihu.com/?target=http%3A//www.pygtk.org/)\n\nPyQt: [PyQt](http://link.zhihu.com/?target=https%3A//sourceforge.net/projects/pyqt/)\n\nPySide: [PySide](http://link.zhihu.com/?target=http%3A//wiki.qt.io/Category%3ALanguageBindings%3A%3APySide)<!--more-->\n\n# **Web框架**\n\ndjango： [django](http://link.zhihu.com/?target=https%3A//www.djangoproject.com/)\n\nweb2py：[web2py](http://link.zhihu.com/?target=http%3A//web2py.com/)\n\nflask： [flask](http://link.zhihu.com/?target=http%3A//flask.pocoo.org/)\n\nbottle： [bottle](http://link.zhihu.com/?target=http%3A//www.bottlepy.org/docs/dev/index.html)\n\ntornadoweb ：[tornadoweb](http://link.zhihu.com/?target=http%3A//www.tornadoweb.org/en/stable/)\n\nwebpy： [webpy](http://link.zhihu.com/?target=http%3A//webpy.org/)\n\ncherrypy： [cherrypy](http://link.zhihu.com/?target=http%3A//www.cherrypy.org/)\n\njinjs： [jinja](http://link.zhihu.com/?target=http%3A//docs.jinkan.org/docs/jinja2/)\n\n# 科学计算\n\nnumpy： [numpy](http://link.zhihu.com/?target=http%3A//www.numpy.org/)\n\nSciPy：[scipy](http://link.zhihu.com/?target=http%3A//www.scipy.org/)\n\npandas： [pandas](http://link.zhihu.com/?target=http%3A//pandas.pydata.org/)\n\nblaze： [blaze](http://link.zhihu.com/?target=http%3A//blaze.readthedocs.io/en/latest/index.html)\n\n# 密码学\n\ncryptography：[cryptography](http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/cryptography/)\n\nhashids：[hashids](http://link.zhihu.com/?target=http%3A//www.oschina.net/p/hashids)\n\nParamiko：[Paramiko](http://link.zhihu.com/?target=http%3A//www.paramiko.org/)\n\nPasslib：[Passlib](http://link.zhihu.com/?target=https%3A//pythonhosted.org/passlib/)\n\nPyCrypto：[PyCrypto](http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/pycrypto)\n\nPyNacl：[PyNacl](http://link.zhihu.com/?target=http%3A//pynacl.readthedocs.io/en/latest/)\n\n# 爬虫相关\n\nurllib 、urllib2 、requests\n\nscrapy： [scrapy](http://link.zhihu.com/?target=http%3A//scrapy.org/)\n\npyspider： [pyspider](http://link.zhihu.com/?target=https%3A//github.com/binux/pyspider)\n\nportia： [portia](http://link.zhihu.com/?target=https%3A//github.com/scrapinghub/portia)\n\nhtml2text： [html2text](http://link.zhihu.com/?target=https%3A//github.com/Alir3z4/html2text)\n\nBeautifulSoup： [BeautifulSoup](http://link.zhihu.com/?target=https%3A//www.crummy.com/software/BeautifulSoup/)\n\nlxml： [lxml](http://link.zhihu.com/?target=http%3A//lxml.de/)\n\nselenium：[selenium](http://link.zhihu.com/?target=http%3A//docs.seleniumhq.org/)\n\nmechanize： [mechanize](http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/mechanize)\n\nPyQuery： [pyquery](http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/pyquery/)\n\ncreepy： [creepy](http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/creepy)\n\n# 图像处理\n\nbigmoyan：[scikit-image](http://link.zhihu.com/?target=http%3A//scikit-image.org/) （感谢[@BigMoyan](http://www.zhihu.com/people/b09b100677c266647b48bc2fe789a36f \"@BigMoyan\") 提供信息）\n\nPython Imaging Library (PIL)：[pil](http://link.zhihu.com/?target=http%3A//www.pythonware.com/products/pil/)\n\npillow： [pillow](http://link.zhihu.com/?target=http%3A//pillow.readthedocs.io/en/latest/)\n\npython-qrcode： [python-qrcode](http://link.zhihu.com/?target=https%3A//github.com/lincolnloop/python-qrcode)\n\n# 自然语言处理\n\nnltk： [nltk ](http://link.zhihu.com/?target=http%3A//www.nltk.org/)\n\nsnownlp： [snownlp](http://link.zhihu.com/?target=https%3A//github.com/isnowfy/snownlp)\n\nPattern：[pattern](http://link.zhihu.com/?target=https%3A//github.com/clips/pattern)\n\nTextBlob：[textblob](http://link.zhihu.com/?target=http%3A//textblob.readthedocs.org/en/dev/)\n\nPolyglot：[polyglot](http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/polyglot)\n\njieba： [jieba](http://link.zhihu.com/?target=https%3A//github.com/fxsjy/jieba)\n\n# 数据库驱动\n\nmysql-python： [mysql-python](http://link.zhihu.com/?target=https%3A//sourceforge.net/projects/mysql-python/)\n\nPyMySQL： [PyMySQL](http://link.zhihu.com/?target=https%3A//github.com/PyMySQL/PyMySQL)\n\nPyMongo： [PyMongo](http://link.zhihu.com/?target=https%3A//docs.mongodb.com/ecosystem/drivers/python/)","slug":"python-libraries","published":1,"updated":"2017-12-09T17:06:50.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec270037iwtw0hkfzlzo","content":"<p><a href=\"https://docs.python.org/3.5/library/\" target=\"_blank\" rel=\"noopener\"><img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/python-logo-300x127.png\" alt=\"python logo\"></a></p>\n<h1 id=\"GUI-图形界面\"><a href=\"#GUI-图形界面\" class=\"headerlink\" title=\"GUI 图形界面\"></a>GUI 图形界面</h1><p>Tkinter : <a href=\"http://link.zhihu.com/?target=https%3A//wiki.python.org/moin/TkInter/\" target=\"_blank\" rel=\"noopener\">Tkinter</a></p>\n<p>wxPython: <a href=\"http://link.zhihu.com/?target=https%3A//www.wxpython.org/\" target=\"_blank\" rel=\"noopener\">wxPython</a></p>\n<p>PyGTK: <a href=\"http://link.zhihu.com/?target=http%3A//www.pygtk.org/\" target=\"_blank\" rel=\"noopener\">PyGTK</a></p>\n<p>PyQt: <a href=\"http://link.zhihu.com/?target=https%3A//sourceforge.net/projects/pyqt/\" target=\"_blank\" rel=\"noopener\">PyQt</a></p>\n<p>PySide: <a href=\"http://link.zhihu.com/?target=http%3A//wiki.qt.io/Category%3ALanguageBindings%3A%3APySide\" target=\"_blank\" rel=\"noopener\">PySide</a><a id=\"more\"></a></p>\n<h1 id=\"Web框架\"><a href=\"#Web框架\" class=\"headerlink\" title=\"Web框架\"></a><strong>Web框架</strong></h1><p>django： <a href=\"http://link.zhihu.com/?target=https%3A//www.djangoproject.com/\" target=\"_blank\" rel=\"noopener\">django</a></p>\n<p>web2py：<a href=\"http://link.zhihu.com/?target=http%3A//web2py.com/\" target=\"_blank\" rel=\"noopener\">web2py</a></p>\n<p>flask： <a href=\"http://link.zhihu.com/?target=http%3A//flask.pocoo.org/\" target=\"_blank\" rel=\"noopener\">flask</a></p>\n<p>bottle： <a href=\"http://link.zhihu.com/?target=http%3A//www.bottlepy.org/docs/dev/index.html\" target=\"_blank\" rel=\"noopener\">bottle</a></p>\n<p>tornadoweb ：<a href=\"http://link.zhihu.com/?target=http%3A//www.tornadoweb.org/en/stable/\" target=\"_blank\" rel=\"noopener\">tornadoweb</a></p>\n<p>webpy： <a href=\"http://link.zhihu.com/?target=http%3A//webpy.org/\" target=\"_blank\" rel=\"noopener\">webpy</a></p>\n<p>cherrypy： <a href=\"http://link.zhihu.com/?target=http%3A//www.cherrypy.org/\" target=\"_blank\" rel=\"noopener\">cherrypy</a></p>\n<p>jinjs： <a href=\"http://link.zhihu.com/?target=http%3A//docs.jinkan.org/docs/jinja2/\" target=\"_blank\" rel=\"noopener\">jinja</a></p>\n<h1 id=\"科学计算\"><a href=\"#科学计算\" class=\"headerlink\" title=\"科学计算\"></a>科学计算</h1><p>numpy： <a href=\"http://link.zhihu.com/?target=http%3A//www.numpy.org/\" target=\"_blank\" rel=\"noopener\">numpy</a></p>\n<p>SciPy：<a href=\"http://link.zhihu.com/?target=http%3A//www.scipy.org/\" target=\"_blank\" rel=\"noopener\">scipy</a></p>\n<p>pandas： <a href=\"http://link.zhihu.com/?target=http%3A//pandas.pydata.org/\" target=\"_blank\" rel=\"noopener\">pandas</a></p>\n<p>blaze： <a href=\"http://link.zhihu.com/?target=http%3A//blaze.readthedocs.io/en/latest/index.html\" target=\"_blank\" rel=\"noopener\">blaze</a></p>\n<h1 id=\"密码学\"><a href=\"#密码学\" class=\"headerlink\" title=\"密码学\"></a>密码学</h1><p>cryptography：<a href=\"http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/cryptography/\" target=\"_blank\" rel=\"noopener\">cryptography</a></p>\n<p>hashids：<a href=\"http://link.zhihu.com/?target=http%3A//www.oschina.net/p/hashids\" target=\"_blank\" rel=\"noopener\">hashids</a></p>\n<p>Paramiko：<a href=\"http://link.zhihu.com/?target=http%3A//www.paramiko.org/\" target=\"_blank\" rel=\"noopener\">Paramiko</a></p>\n<p>Passlib：<a href=\"http://link.zhihu.com/?target=https%3A//pythonhosted.org/passlib/\" target=\"_blank\" rel=\"noopener\">Passlib</a></p>\n<p>PyCrypto：<a href=\"http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/pycrypto\" target=\"_blank\" rel=\"noopener\">PyCrypto</a></p>\n<p>PyNacl：<a href=\"http://link.zhihu.com/?target=http%3A//pynacl.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener\">PyNacl</a></p>\n<h1 id=\"爬虫相关\"><a href=\"#爬虫相关\" class=\"headerlink\" title=\"爬虫相关\"></a>爬虫相关</h1><p>urllib 、urllib2 、requests</p>\n<p>scrapy： <a href=\"http://link.zhihu.com/?target=http%3A//scrapy.org/\" target=\"_blank\" rel=\"noopener\">scrapy</a></p>\n<p>pyspider： <a href=\"http://link.zhihu.com/?target=https%3A//github.com/binux/pyspider\" target=\"_blank\" rel=\"noopener\">pyspider</a></p>\n<p>portia： <a href=\"http://link.zhihu.com/?target=https%3A//github.com/scrapinghub/portia\" target=\"_blank\" rel=\"noopener\">portia</a></p>\n<p>html2text： <a href=\"http://link.zhihu.com/?target=https%3A//github.com/Alir3z4/html2text\" target=\"_blank\" rel=\"noopener\">html2text</a></p>\n<p>BeautifulSoup： <a href=\"http://link.zhihu.com/?target=https%3A//www.crummy.com/software/BeautifulSoup/\" target=\"_blank\" rel=\"noopener\">BeautifulSoup</a></p>\n<p>lxml： <a href=\"http://link.zhihu.com/?target=http%3A//lxml.de/\" target=\"_blank\" rel=\"noopener\">lxml</a></p>\n<p>selenium：<a href=\"http://link.zhihu.com/?target=http%3A//docs.seleniumhq.org/\" target=\"_blank\" rel=\"noopener\">selenium</a></p>\n<p>mechanize： <a href=\"http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/mechanize\" target=\"_blank\" rel=\"noopener\">mechanize</a></p>\n<p>PyQuery： <a href=\"http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/pyquery/\" target=\"_blank\" rel=\"noopener\">pyquery</a></p>\n<p>creepy： <a href=\"http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/creepy\" target=\"_blank\" rel=\"noopener\">creepy</a></p>\n<h1 id=\"图像处理\"><a href=\"#图像处理\" class=\"headerlink\" title=\"图像处理\"></a>图像处理</h1><p>bigmoyan：<a href=\"http://link.zhihu.com/?target=http%3A//scikit-image.org/\" target=\"_blank\" rel=\"noopener\">scikit-image</a> （感谢<a href=\"http://www.zhihu.com/people/b09b100677c266647b48bc2fe789a36f\" title=\"@BigMoyan\" target=\"_blank\" rel=\"noopener\">@BigMoyan</a> 提供信息）</p>\n<p>Python Imaging Library (PIL)：<a href=\"http://link.zhihu.com/?target=http%3A//www.pythonware.com/products/pil/\" target=\"_blank\" rel=\"noopener\">pil</a></p>\n<p>pillow： <a href=\"http://link.zhihu.com/?target=http%3A//pillow.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener\">pillow</a></p>\n<p>python-qrcode： <a href=\"http://link.zhihu.com/?target=https%3A//github.com/lincolnloop/python-qrcode\" target=\"_blank\" rel=\"noopener\">python-qrcode</a></p>\n<h1 id=\"自然语言处理\"><a href=\"#自然语言处理\" class=\"headerlink\" title=\"自然语言处理\"></a>自然语言处理</h1><p>nltk： <a href=\"http://link.zhihu.com/?target=http%3A//www.nltk.org/\" target=\"_blank\" rel=\"noopener\">nltk </a></p>\n<p>snownlp： <a href=\"http://link.zhihu.com/?target=https%3A//github.com/isnowfy/snownlp\" target=\"_blank\" rel=\"noopener\">snownlp</a></p>\n<p>Pattern：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/clips/pattern\" target=\"_blank\" rel=\"noopener\">pattern</a></p>\n<p>TextBlob：<a href=\"http://link.zhihu.com/?target=http%3A//textblob.readthedocs.org/en/dev/\" target=\"_blank\" rel=\"noopener\">textblob</a></p>\n<p>Polyglot：<a href=\"http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/polyglot\" target=\"_blank\" rel=\"noopener\">polyglot</a></p>\n<p>jieba： <a href=\"http://link.zhihu.com/?target=https%3A//github.com/fxsjy/jieba\" target=\"_blank\" rel=\"noopener\">jieba</a></p>\n<h1 id=\"数据库驱动\"><a href=\"#数据库驱动\" class=\"headerlink\" title=\"数据库驱动\"></a>数据库驱动</h1><p>mysql-python： <a href=\"http://link.zhihu.com/?target=https%3A//sourceforge.net/projects/mysql-python/\" target=\"_blank\" rel=\"noopener\">mysql-python</a></p>\n<p>PyMySQL： <a href=\"http://link.zhihu.com/?target=https%3A//github.com/PyMySQL/PyMySQL\" target=\"_blank\" rel=\"noopener\">PyMySQL</a></p>\n<p>PyMongo： <a href=\"http://link.zhihu.com/?target=https%3A//docs.mongodb.com/ecosystem/drivers/python/\" target=\"_blank\" rel=\"noopener\">PyMongo</a></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://docs.python.org/3.5/library/\" target=\"_blank\" rel=\"noopener\"><img src=\"http://www.alanpro.win/wp-content/uploads/2017/06/python-logo-300x127.png\" alt=\"python logo\"></a></p>\n<h1 id=\"GUI-图形界面\"><a href=\"#GUI-图形界面\" class=\"headerlink\" title=\"GUI 图形界面\"></a>GUI 图形界面</h1><p>Tkinter : <a href=\"http://link.zhihu.com/?target=https%3A//wiki.python.org/moin/TkInter/\" target=\"_blank\" rel=\"noopener\">Tkinter</a></p>\n<p>wxPython: <a href=\"http://link.zhihu.com/?target=https%3A//www.wxpython.org/\" target=\"_blank\" rel=\"noopener\">wxPython</a></p>\n<p>PyGTK: <a href=\"http://link.zhihu.com/?target=http%3A//www.pygtk.org/\" target=\"_blank\" rel=\"noopener\">PyGTK</a></p>\n<p>PyQt: <a href=\"http://link.zhihu.com/?target=https%3A//sourceforge.net/projects/pyqt/\" target=\"_blank\" rel=\"noopener\">PyQt</a></p>\n<p>PySide: <a href=\"http://link.zhihu.com/?target=http%3A//wiki.qt.io/Category%3ALanguageBindings%3A%3APySide\" target=\"_blank\" rel=\"noopener\">PySide</a>","more":"</p>\n<h1 id=\"Web框架\"><a href=\"#Web框架\" class=\"headerlink\" title=\"Web框架\"></a><strong>Web框架</strong></h1><p>django： <a href=\"http://link.zhihu.com/?target=https%3A//www.djangoproject.com/\" target=\"_blank\" rel=\"noopener\">django</a></p>\n<p>web2py：<a href=\"http://link.zhihu.com/?target=http%3A//web2py.com/\" target=\"_blank\" rel=\"noopener\">web2py</a></p>\n<p>flask： <a href=\"http://link.zhihu.com/?target=http%3A//flask.pocoo.org/\" target=\"_blank\" rel=\"noopener\">flask</a></p>\n<p>bottle： <a href=\"http://link.zhihu.com/?target=http%3A//www.bottlepy.org/docs/dev/index.html\" target=\"_blank\" rel=\"noopener\">bottle</a></p>\n<p>tornadoweb ：<a href=\"http://link.zhihu.com/?target=http%3A//www.tornadoweb.org/en/stable/\" target=\"_blank\" rel=\"noopener\">tornadoweb</a></p>\n<p>webpy： <a href=\"http://link.zhihu.com/?target=http%3A//webpy.org/\" target=\"_blank\" rel=\"noopener\">webpy</a></p>\n<p>cherrypy： <a href=\"http://link.zhihu.com/?target=http%3A//www.cherrypy.org/\" target=\"_blank\" rel=\"noopener\">cherrypy</a></p>\n<p>jinjs： <a href=\"http://link.zhihu.com/?target=http%3A//docs.jinkan.org/docs/jinja2/\" target=\"_blank\" rel=\"noopener\">jinja</a></p>\n<h1 id=\"科学计算\"><a href=\"#科学计算\" class=\"headerlink\" title=\"科学计算\"></a>科学计算</h1><p>numpy： <a href=\"http://link.zhihu.com/?target=http%3A//www.numpy.org/\" target=\"_blank\" rel=\"noopener\">numpy</a></p>\n<p>SciPy：<a href=\"http://link.zhihu.com/?target=http%3A//www.scipy.org/\" target=\"_blank\" rel=\"noopener\">scipy</a></p>\n<p>pandas： <a href=\"http://link.zhihu.com/?target=http%3A//pandas.pydata.org/\" target=\"_blank\" rel=\"noopener\">pandas</a></p>\n<p>blaze： <a href=\"http://link.zhihu.com/?target=http%3A//blaze.readthedocs.io/en/latest/index.html\" target=\"_blank\" rel=\"noopener\">blaze</a></p>\n<h1 id=\"密码学\"><a href=\"#密码学\" class=\"headerlink\" title=\"密码学\"></a>密码学</h1><p>cryptography：<a href=\"http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/cryptography/\" target=\"_blank\" rel=\"noopener\">cryptography</a></p>\n<p>hashids：<a href=\"http://link.zhihu.com/?target=http%3A//www.oschina.net/p/hashids\" target=\"_blank\" rel=\"noopener\">hashids</a></p>\n<p>Paramiko：<a href=\"http://link.zhihu.com/?target=http%3A//www.paramiko.org/\" target=\"_blank\" rel=\"noopener\">Paramiko</a></p>\n<p>Passlib：<a href=\"http://link.zhihu.com/?target=https%3A//pythonhosted.org/passlib/\" target=\"_blank\" rel=\"noopener\">Passlib</a></p>\n<p>PyCrypto：<a href=\"http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/pycrypto\" target=\"_blank\" rel=\"noopener\">PyCrypto</a></p>\n<p>PyNacl：<a href=\"http://link.zhihu.com/?target=http%3A//pynacl.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener\">PyNacl</a></p>\n<h1 id=\"爬虫相关\"><a href=\"#爬虫相关\" class=\"headerlink\" title=\"爬虫相关\"></a>爬虫相关</h1><p>urllib 、urllib2 、requests</p>\n<p>scrapy： <a href=\"http://link.zhihu.com/?target=http%3A//scrapy.org/\" target=\"_blank\" rel=\"noopener\">scrapy</a></p>\n<p>pyspider： <a href=\"http://link.zhihu.com/?target=https%3A//github.com/binux/pyspider\" target=\"_blank\" rel=\"noopener\">pyspider</a></p>\n<p>portia： <a href=\"http://link.zhihu.com/?target=https%3A//github.com/scrapinghub/portia\" target=\"_blank\" rel=\"noopener\">portia</a></p>\n<p>html2text： <a href=\"http://link.zhihu.com/?target=https%3A//github.com/Alir3z4/html2text\" target=\"_blank\" rel=\"noopener\">html2text</a></p>\n<p>BeautifulSoup： <a href=\"http://link.zhihu.com/?target=https%3A//www.crummy.com/software/BeautifulSoup/\" target=\"_blank\" rel=\"noopener\">BeautifulSoup</a></p>\n<p>lxml： <a href=\"http://link.zhihu.com/?target=http%3A//lxml.de/\" target=\"_blank\" rel=\"noopener\">lxml</a></p>\n<p>selenium：<a href=\"http://link.zhihu.com/?target=http%3A//docs.seleniumhq.org/\" target=\"_blank\" rel=\"noopener\">selenium</a></p>\n<p>mechanize： <a href=\"http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/mechanize\" target=\"_blank\" rel=\"noopener\">mechanize</a></p>\n<p>PyQuery： <a href=\"http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/pyquery/\" target=\"_blank\" rel=\"noopener\">pyquery</a></p>\n<p>creepy： <a href=\"http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/creepy\" target=\"_blank\" rel=\"noopener\">creepy</a></p>\n<h1 id=\"图像处理\"><a href=\"#图像处理\" class=\"headerlink\" title=\"图像处理\"></a>图像处理</h1><p>bigmoyan：<a href=\"http://link.zhihu.com/?target=http%3A//scikit-image.org/\" target=\"_blank\" rel=\"noopener\">scikit-image</a> （感谢<a href=\"http://www.zhihu.com/people/b09b100677c266647b48bc2fe789a36f\" title=\"@BigMoyan\" target=\"_blank\" rel=\"noopener\">@BigMoyan</a> 提供信息）</p>\n<p>Python Imaging Library (PIL)：<a href=\"http://link.zhihu.com/?target=http%3A//www.pythonware.com/products/pil/\" target=\"_blank\" rel=\"noopener\">pil</a></p>\n<p>pillow： <a href=\"http://link.zhihu.com/?target=http%3A//pillow.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener\">pillow</a></p>\n<p>python-qrcode： <a href=\"http://link.zhihu.com/?target=https%3A//github.com/lincolnloop/python-qrcode\" target=\"_blank\" rel=\"noopener\">python-qrcode</a></p>\n<h1 id=\"自然语言处理\"><a href=\"#自然语言处理\" class=\"headerlink\" title=\"自然语言处理\"></a>自然语言处理</h1><p>nltk： <a href=\"http://link.zhihu.com/?target=http%3A//www.nltk.org/\" target=\"_blank\" rel=\"noopener\">nltk </a></p>\n<p>snownlp： <a href=\"http://link.zhihu.com/?target=https%3A//github.com/isnowfy/snownlp\" target=\"_blank\" rel=\"noopener\">snownlp</a></p>\n<p>Pattern：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/clips/pattern\" target=\"_blank\" rel=\"noopener\">pattern</a></p>\n<p>TextBlob：<a href=\"http://link.zhihu.com/?target=http%3A//textblob.readthedocs.org/en/dev/\" target=\"_blank\" rel=\"noopener\">textblob</a></p>\n<p>Polyglot：<a href=\"http://link.zhihu.com/?target=https%3A//pypi.python.org/pypi/polyglot\" target=\"_blank\" rel=\"noopener\">polyglot</a></p>\n<p>jieba： <a href=\"http://link.zhihu.com/?target=https%3A//github.com/fxsjy/jieba\" target=\"_blank\" rel=\"noopener\">jieba</a></p>\n<h1 id=\"数据库驱动\"><a href=\"#数据库驱动\" class=\"headerlink\" title=\"数据库驱动\"></a>数据库驱动</h1><p>mysql-python： <a href=\"http://link.zhihu.com/?target=https%3A//sourceforge.net/projects/mysql-python/\" target=\"_blank\" rel=\"noopener\">mysql-python</a></p>\n<p>PyMySQL： <a href=\"http://link.zhihu.com/?target=https%3A//github.com/PyMySQL/PyMySQL\" target=\"_blank\" rel=\"noopener\">PyMySQL</a></p>\n<p>PyMongo： <a href=\"http://link.zhihu.com/?target=https%3A//docs.mongodb.com/ecosystem/drivers/python/\" target=\"_blank\" rel=\"noopener\">PyMongo</a></p>"},{"title":"为什么vector不能存引用？","id":"319","date":"2017-08-23T07:17:05.000Z","_content":"\n# 为什么vector不能存引用？\n\n标签（空格分隔）： c++/reference CN-5th\n\n* * *\n\n遇到了这样一段代码：编译器却报错\n`\ntemplate<typename T>\n    void f(T &&t){\n    vector<T> v;\n}\nint main(){\n    int a = 10;\n    f(a);\n    return 0;\n}\n`\na是一个左值，当左值传递给模板参数是右值的模板函数时，T被推断为T&amp;,也就是说T是int&amp;。那么为什么vector容器不能存引用呢？\n答：容器的元素必须是可以分配空间的元素，而引用是在初始化的时候绑定在变量上的，而且不能让它们引用到别的对象上去。同理可得：const int类型的变量（即not-assignable的变量）都不能放在此类容器中的。\n\nreference to:[discuss in SO](https://stackoverflow.com/questions/922360/why-cant-i-make-a-vector-of-references)<code>","source":"_posts/why-vector-cannot-store-reference.md","raw":"---\ntitle: 为什么vector不能存引用？\nid: 319\ncategories:\n  - c++学习\ndate: 2017-08-23 15:17:05\ntags:\n---\n\n# 为什么vector不能存引用？\n\n标签（空格分隔）： c++/reference CN-5th\n\n* * *\n\n遇到了这样一段代码：编译器却报错\n`\ntemplate<typename T>\n    void f(T &&t){\n    vector<T> v;\n}\nint main(){\n    int a = 10;\n    f(a);\n    return 0;\n}\n`\na是一个左值，当左值传递给模板参数是右值的模板函数时，T被推断为T&amp;,也就是说T是int&amp;。那么为什么vector容器不能存引用呢？\n答：容器的元素必须是可以分配空间的元素，而引用是在初始化的时候绑定在变量上的，而且不能让它们引用到别的对象上去。同理可得：const int类型的变量（即not-assignable的变量）都不能放在此类容器中的。\n\nreference to:[discuss in SO](https://stackoverflow.com/questions/922360/why-cant-i-make-a-vector-of-references)<code>","slug":"why-vector-cannot-store-reference","published":1,"updated":"2017-12-09T17:06:50.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec2k003ciwtwns28efdn","content":"<h1 id=\"为什么vector不能存引用？\"><a href=\"#为什么vector不能存引用？\" class=\"headerlink\" title=\"为什么vector不能存引用？\"></a>为什么vector不能存引用？</h1><p>标签（空格分隔）： c++/reference CN-5th</p>\n<hr>\n<p>遇到了这样一段代码：编译器却报错<br><code>template&lt;typename T&gt;\n    void f(T &amp;&amp;t){\n    vector&lt;T&gt; v;\n}\nint main(){\n    int a = 10;\n    f(a);\n    return 0;\n}</code><br>a是一个左值，当左值传递给模板参数是右值的模板函数时，T被推断为T&amp;,也就是说T是int&amp;。那么为什么vector容器不能存引用呢？<br>答：容器的元素必须是可以分配空间的元素，而引用是在初始化的时候绑定在变量上的，而且不能让它们引用到别的对象上去。同理可得：const int类型的变量（即not-assignable的变量）都不能放在此类容器中的。</p>\n<p>reference to:<a href=\"https://stackoverflow.com/questions/922360/why-cant-i-make-a-vector-of-references\" target=\"_blank\" rel=\"noopener\">discuss in SO</a><code></code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么vector不能存引用？\"><a href=\"#为什么vector不能存引用？\" class=\"headerlink\" title=\"为什么vector不能存引用？\"></a>为什么vector不能存引用？</h1><p>标签（空格分隔）： c++/reference CN-5th</p>\n<hr>\n<p>遇到了这样一段代码：编译器却报错<br><code>template&lt;typename T&gt;\n    void f(T &amp;&amp;t){\n    vector&lt;T&gt; v;\n}\nint main(){\n    int a = 10;\n    f(a);\n    return 0;\n}</code><br>a是一个左值，当左值传递给模板参数是右值的模板函数时，T被推断为T&amp;,也就是说T是int&amp;。那么为什么vector容器不能存引用呢？<br>答：容器的元素必须是可以分配空间的元素，而引用是在初始化的时候绑定在变量上的，而且不能让它们引用到别的对象上去。同理可得：const int类型的变量（即not-assignable的变量）都不能放在此类容器中的。</p>\n<p>reference to:<a href=\"https://stackoverflow.com/questions/922360/why-cant-i-make-a-vector-of-references\" target=\"_blank\" rel=\"noopener\">discuss in SO</a><code></code></p>\n"},{"title":"解决ubuntu E: 无法获得锁 /var/lib/apt/lists/lock - open (11: 资源暂时不可用)","id":"206","date":"2017-07-11T11:02:32.000Z","_content":"\n原文来自[http://blog.chinaunix.net/uid-20769200-id-3404207.html](http://blog.chinaunix.net/uid-20769200-id-3404207.html)\n\n今天使用apt-get update 出现\n\nE: 无法获得锁 /var/lib/apt/lists/lock - open (11: 资源暂时不可用)\nE: 无法对目录 /var/lib/apt/lists/ 加锁\n第一次发现，不明原因。问度娘<!--more-->\n<div id=\"content\" class=\"content mod-cs-content text-content clearfix\">在网上搜索到的解决方案──“将/var/lib/apt/list/lock删除掉即可”──其实是一种极端的情况，也就是在上次更新没有正常关闭的情况下使用。\n在大部分情况下，问题的原因在于其它的程序如系统的自动更新、新立得等正在使用apt-get进程，所以解决方法也就是将这一进程关闭。\n具体如下：\n1、ps -aux 查出apt-get进程的PID，通常是一个四位数字。\n2、用kill PID代码 杀死进程\n3、用apt-get update，sudo apt-get dist-upgrade升级。方法一：\n执行一下 sudo dpkg --configure -a\n方法二：\nsudo rm /var/lib/apt/lists/lock\n方法三：\n1、ps -aux 查出apt-get进程的PID,\n2、用sudo kill PID代码 杀死进程(我都是找出带apt字样的进程格杀勿论)</div>\n我是用的方法三解决了","source":"_posts/resolve ubuntu cannot get lock.md","raw":"---\ntitle: '解决ubuntu E: 无法获得锁 /var/lib/apt/lists/lock - open (11: 资源暂时不可用)'\ntags:\n  - 小问题\nid: 206\ncategories:\n  - 操作系统\ndate: 2017-07-11 19:02:32\n---\n\n原文来自[http://blog.chinaunix.net/uid-20769200-id-3404207.html](http://blog.chinaunix.net/uid-20769200-id-3404207.html)\n\n今天使用apt-get update 出现\n\nE: 无法获得锁 /var/lib/apt/lists/lock - open (11: 资源暂时不可用)\nE: 无法对目录 /var/lib/apt/lists/ 加锁\n第一次发现，不明原因。问度娘<!--more-->\n<div id=\"content\" class=\"content mod-cs-content text-content clearfix\">在网上搜索到的解决方案──“将/var/lib/apt/list/lock删除掉即可”──其实是一种极端的情况，也就是在上次更新没有正常关闭的情况下使用。\n在大部分情况下，问题的原因在于其它的程序如系统的自动更新、新立得等正在使用apt-get进程，所以解决方法也就是将这一进程关闭。\n具体如下：\n1、ps -aux 查出apt-get进程的PID，通常是一个四位数字。\n2、用kill PID代码 杀死进程\n3、用apt-get update，sudo apt-get dist-upgrade升级。方法一：\n执行一下 sudo dpkg --configure -a\n方法二：\nsudo rm /var/lib/apt/lists/lock\n方法三：\n1、ps -aux 查出apt-get进程的PID,\n2、用sudo kill PID代码 杀死进程(我都是找出带apt字样的进程格杀勿论)</div>\n我是用的方法三解决了","slug":"resolve ubuntu cannot get lock","published":1,"updated":"2017-12-09T17:06:50.786Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec2m003fiwtw4cxvh4gi","content":"<p>原文来自<a href=\"http://blog.chinaunix.net/uid-20769200-id-3404207.html\" target=\"_blank\" rel=\"noopener\">http://blog.chinaunix.net/uid-20769200-id-3404207.html</a></p>\n<p>今天使用apt-get update 出现</p>\n<p>E: 无法获得锁 /var/lib/apt/lists/lock - open (11: 资源暂时不可用)<br>E: 无法对目录 /var/lib/apt/lists/ 加锁<br>第一次发现，不明原因。问度娘<a id=\"more\"></a></p>\n<p><div id=\"content\" class=\"content mod-cs-content text-content clearfix\">在网上搜索到的解决方案──“将/var/lib/apt/list/lock删除掉即可”──其实是一种极端的情况，也就是在上次更新没有正常关闭的情况下使用。<br>在大部分情况下，问题的原因在于其它的程序如系统的自动更新、新立得等正在使用apt-get进程，所以解决方法也就是将这一进程关闭。<br>具体如下：<br>1、ps -aux 查出apt-get进程的PID，通常是一个四位数字。<br>2、用kill PID代码 杀死进程<br>3、用apt-get update，sudo apt-get dist-upgrade升级。方法一：<br>执行一下 sudo dpkg –configure -a<br>方法二：<br>sudo rm /var/lib/apt/lists/lock<br>方法三：<br>1、ps -aux 查出apt-get进程的PID,<br>2、用sudo kill PID代码 杀死进程(我都是找出带apt字样的进程格杀勿论)</div><br>我是用的方法三解决了</p>\n","site":{"data":{}},"excerpt":"<p>原文来自<a href=\"http://blog.chinaunix.net/uid-20769200-id-3404207.html\" target=\"_blank\" rel=\"noopener\">http://blog.chinaunix.net/uid-20769200-id-3404207.html</a></p>\n<p>今天使用apt-get update 出现</p>\n<p>E: 无法获得锁 /var/lib/apt/lists/lock - open (11: 资源暂时不可用)<br>E: 无法对目录 /var/lib/apt/lists/ 加锁<br>第一次发现，不明原因。问度娘","more":"</p>\n<p><div id=\"content\" class=\"content mod-cs-content text-content clearfix\">在网上搜索到的解决方案──“将/var/lib/apt/list/lock删除掉即可”──其实是一种极端的情况，也就是在上次更新没有正常关闭的情况下使用。<br>在大部分情况下，问题的原因在于其它的程序如系统的自动更新、新立得等正在使用apt-get进程，所以解决方法也就是将这一进程关闭。<br>具体如下：<br>1、ps -aux 查出apt-get进程的PID，通常是一个四位数字。<br>2、用kill PID代码 杀死进程<br>3、用apt-get update，sudo apt-get dist-upgrade升级。方法一：<br>执行一下 sudo dpkg –configure -a<br>方法二：<br>sudo rm /var/lib/apt/lists/lock<br>方法三：<br>1、ps -aux 查出apt-get进程的PID,<br>2、用sudo kill PID代码 杀死进程(我都是找出带apt字样的进程格杀勿论)</div><br>我是用的方法三解决了</p>"},{"title":"linux下常用的命令","id":"285","date":"2017-08-07T04:42:06.000Z","_content":"\n查看机器是64位还是32  ：sudo uname --m\n\nsudo uname --s  显示内核名字s\n\nsudo uname --r 显示内核版本\n\nsudo uname --n 显示网络主机名\n\nsudo uname --p 显示cpu <!--more-->\n\n关闭笔记本触摸板：sudo modprobe -r psmouse\n\ncentos下默认的下载工具是yum而不是apt，不过使用方法是差不多的\n\n&nbsp;\n\n## linux下新建用户:\n\nuseradd [-d home] [-s shell] [-c comment] [-m [-k template]] [-f inactive] [-e expire ] [-p passwd] [-r] name\n\n（-d：指定用户登入时的主目录，替换系统默认值/home/&lt;用户名&gt;）\n可以在/etc/group里查看有哪些用户，切换到root用户下，用passwd username来给刚创建的用户设置密码。\n\n&nbsp;\n\n在远程服务器中登录的时候是以root的用户登录的，我新建了一个名为yanhui的用户，想用sudo apt-get install xxx安装软件的时候，被告知：yanhui 不在sudoers文件中。此事将被报告。\n先来说说sudo：sudo命令可以让你用root的身份执行命令，来完成这个用户完成不了的高权限任务。其实并非所有用户都能执行sudo，因为有权限的用户都在/etc/sudoers，使这些用户可以通过sudo命令来暂时获取root的权限。\n\n现在要让yanhui用户获得sudo使用权\n1.切换到超级用户root\n$su root\n2.查看/etc/sudoers权限，可以看到当前权限为440\n$ ls -all /etc/sudoers\n-r--r----- 1 root root 744 6月 8 10:29 /etc/sudoers\n3.更改权限为777\n$chmod 777 /etc/sudoers\n4.编辑/etc/sudoers\n$vi /etc/sudoers\n5.在root ALL=(ALL:ALL) ALL 下面添加一行\nyanhui ALL=(ALL)ALL\n然后保存退出。\n第一个ALL是指网络中的主机，我们后面把它改成了主机名，它指明jack可以在此主机上执行后面的命令。\n第二个括号里的ALL是指目标用户，也就是以谁的身份去执行命令。\n最后一个ALL当然就是指命令名了。\n具体这里不作说明\n\nesc wq!\n6.把/etc/sudoers权限改回440\n$chmod 440 /etc/sudoers\n\n7.操作完成，切换到yanhui用户测试一下。测试成功，权限更改完毕\n\n&nbsp;\n\nubuntu16上安装mysql：sudo apt-get install mysql-client mysql-server","source":"_posts/ubuntu-e4-b8-8b-e5-b8-b8-e7-94-a8-e7-9a-84-e5-91-bd-e4-bb-a4-e8-ae-b0-e5-bd-95.md","raw":"---\ntitle: linux下常用的命令\nid: 285\ncategories:\n  - 工具们\n  - 操作系统\ndate: 2017-08-07 12:42:06\ntags:\n---\n\n查看机器是64位还是32  ：sudo uname --m\n\nsudo uname --s  显示内核名字s\n\nsudo uname --r 显示内核版本\n\nsudo uname --n 显示网络主机名\n\nsudo uname --p 显示cpu <!--more-->\n\n关闭笔记本触摸板：sudo modprobe -r psmouse\n\ncentos下默认的下载工具是yum而不是apt，不过使用方法是差不多的\n\n&nbsp;\n\n## linux下新建用户:\n\nuseradd [-d home] [-s shell] [-c comment] [-m [-k template]] [-f inactive] [-e expire ] [-p passwd] [-r] name\n\n（-d：指定用户登入时的主目录，替换系统默认值/home/&lt;用户名&gt;）\n可以在/etc/group里查看有哪些用户，切换到root用户下，用passwd username来给刚创建的用户设置密码。\n\n&nbsp;\n\n在远程服务器中登录的时候是以root的用户登录的，我新建了一个名为yanhui的用户，想用sudo apt-get install xxx安装软件的时候，被告知：yanhui 不在sudoers文件中。此事将被报告。\n先来说说sudo：sudo命令可以让你用root的身份执行命令，来完成这个用户完成不了的高权限任务。其实并非所有用户都能执行sudo，因为有权限的用户都在/etc/sudoers，使这些用户可以通过sudo命令来暂时获取root的权限。\n\n现在要让yanhui用户获得sudo使用权\n1.切换到超级用户root\n$su root\n2.查看/etc/sudoers权限，可以看到当前权限为440\n$ ls -all /etc/sudoers\n-r--r----- 1 root root 744 6月 8 10:29 /etc/sudoers\n3.更改权限为777\n$chmod 777 /etc/sudoers\n4.编辑/etc/sudoers\n$vi /etc/sudoers\n5.在root ALL=(ALL:ALL) ALL 下面添加一行\nyanhui ALL=(ALL)ALL\n然后保存退出。\n第一个ALL是指网络中的主机，我们后面把它改成了主机名，它指明jack可以在此主机上执行后面的命令。\n第二个括号里的ALL是指目标用户，也就是以谁的身份去执行命令。\n最后一个ALL当然就是指命令名了。\n具体这里不作说明\n\nesc wq!\n6.把/etc/sudoers权限改回440\n$chmod 440 /etc/sudoers\n\n7.操作完成，切换到yanhui用户测试一下。测试成功，权限更改完毕\n\n&nbsp;\n\nubuntu16上安装mysql：sudo apt-get install mysql-client mysql-server","slug":"ubuntu-e4-b8-8b-e5-b8-b8-e7-94-a8-e7-9a-84-e5-91-bd-e4-bb-a4-e8-ae-b0-e5-bd-95","published":1,"updated":"2017-12-09T17:06:50.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec2p003jiwtwc94ddwek","content":"<p>查看机器是64位还是32  ：sudo uname –m</p>\n<p>sudo uname –s  显示内核名字s</p>\n<p>sudo uname –r 显示内核版本</p>\n<p>sudo uname –n 显示网络主机名</p>\n<p>sudo uname –p 显示cpu <a id=\"more\"></a></p>\n<p>关闭笔记本触摸板：sudo modprobe -r psmouse</p>\n<p>centos下默认的下载工具是yum而不是apt，不过使用方法是差不多的</p>\n<p>&nbsp;</p>\n<h2 id=\"linux下新建用户\"><a href=\"#linux下新建用户\" class=\"headerlink\" title=\"linux下新建用户:\"></a>linux下新建用户:</h2><p>useradd [-d home] [-s shell] [-c comment] [-m [-k template]] [-f inactive] [-e expire ] [-p passwd] [-r] name</p>\n<p>（-d：指定用户登入时的主目录，替换系统默认值/home/&lt;用户名&gt;）<br>可以在/etc/group里查看有哪些用户，切换到root用户下，用passwd username来给刚创建的用户设置密码。</p>\n<p>&nbsp;</p>\n<p>在远程服务器中登录的时候是以root的用户登录的，我新建了一个名为yanhui的用户，想用sudo apt-get install xxx安装软件的时候，被告知：yanhui 不在sudoers文件中。此事将被报告。<br>先来说说sudo：sudo命令可以让你用root的身份执行命令，来完成这个用户完成不了的高权限任务。其实并非所有用户都能执行sudo，因为有权限的用户都在/etc/sudoers，使这些用户可以通过sudo命令来暂时获取root的权限。</p>\n<p>现在要让yanhui用户获得sudo使用权<br>1.切换到超级用户root<br>$su root<br>2.查看/etc/sudoers权限，可以看到当前权限为440<br>$ ls -all /etc/sudoers<br>-r–r—– 1 root root 744 6月 8 10:29 /etc/sudoers<br>3.更改权限为777<br>$chmod 777 /etc/sudoers<br>4.编辑/etc/sudoers<br>$vi /etc/sudoers<br>5.在root ALL=(ALL:ALL) ALL 下面添加一行<br>yanhui ALL=(ALL)ALL<br>然后保存退出。<br>第一个ALL是指网络中的主机，我们后面把它改成了主机名，它指明jack可以在此主机上执行后面的命令。<br>第二个括号里的ALL是指目标用户，也就是以谁的身份去执行命令。<br>最后一个ALL当然就是指命令名了。<br>具体这里不作说明</p>\n<p>esc wq!<br>6.把/etc/sudoers权限改回440<br>$chmod 440 /etc/sudoers</p>\n<p>7.操作完成，切换到yanhui用户测试一下。测试成功，权限更改完毕</p>\n<p>&nbsp;</p>\n<p>ubuntu16上安装mysql：sudo apt-get install mysql-client mysql-server</p>\n","site":{"data":{}},"excerpt":"<p>查看机器是64位还是32  ：sudo uname –m</p>\n<p>sudo uname –s  显示内核名字s</p>\n<p>sudo uname –r 显示内核版本</p>\n<p>sudo uname –n 显示网络主机名</p>\n<p>sudo uname –p 显示cpu","more":"</p>\n<p>关闭笔记本触摸板：sudo modprobe -r psmouse</p>\n<p>centos下默认的下载工具是yum而不是apt，不过使用方法是差不多的</p>\n<p>&nbsp;</p>\n<h2 id=\"linux下新建用户\"><a href=\"#linux下新建用户\" class=\"headerlink\" title=\"linux下新建用户:\"></a>linux下新建用户:</h2><p>useradd [-d home] [-s shell] [-c comment] [-m [-k template]] [-f inactive] [-e expire ] [-p passwd] [-r] name</p>\n<p>（-d：指定用户登入时的主目录，替换系统默认值/home/&lt;用户名&gt;）<br>可以在/etc/group里查看有哪些用户，切换到root用户下，用passwd username来给刚创建的用户设置密码。</p>\n<p>&nbsp;</p>\n<p>在远程服务器中登录的时候是以root的用户登录的，我新建了一个名为yanhui的用户，想用sudo apt-get install xxx安装软件的时候，被告知：yanhui 不在sudoers文件中。此事将被报告。<br>先来说说sudo：sudo命令可以让你用root的身份执行命令，来完成这个用户完成不了的高权限任务。其实并非所有用户都能执行sudo，因为有权限的用户都在/etc/sudoers，使这些用户可以通过sudo命令来暂时获取root的权限。</p>\n<p>现在要让yanhui用户获得sudo使用权<br>1.切换到超级用户root<br>$su root<br>2.查看/etc/sudoers权限，可以看到当前权限为440<br>$ ls -all /etc/sudoers<br>-r–r—– 1 root root 744 6月 8 10:29 /etc/sudoers<br>3.更改权限为777<br>$chmod 777 /etc/sudoers<br>4.编辑/etc/sudoers<br>$vi /etc/sudoers<br>5.在root ALL=(ALL:ALL) ALL 下面添加一行<br>yanhui ALL=(ALL)ALL<br>然后保存退出。<br>第一个ALL是指网络中的主机，我们后面把它改成了主机名，它指明jack可以在此主机上执行后面的命令。<br>第二个括号里的ALL是指目标用户，也就是以谁的身份去执行命令。<br>最后一个ALL当然就是指命令名了。<br>具体这里不作说明</p>\n<p>esc wq!<br>6.把/etc/sudoers权限改回440<br>$chmod 440 /etc/sudoers</p>\n<p>7.操作完成，切换到yanhui用户测试一下。测试成功，权限更改完毕</p>\n<p>&nbsp;</p>\n<p>ubuntu16上安装mysql：sudo apt-get install mysql-client mysql-server</p>"},{"title":"ubuntu用shadowsocks科学上网完全教程","id":"210","date":"2017-07-11T12:36:20.000Z","_content":"\n声明：科学文明上网，本文只分享技术，请自行承担后果\n\n前言：\n\n之前一直使用Windows做学习的，这段时间在学git和python，于是在笔记本上划了50G空间又装了个Ubuntu16.04 LTS，之前之前在别的机器和虚拟机上尝试过安装shadowsocks QT5的客户端，但是尝试过几次都没有成功番羽墙成功。这次用了好久来找博客，终于成功。以下是我的步骤：<!--more-->\n\n1.  shadowsocks是目前比较稳定的代理方式，首先你要有一台代理服务器（vps），或者买一个shadowsocks账号。这个步骤在网上一搜一大把\n2.  安装Shadowsock客户端，我用的是shadowsocks-qt5，因为是图形界面版，便于管理\n\n    *   在终端(ctrl+alt+t) 中依次输入（直接粘贴复制）三个步骤（分别是：添加源-&gt;更新源-&gt;安装）：\n    *   sudo add-apt-repository ppa:hzwhuang/ss-qt5\n    *   sudo apt-get update\n    *   sudo apt-get install shadowsocks-qt5\n\n3.  设置代理服务\n\n    *   ![](http://www.alanpro.win/wp-content/uploads/2017/07/2-16060915030H59.jpg)打开软件shadowsocks-qt5\n    *   ![](http://www.alanpro.win/wp-content/uploads/2017/07/2-16060915031J37.jpg)连接-&gt;添加-&gt;手动 添加配置信息\n    *   填写服务器地址，服务器端口，密钥，加密方式，其他的默认即可，配置名称随便写，点击OK\n    *   点击连接即可开启服务，如果报错请检查上一步填写的信息是否有误，或者你的代理服务器是否正常服务\n\n4.  至此，shadowsocks已经配置完成，接下来设置全局代理，以下两步是准备工具：\n\n    1.  安装pip：(upgrade前的横线是两个短横线-，直接复制会出错)\n\n            *   <div>sudo apt-get install python-pip python-dev build-essential</div>\n<div>sudo pip install --upgrade pip</div>\n<div>sudo pip install --upgrade virtualenv</div>\n\n        2.  安装GenPAC：\n\n            *   <div>sudo pip install genpac</div>\n<div>sudo pip install --upgrade genpac</div>\n\n        3.  现在要下载一个文件，首先cd命令进入到你想存放文件的目录，比如:cd /home/yanhui\n    4.  执行下面命令：\n\n            *   sudo genpac --proxy=\"SOCKS5 127.0.0.1:1080\" --gfwlist-proxy=\"SOCKS5 127.0.0.1:1080\" -o autoproxy.pac --gfwlist-url=\"https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt\"\n\n        5.  现在在/home/yanhui的目录下生成了一个autoproxy.pac的文件\n    6.  设置全局代理：\n\n            1.  系统设置-&gt;网络-&gt;网络代理\n        2.  方法选择“自动”\n        3.  配置url填写：file:///home/yanhui/autoproxy.pac\n        4.  点击应用到整个系统\n\n        7.  用google来测试是否成功","source":"_posts/ubuntu-e7-94-a8shadowsocks-e7-a7-91-e5-ad-a6-e4-b8-8a-e7-bd-91-e5-ae-8c-e5-85-a8-e6-95-99-e7-a8-8b.md","raw":"---\ntitle: ubuntu用shadowsocks科学上网完全教程\ntags:\n  - 小问题\nid: 210\ncategories:\n  - 工具们\ndate: 2017-07-11 20:36:20\n---\n\n声明：科学文明上网，本文只分享技术，请自行承担后果\n\n前言：\n\n之前一直使用Windows做学习的，这段时间在学git和python，于是在笔记本上划了50G空间又装了个Ubuntu16.04 LTS，之前之前在别的机器和虚拟机上尝试过安装shadowsocks QT5的客户端，但是尝试过几次都没有成功番羽墙成功。这次用了好久来找博客，终于成功。以下是我的步骤：<!--more-->\n\n1.  shadowsocks是目前比较稳定的代理方式，首先你要有一台代理服务器（vps），或者买一个shadowsocks账号。这个步骤在网上一搜一大把\n2.  安装Shadowsock客户端，我用的是shadowsocks-qt5，因为是图形界面版，便于管理\n\n    *   在终端(ctrl+alt+t) 中依次输入（直接粘贴复制）三个步骤（分别是：添加源-&gt;更新源-&gt;安装）：\n    *   sudo add-apt-repository ppa:hzwhuang/ss-qt5\n    *   sudo apt-get update\n    *   sudo apt-get install shadowsocks-qt5\n\n3.  设置代理服务\n\n    *   ![](http://www.alanpro.win/wp-content/uploads/2017/07/2-16060915030H59.jpg)打开软件shadowsocks-qt5\n    *   ![](http://www.alanpro.win/wp-content/uploads/2017/07/2-16060915031J37.jpg)连接-&gt;添加-&gt;手动 添加配置信息\n    *   填写服务器地址，服务器端口，密钥，加密方式，其他的默认即可，配置名称随便写，点击OK\n    *   点击连接即可开启服务，如果报错请检查上一步填写的信息是否有误，或者你的代理服务器是否正常服务\n\n4.  至此，shadowsocks已经配置完成，接下来设置全局代理，以下两步是准备工具：\n\n    1.  安装pip：(upgrade前的横线是两个短横线-，直接复制会出错)\n\n            *   <div>sudo apt-get install python-pip python-dev build-essential</div>\n<div>sudo pip install --upgrade pip</div>\n<div>sudo pip install --upgrade virtualenv</div>\n\n        2.  安装GenPAC：\n\n            *   <div>sudo pip install genpac</div>\n<div>sudo pip install --upgrade genpac</div>\n\n        3.  现在要下载一个文件，首先cd命令进入到你想存放文件的目录，比如:cd /home/yanhui\n    4.  执行下面命令：\n\n            *   sudo genpac --proxy=\"SOCKS5 127.0.0.1:1080\" --gfwlist-proxy=\"SOCKS5 127.0.0.1:1080\" -o autoproxy.pac --gfwlist-url=\"https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt\"\n\n        5.  现在在/home/yanhui的目录下生成了一个autoproxy.pac的文件\n    6.  设置全局代理：\n\n            1.  系统设置-&gt;网络-&gt;网络代理\n        2.  方法选择“自动”\n        3.  配置url填写：file:///home/yanhui/autoproxy.pac\n        4.  点击应用到整个系统\n\n        7.  用google来测试是否成功","slug":"ubuntu-e7-94-a8shadowsocks-e7-a7-91-e5-ad-a6-e4-b8-8a-e7-bd-91-e5-ae-8c-e5-85-a8-e6-95-99-e7-a8-8b","published":1,"updated":"2017-12-09T17:06:50.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec2r003miwtw0u6zhwsb","content":"<p>声明：科学文明上网，本文只分享技术，请自行承担后果</p>\n<p>前言：</p>\n<p>之前一直使用Windows做学习的，这段时间在学git和python，于是在笔记本上划了50G空间又装了个Ubuntu16.04 LTS，之前之前在别的机器和虚拟机上尝试过安装shadowsocks QT5的客户端，但是尝试过几次都没有成功番羽墙成功。这次用了好久来找博客，终于成功。以下是我的步骤：<a id=\"more\"></a></p>\n<ol>\n<li>shadowsocks是目前比较稳定的代理方式，首先你要有一台代理服务器（vps），或者买一个shadowsocks账号。这个步骤在网上一搜一大把</li>\n<li><p>安装Shadowsock客户端，我用的是shadowsocks-qt5，因为是图形界面版，便于管理</p>\n<ul>\n<li>在终端(ctrl+alt+t) 中依次输入（直接粘贴复制）三个步骤（分别是：添加源-&gt;更新源-&gt;安装）：</li>\n<li>sudo add-apt-repository ppa:hzwhuang/ss-qt5</li>\n<li>sudo apt-get update</li>\n<li>sudo apt-get install shadowsocks-qt5</li>\n</ul>\n</li>\n<li><p>设置代理服务</p>\n<ul>\n<li><img src=\"http://www.alanpro.win/wp-content/uploads/2017/07/2-16060915030H59.jpg\" alt=\"\">打开软件shadowsocks-qt5</li>\n<li><img src=\"http://www.alanpro.win/wp-content/uploads/2017/07/2-16060915031J37.jpg\" alt=\"\">连接-&gt;添加-&gt;手动 添加配置信息</li>\n<li>填写服务器地址，服务器端口，密钥，加密方式，其他的默认即可，配置名称随便写，点击OK</li>\n<li>点击连接即可开启服务，如果报错请检查上一步填写的信息是否有误，或者你的代理服务器是否正常服务</li>\n</ul>\n</li>\n<li><p>至此，shadowsocks已经配置完成，接下来设置全局代理，以下两步是准备工具：</p>\n<ol>\n<li><p>安装pip：(upgrade前的横线是两个短横线-，直接复制会出错)</p>\n<pre><code>*   &lt;div&gt;sudo apt-get install python-pip python-dev build-essential&lt;/div&gt;\n</code></pre><div>sudo pip install –upgrade pip</div><br><div>sudo pip install –upgrade virtualenv</div>\n\n<ol>\n<li><p>安装GenPAC：</p>\n<ul>\n<li><div>sudo pip install genpac</div><br><div>sudo pip install –upgrade genpac</div>\n</li>\n</ul>\n</li>\n<li><p>现在要下载一个文件，首先cd命令进入到你想存放文件的目录，比如:cd /home/yanhui</p>\n</li>\n</ol>\n</li>\n<li><p>执行下面命令：</p>\n<pre><code>*   sudo genpac --proxy=&quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-proxy=&quot;SOCKS5 127.0.0.1:1080&quot; -o autoproxy.pac --gfwlist-url=&quot;https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;\n</code></pre><ol>\n<li>现在在/home/yanhui的目录下生成了一个autoproxy.pac的文件</li>\n</ol>\n</li>\n<li><p>设置全局代理：</p>\n<pre><code>1.  系统设置-&amp;gt;网络-&amp;gt;网络代理\n</code></pre><ol>\n<li>方法选择“自动”</li>\n<li>配置url填写：file:///home/yanhui/autoproxy.pac</li>\n<li><p>点击应用到整个系统</p>\n</li>\n<li><p>用google来测试是否成功</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>声明：科学文明上网，本文只分享技术，请自行承担后果</p>\n<p>前言：</p>\n<p>之前一直使用Windows做学习的，这段时间在学git和python，于是在笔记本上划了50G空间又装了个Ubuntu16.04 LTS，之前之前在别的机器和虚拟机上尝试过安装shadowsocks QT5的客户端，但是尝试过几次都没有成功番羽墙成功。这次用了好久来找博客，终于成功。以下是我的步骤：","more":"</p>\n<ol>\n<li>shadowsocks是目前比较稳定的代理方式，首先你要有一台代理服务器（vps），或者买一个shadowsocks账号。这个步骤在网上一搜一大把</li>\n<li><p>安装Shadowsock客户端，我用的是shadowsocks-qt5，因为是图形界面版，便于管理</p>\n<ul>\n<li>在终端(ctrl+alt+t) 中依次输入（直接粘贴复制）三个步骤（分别是：添加源-&gt;更新源-&gt;安装）：</li>\n<li>sudo add-apt-repository ppa:hzwhuang/ss-qt5</li>\n<li>sudo apt-get update</li>\n<li>sudo apt-get install shadowsocks-qt5</li>\n</ul>\n</li>\n<li><p>设置代理服务</p>\n<ul>\n<li><img src=\"http://www.alanpro.win/wp-content/uploads/2017/07/2-16060915030H59.jpg\" alt=\"\">打开软件shadowsocks-qt5</li>\n<li><img src=\"http://www.alanpro.win/wp-content/uploads/2017/07/2-16060915031J37.jpg\" alt=\"\">连接-&gt;添加-&gt;手动 添加配置信息</li>\n<li>填写服务器地址，服务器端口，密钥，加密方式，其他的默认即可，配置名称随便写，点击OK</li>\n<li>点击连接即可开启服务，如果报错请检查上一步填写的信息是否有误，或者你的代理服务器是否正常服务</li>\n</ul>\n</li>\n<li><p>至此，shadowsocks已经配置完成，接下来设置全局代理，以下两步是准备工具：</p>\n<ol>\n<li><p>安装pip：(upgrade前的横线是两个短横线-，直接复制会出错)</p>\n<pre><code>*   &lt;div&gt;sudo apt-get install python-pip python-dev build-essential&lt;/div&gt;\n</code></pre><div>sudo pip install –upgrade pip</div><br><div>sudo pip install –upgrade virtualenv</div>\n\n<ol>\n<li><p>安装GenPAC：</p>\n<ul>\n<li><div>sudo pip install genpac</div><br><div>sudo pip install –upgrade genpac</div>\n</li>\n</ul>\n</li>\n<li><p>现在要下载一个文件，首先cd命令进入到你想存放文件的目录，比如:cd /home/yanhui</p>\n</li>\n</ol>\n</li>\n<li><p>执行下面命令：</p>\n<pre><code>*   sudo genpac --proxy=&quot;SOCKS5 127.0.0.1:1080&quot; --gfwlist-proxy=&quot;SOCKS5 127.0.0.1:1080&quot; -o autoproxy.pac --gfwlist-url=&quot;https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;\n</code></pre><ol>\n<li>现在在/home/yanhui的目录下生成了一个autoproxy.pac的文件</li>\n</ol>\n</li>\n<li><p>设置全局代理：</p>\n<pre><code>1.  系统设置-&amp;gt;网络-&amp;gt;网络代理\n</code></pre><ol>\n<li>方法选择“自动”</li>\n<li>配置url填写：file:///home/yanhui/autoproxy.pac</li>\n<li><p>点击应用到整个系统</p>\n</li>\n<li><p>用google来测试是否成功</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>"},{"title":"web开发基础理论知识","date":"2017-12-27T14:40:28.000Z","_content":"\n# web开发的理论知识\n\n## 关于网络的基本知识\n### 网址组成（四部分）上网的地址\n    协议      http, https（https 是加密的 http）\n    主机      zhihu.com  baidu.com之类的网址\n    端口      HTTP 协议默认是 80，因此一般不用填写\n    路径      下面的「/」和「/tags/python学习」都是路径\n例子：http协议 + 分隔符 + 域名(主机、ip地址) + 路径\nhttp://www.alanpro.win\nhttp://www.alanpro.win/tags/python学习/\n<!--more-->\n\n---\n\n### ip地址和dns服务器\n电脑通信靠IP地址，IP地址记不住就发明了域名（domain name），然后电脑自动向DNS服务器（domain name server）查询域名对应的IP地址\n比如g.cn这样的网址，可以通过电脑的ping程序查出对应 IP 地址\n➜    ping g.cn\nPING g.cn (74.125.69.160): 56 data bytes\n（自查dns服务器缓存）\n\n---\n\n### 端口的概念\n一个比喻：\n用邮局互相写信的时候，ip相当于地址（也可以看做邮编，地址是域名）\n端口是收信人姓名（因为一个地址比如公司、家只有一个地址，但是却可能有很多收信人）\n计算机运行着多个程序，比如说当qq在向另一台电脑上的qq发送信息的时候，先是要找到另一台电脑(ip)，找到电脑之后还要找到对应的程序，这样才能对应起来，在这里就是每个电脑都为qq分配了一个端口号。qq的端口号默认是4000，如果在启动qq的时候4000的端口号被占用则向后申请4001，以此类推。\n在windows下用 netstat -ano | findstr \"80\"可以查看80端口的使用情况\n\n如果具体想看哪个进程占用端口，可以用：tasklist | findstr \"80\"\n\n端口是一个 16 位的数字，所以范围是 0-65535（2**16）\n\n---\n\n## web后端开发是依托于http协议的\n\n一个传输协议，协议就是双方都遵守的*规范*\n为什么要用协议？因为只有有了同样的协议，两台计算机双方才能知道如何解析对方发来的信息。\n为什么叫超文本传输协议呢，因为收发的是文本信息。\n1，浏览器（客户端）按照规定的格式发送文本数据（请求）到服务器\n2，服务器解析请求，按照规定的格式返回文本数据到浏览器\n3，浏览器解析得到的数据，并做相应处理\n\n### http协议格式简单理解\n请求和返回是一样的数据格式，分为4部分：\n1，请求行或者响应行\n2，Header（请求的 Header 中 Host 字段是必须的，其他都是可选）\n3，\\r\\n\\r\\n（连续两个换行回车符，用来分隔Header和Body）\n4，Body（可选）\n\n请求的格式，注意大小写（这是一个不包含Body的请求）：\n原始数据如下\n'GET / HTTP/1.1\\r\\nhost:g.cn\\r\\n\\r\\n'\n打印出来如下（服务器解析原始数据）\nGET / HTTP/1.1\nHost: g.cn\n\n其中\n1， GET 是请求方法（还有POST等，这就是个标志字符串而已）\n2，/ 是请求的路径（这代表根路径）\n3，HTTP/1.1  中，1.1是版本号，浏览器一般不会管这个\n\n具体字符串是 'GET / HTTP/1.1\\r\\nhost:g.cn\\r\\n\\r\\n'\n\n返回的数据如下\nHTTP/1.1 301 Moved Permanently\nAlternate-Protocol: 80:quic,p=0,80:quic,p=0\nCache-Control: private, max-age=2592000\nContent-Length: 218\nContent-Type: text/html; charset=UTF-8\nDate: Tue, 07 Jul 2015 02:57:59 GMT\nExpires: Tue, 07 Jul 2015 02:57:59 GMT\n Location: http://www.google.cn/\nServer: gws\n\nBody部分省略\n\n其中响应行（第一行）：\n1，HTTP/1.1 是版本\n2，301 是「状态码，表示成功响应」，参见文末链接\n3，Moved Permanently 是状态码的描述\n浏览器会自己解析Header部分，然后将Body显示成网页\n\n\n\n## 后端开发，web服务器的主要工作\n主要就是解析请求，发送相应的数据给客户端。\n可以用python或者别的语言模拟浏览器发送 HTTP（例如爬虫就是这样工作） 请求给服务器并把收到的所有信息打印出来\n","source":"_posts/web-development-1.md","raw":"---\ntitle: web开发基础理论知识\n\ncategories:\n  - web学习整理\ndate: 2017-12-27 22:40:28\ntags:\n  - web学习整理\n---\n\n# web开发的理论知识\n\n## 关于网络的基本知识\n### 网址组成（四部分）上网的地址\n    协议      http, https（https 是加密的 http）\n    主机      zhihu.com  baidu.com之类的网址\n    端口      HTTP 协议默认是 80，因此一般不用填写\n    路径      下面的「/」和「/tags/python学习」都是路径\n例子：http协议 + 分隔符 + 域名(主机、ip地址) + 路径\nhttp://www.alanpro.win\nhttp://www.alanpro.win/tags/python学习/\n<!--more-->\n\n---\n\n### ip地址和dns服务器\n电脑通信靠IP地址，IP地址记不住就发明了域名（domain name），然后电脑自动向DNS服务器（domain name server）查询域名对应的IP地址\n比如g.cn这样的网址，可以通过电脑的ping程序查出对应 IP 地址\n➜    ping g.cn\nPING g.cn (74.125.69.160): 56 data bytes\n（自查dns服务器缓存）\n\n---\n\n### 端口的概念\n一个比喻：\n用邮局互相写信的时候，ip相当于地址（也可以看做邮编，地址是域名）\n端口是收信人姓名（因为一个地址比如公司、家只有一个地址，但是却可能有很多收信人）\n计算机运行着多个程序，比如说当qq在向另一台电脑上的qq发送信息的时候，先是要找到另一台电脑(ip)，找到电脑之后还要找到对应的程序，这样才能对应起来，在这里就是每个电脑都为qq分配了一个端口号。qq的端口号默认是4000，如果在启动qq的时候4000的端口号被占用则向后申请4001，以此类推。\n在windows下用 netstat -ano | findstr \"80\"可以查看80端口的使用情况\n\n如果具体想看哪个进程占用端口，可以用：tasklist | findstr \"80\"\n\n端口是一个 16 位的数字，所以范围是 0-65535（2**16）\n\n---\n\n## web后端开发是依托于http协议的\n\n一个传输协议，协议就是双方都遵守的*规范*\n为什么要用协议？因为只有有了同样的协议，两台计算机双方才能知道如何解析对方发来的信息。\n为什么叫超文本传输协议呢，因为收发的是文本信息。\n1，浏览器（客户端）按照规定的格式发送文本数据（请求）到服务器\n2，服务器解析请求，按照规定的格式返回文本数据到浏览器\n3，浏览器解析得到的数据，并做相应处理\n\n### http协议格式简单理解\n请求和返回是一样的数据格式，分为4部分：\n1，请求行或者响应行\n2，Header（请求的 Header 中 Host 字段是必须的，其他都是可选）\n3，\\r\\n\\r\\n（连续两个换行回车符，用来分隔Header和Body）\n4，Body（可选）\n\n请求的格式，注意大小写（这是一个不包含Body的请求）：\n原始数据如下\n'GET / HTTP/1.1\\r\\nhost:g.cn\\r\\n\\r\\n'\n打印出来如下（服务器解析原始数据）\nGET / HTTP/1.1\nHost: g.cn\n\n其中\n1， GET 是请求方法（还有POST等，这就是个标志字符串而已）\n2，/ 是请求的路径（这代表根路径）\n3，HTTP/1.1  中，1.1是版本号，浏览器一般不会管这个\n\n具体字符串是 'GET / HTTP/1.1\\r\\nhost:g.cn\\r\\n\\r\\n'\n\n返回的数据如下\nHTTP/1.1 301 Moved Permanently\nAlternate-Protocol: 80:quic,p=0,80:quic,p=0\nCache-Control: private, max-age=2592000\nContent-Length: 218\nContent-Type: text/html; charset=UTF-8\nDate: Tue, 07 Jul 2015 02:57:59 GMT\nExpires: Tue, 07 Jul 2015 02:57:59 GMT\n Location: http://www.google.cn/\nServer: gws\n\nBody部分省略\n\n其中响应行（第一行）：\n1，HTTP/1.1 是版本\n2，301 是「状态码，表示成功响应」，参见文末链接\n3，Moved Permanently 是状态码的描述\n浏览器会自己解析Header部分，然后将Body显示成网页\n\n\n\n## 后端开发，web服务器的主要工作\n主要就是解析请求，发送相应的数据给客户端。\n可以用python或者别的语言模拟浏览器发送 HTTP（例如爬虫就是这样工作） 请求给服务器并把收到的所有信息打印出来\n","slug":"web-development-1","published":1,"updated":"2017-12-27T14:35:08.158Z","_id":"cjbp5ec2u003piwtwr9pgyiej","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"web开发的理论知识\"><a href=\"#web开发的理论知识\" class=\"headerlink\" title=\"web开发的理论知识\"></a>web开发的理论知识</h1><h2 id=\"关于网络的基本知识\"><a href=\"#关于网络的基本知识\" class=\"headerlink\" title=\"关于网络的基本知识\"></a>关于网络的基本知识</h2><h3 id=\"网址组成（四部分）上网的地址\"><a href=\"#网址组成（四部分）上网的地址\" class=\"headerlink\" title=\"网址组成（四部分）上网的地址\"></a>网址组成（四部分）上网的地址</h3><pre><code>协议      http, https（https 是加密的 http）\n主机      zhihu.com  baidu.com之类的网址\n端口      HTTP 协议默认是 80，因此一般不用填写\n路径      下面的「/」和「/tags/python学习」都是路径\n</code></pre><p>例子：http协议 + 分隔符 + 域名(主机、ip地址) + 路径<br><a href=\"http://www.alanpro.win\" target=\"_blank\" rel=\"noopener\">http://www.alanpro.win</a><br><a href=\"http://www.alanpro.win/tags/python学习/\" target=\"_blank\" rel=\"noopener\">http://www.alanpro.win/tags/python学习/</a><br><a id=\"more\"></a></p>\n<hr>\n<h3 id=\"ip地址和dns服务器\"><a href=\"#ip地址和dns服务器\" class=\"headerlink\" title=\"ip地址和dns服务器\"></a>ip地址和dns服务器</h3><p>电脑通信靠IP地址，IP地址记不住就发明了域名（domain name），然后电脑自动向DNS服务器（domain name server）查询域名对应的IP地址<br>比如g.cn这样的网址，可以通过电脑的ping程序查出对应 IP 地址<br>➜    ping g.cn<br>PING g.cn (74.125.69.160): 56 data bytes<br>（自查dns服务器缓存）</p>\n<hr>\n<h3 id=\"端口的概念\"><a href=\"#端口的概念\" class=\"headerlink\" title=\"端口的概念\"></a>端口的概念</h3><p>一个比喻：<br>用邮局互相写信的时候，ip相当于地址（也可以看做邮编，地址是域名）<br>端口是收信人姓名（因为一个地址比如公司、家只有一个地址，但是却可能有很多收信人）<br>计算机运行着多个程序，比如说当qq在向另一台电脑上的qq发送信息的时候，先是要找到另一台电脑(ip)，找到电脑之后还要找到对应的程序，这样才能对应起来，在这里就是每个电脑都为qq分配了一个端口号。qq的端口号默认是4000，如果在启动qq的时候4000的端口号被占用则向后申请4001，以此类推。<br>在windows下用 netstat -ano | findstr “80”可以查看80端口的使用情况</p>\n<p>如果具体想看哪个进程占用端口，可以用：tasklist | findstr “80”</p>\n<p>端口是一个 16 位的数字，所以范围是 0-65535（2**16）</p>\n<hr>\n<h2 id=\"web后端开发是依托于http协议的\"><a href=\"#web后端开发是依托于http协议的\" class=\"headerlink\" title=\"web后端开发是依托于http协议的\"></a>web后端开发是依托于http协议的</h2><p>一个传输协议，协议就是双方都遵守的<em>规范</em><br>为什么要用协议？因为只有有了同样的协议，两台计算机双方才能知道如何解析对方发来的信息。<br>为什么叫超文本传输协议呢，因为收发的是文本信息。<br>1，浏览器（客户端）按照规定的格式发送文本数据（请求）到服务器<br>2，服务器解析请求，按照规定的格式返回文本数据到浏览器<br>3，浏览器解析得到的数据，并做相应处理</p>\n<h3 id=\"http协议格式简单理解\"><a href=\"#http协议格式简单理解\" class=\"headerlink\" title=\"http协议格式简单理解\"></a>http协议格式简单理解</h3><p>请求和返回是一样的数据格式，分为4部分：<br>1，请求行或者响应行<br>2，Header（请求的 Header 中 Host 字段是必须的，其他都是可选）<br>3，\\r\\n\\r\\n（连续两个换行回车符，用来分隔Header和Body）<br>4，Body（可选）</p>\n<p>请求的格式，注意大小写（这是一个不包含Body的请求）：<br>原始数据如下<br>‘GET / HTTP/1.1\\r\\nhost:g.cn\\r\\n\\r\\n’<br>打印出来如下（服务器解析原始数据）<br>GET / HTTP/1.1<br>Host: g.cn</p>\n<p>其中<br>1， GET 是请求方法（还有POST等，这就是个标志字符串而已）<br>2，/ 是请求的路径（这代表根路径）<br>3，HTTP/1.1  中，1.1是版本号，浏览器一般不会管这个</p>\n<p>具体字符串是 ‘GET / HTTP/1.1\\r\\nhost:g.cn\\r\\n\\r\\n’</p>\n<p>返回的数据如下<br>HTTP/1.1 301 Moved Permanently<br>Alternate-Protocol: 80:quic,p=0,80:quic,p=0<br>Cache-Control: private, max-age=2592000<br>Content-Length: 218<br>Content-Type: text/html; charset=UTF-8<br>Date: Tue, 07 Jul 2015 02:57:59 GMT<br>Expires: Tue, 07 Jul 2015 02:57:59 GMT<br> Location: <a href=\"http://www.google.cn/\" target=\"_blank\" rel=\"noopener\">http://www.google.cn/</a><br>Server: gws</p>\n<p>Body部分省略</p>\n<p>其中响应行（第一行）：<br>1，HTTP/1.1 是版本<br>2，301 是「状态码，表示成功响应」，参见文末链接<br>3，Moved Permanently 是状态码的描述<br>浏览器会自己解析Header部分，然后将Body显示成网页</p>\n<h2 id=\"后端开发，web服务器的主要工作\"><a href=\"#后端开发，web服务器的主要工作\" class=\"headerlink\" title=\"后端开发，web服务器的主要工作\"></a>后端开发，web服务器的主要工作</h2><p>主要就是解析请求，发送相应的数据给客户端。<br>可以用python或者别的语言模拟浏览器发送 HTTP（例如爬虫就是这样工作） 请求给服务器并把收到的所有信息打印出来</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"web开发的理论知识\"><a href=\"#web开发的理论知识\" class=\"headerlink\" title=\"web开发的理论知识\"></a>web开发的理论知识</h1><h2 id=\"关于网络的基本知识\"><a href=\"#关于网络的基本知识\" class=\"headerlink\" title=\"关于网络的基本知识\"></a>关于网络的基本知识</h2><h3 id=\"网址组成（四部分）上网的地址\"><a href=\"#网址组成（四部分）上网的地址\" class=\"headerlink\" title=\"网址组成（四部分）上网的地址\"></a>网址组成（四部分）上网的地址</h3><pre><code>协议      http, https（https 是加密的 http）\n主机      zhihu.com  baidu.com之类的网址\n端口      HTTP 协议默认是 80，因此一般不用填写\n路径      下面的「/」和「/tags/python学习」都是路径\n</code></pre><p>例子：http协议 + 分隔符 + 域名(主机、ip地址) + 路径<br><a href=\"http://www.alanpro.win\" target=\"_blank\" rel=\"noopener\">http://www.alanpro.win</a><br><a href=\"http://www.alanpro.win/tags/python学习/\" target=\"_blank\" rel=\"noopener\">http://www.alanpro.win/tags/python学习/</a><br>","more":"</p>\n<hr>\n<h3 id=\"ip地址和dns服务器\"><a href=\"#ip地址和dns服务器\" class=\"headerlink\" title=\"ip地址和dns服务器\"></a>ip地址和dns服务器</h3><p>电脑通信靠IP地址，IP地址记不住就发明了域名（domain name），然后电脑自动向DNS服务器（domain name server）查询域名对应的IP地址<br>比如g.cn这样的网址，可以通过电脑的ping程序查出对应 IP 地址<br>➜    ping g.cn<br>PING g.cn (74.125.69.160): 56 data bytes<br>（自查dns服务器缓存）</p>\n<hr>\n<h3 id=\"端口的概念\"><a href=\"#端口的概念\" class=\"headerlink\" title=\"端口的概念\"></a>端口的概念</h3><p>一个比喻：<br>用邮局互相写信的时候，ip相当于地址（也可以看做邮编，地址是域名）<br>端口是收信人姓名（因为一个地址比如公司、家只有一个地址，但是却可能有很多收信人）<br>计算机运行着多个程序，比如说当qq在向另一台电脑上的qq发送信息的时候，先是要找到另一台电脑(ip)，找到电脑之后还要找到对应的程序，这样才能对应起来，在这里就是每个电脑都为qq分配了一个端口号。qq的端口号默认是4000，如果在启动qq的时候4000的端口号被占用则向后申请4001，以此类推。<br>在windows下用 netstat -ano | findstr “80”可以查看80端口的使用情况</p>\n<p>如果具体想看哪个进程占用端口，可以用：tasklist | findstr “80”</p>\n<p>端口是一个 16 位的数字，所以范围是 0-65535（2**16）</p>\n<hr>\n<h2 id=\"web后端开发是依托于http协议的\"><a href=\"#web后端开发是依托于http协议的\" class=\"headerlink\" title=\"web后端开发是依托于http协议的\"></a>web后端开发是依托于http协议的</h2><p>一个传输协议，协议就是双方都遵守的<em>规范</em><br>为什么要用协议？因为只有有了同样的协议，两台计算机双方才能知道如何解析对方发来的信息。<br>为什么叫超文本传输协议呢，因为收发的是文本信息。<br>1，浏览器（客户端）按照规定的格式发送文本数据（请求）到服务器<br>2，服务器解析请求，按照规定的格式返回文本数据到浏览器<br>3，浏览器解析得到的数据，并做相应处理</p>\n<h3 id=\"http协议格式简单理解\"><a href=\"#http协议格式简单理解\" class=\"headerlink\" title=\"http协议格式简单理解\"></a>http协议格式简单理解</h3><p>请求和返回是一样的数据格式，分为4部分：<br>1，请求行或者响应行<br>2，Header（请求的 Header 中 Host 字段是必须的，其他都是可选）<br>3，\\r\\n\\r\\n（连续两个换行回车符，用来分隔Header和Body）<br>4，Body（可选）</p>\n<p>请求的格式，注意大小写（这是一个不包含Body的请求）：<br>原始数据如下<br>‘GET / HTTP/1.1\\r\\nhost:g.cn\\r\\n\\r\\n’<br>打印出来如下（服务器解析原始数据）<br>GET / HTTP/1.1<br>Host: g.cn</p>\n<p>其中<br>1， GET 是请求方法（还有POST等，这就是个标志字符串而已）<br>2，/ 是请求的路径（这代表根路径）<br>3，HTTP/1.1  中，1.1是版本号，浏览器一般不会管这个</p>\n<p>具体字符串是 ‘GET / HTTP/1.1\\r\\nhost:g.cn\\r\\n\\r\\n’</p>\n<p>返回的数据如下<br>HTTP/1.1 301 Moved Permanently<br>Alternate-Protocol: 80:quic,p=0,80:quic,p=0<br>Cache-Control: private, max-age=2592000<br>Content-Length: 218<br>Content-Type: text/html; charset=UTF-8<br>Date: Tue, 07 Jul 2015 02:57:59 GMT<br>Expires: Tue, 07 Jul 2015 02:57:59 GMT<br> Location: <a href=\"http://www.google.cn/\" target=\"_blank\" rel=\"noopener\">http://www.google.cn/</a><br>Server: gws</p>\n<p>Body部分省略</p>\n<p>其中响应行（第一行）：<br>1，HTTP/1.1 是版本<br>2，301 是「状态码，表示成功响应」，参见文末链接<br>3，Moved Permanently 是状态码的描述<br>浏览器会自己解析Header部分，然后将Body显示成网页</p>\n<h2 id=\"后端开发，web服务器的主要工作\"><a href=\"#后端开发，web服务器的主要工作\" class=\"headerlink\" title=\"后端开发，web服务器的主要工作\"></a>后端开发，web服务器的主要工作</h2><p>主要就是解析请求，发送相应的数据给客户端。<br>可以用python或者别的语言模拟浏览器发送 HTTP（例如爬虫就是这样工作） 请求给服务器并把收到的所有信息打印出来</p>"},{"title":"windows应用程序设计期末复习","id":"175","date":"2017-06-23T07:15:05.000Z","_content":"\n第一章：\n\n1.  在Windows操作系统上运行的应用程序叫做Windows应用程序\n2.  用户可以使用的、由操作系统提供的_**C语言**_函数称作应用编程接口\n3.  Windows应用程序都是基于消息驱动的\n4.  在窗口中按下鼠标左键的消息是WM_LBUTTONDOWN\n5.  在窗口下按下键盘中的任何一个键的消息是WM_KEYDO<!--more-->WN\n6.  在窗口中移动鼠标的消息是WN_MOUSEMOVE\n7.  工程项目名为My的MFC中的应用程序类是 CMyApp\n8.  窗口类CFrameWnd的派生类是CMainFrame\n9.  为了和程序的主函数名称相区别，Windows应用程序的主函数名称是 WinMain\n10.  应用程序的主函数的两个任务是：创建应用程序窗口 和 建立消息循环\n11.  在键盘上按任意一个键的消息是 WM_KEYDOWN，对应的消息响应函数名是 OnKeyDown\n12.  假设项目名为My，MFC AppWizard创建的4个类分别是：CMyView、CMyDoc、CMyApp、CMainFrame\n13.  按下鼠标右键的消息是WM_RBUTTONDOWN，对应的消息响应函数是OnRButtonDown（）\n&nbsp;\n\n*   名词解释：\n\n    *   API：应用程序接口。Windows提供了大量预定义的，用C语言编写的函数，这些函数被称为API函数。\n    *   消息：为了描述事件的各种信息，Windows定义了一个结构， 这个结构称为消息\n    *   消息映射：消息与消息响应函数之间一一对应的关系 称为消息映射\n第二章：\n\n1.  简单的说，DC是设备描述环境的简称\n2.  MFC中CDC类的派生类有4个，其中_**CPaintDC**_和**_CClientDC_**是最常用的\n3.  CClientDC类只能使用在OnDraw（）函数之外的其他消息响应函数中\n4.  MFC中TextOut()函数可以直接使用，不需要任何对象去调用该函数\n5.  MFC中的画笔类是CPen\n6.  MFC中的画刷类是CBrush\n7.  OnDraw（）函数中用来绘制图形的是CPaintDC 对象调用CDC类成员方法\n8.  在整个窗口（不仅是用户区）绘图的设备描述环境是 CWindowDC\n9.  图元文件的设备描述环境类是 CMetaFileDC\n10.  CDC类中用于显示文本的成员函数是 TextOut\n11.  CDC类中用于设置文本颜色的成员函数是SetTextColor\n12.  CDC类中用于设置文字字符间距的成员函数是SetTextCharacterExtra\n13.  CPaintDC类只能使用在OnDraw函数之中\n\n*   名词解释\n\n    *   CDC类：将DC和GDI函数封装到一起形成一个类，在MFC中称为CDC类\n    *   CClientDC类：CClientDC类是窗口客户区的设备描述环境，应用在WM_PAINT之外的其他消息的消息处理函数中\n    *   CPaintDC类：CPaintDC类是窗口客户区的设备描述环境，应用处理WM_PAINT消息的OnDraw（）函数中\n第三章：\n\n1.  在MFC中，仍然可以使用Windows和C语言的所有数据类型\n2.  为了把数据和对数据的操作封装到一起，MFC定义了一些通用的数据类。例如，点类CPoint、矩形类CRect和字符串CString等\n3.  在文档/视图结构程序中，文档对象和视图对象分工明确。文档类中保存变量，视图类中负责处理用户和窗口之间的交互\n4.  CSize类的对象表示窗口中一个矩形区域的大小。两个CSize类的对象只要矩形面积大小相同，两个CSize类的对象相等\n5.  MFC中点类的类名是CPoint\n6.  MFC中的矩形类名是CRect\n7.  MFC中数组类的类名是CArray\n8.  链表类的类名是CList\n9.  要使用数组类时，需要在StdAfx.h头文件中添加afxtempl.h的包含命令\n10.  MFC中点类的构造函数是：CPoint(int initX,int initY); CPoint(POINT initPt);\n11.  矩形类的构造函数是：CRect(int l,int t, int r, int b); CRect(const RECT&amp; srcRect);\n12.  尺寸类的构造函数是：CSize(int initCX, int initCY); CSize(SIZE initSize);\n\n*   语句解释题：\n\n    *   CString str:定义一个字符串类的对象str，其值为空串\n    *   CString str(\"hello\")：定义一个字符串的对象str，其值为“hello”\n    *   CString str(anotherString)：定义一个字符串对象str，其值为另一个字符串类对象。\n第四章：\n\n1.  在MFC APPWizard 中只有3种方式可以确定窗口的样式\n2.  单文档界面和多文档界面是MFC应用程序的两种类型\n3.  MFC APPWizard 设置完应用程序界面以后，在应用程序框架中还可以修改窗口的样式\n4.  使用UpdateAllViews(NULL)函数可以实现所有拆分窗口的同步更新\n5.  提高拆分窗口更新效率的方法由InvalidateRect()函数和OnUpdate()函数\n6.  双文档界面不是MFC应用程序类型，mfc应用程序类型只有两种\n7.  提供支持自动化滚动滑条的类是 CScrollView\n8.  UpdateAllViews(NULL)是让拆分窗口同步更新的函数\n9.  Update不是让视图更新的函数\n10.  拆分窗口最多可以将窗口分为4个\n11.  MFC中除了可以在应用程序向导中设置窗口样式外，还可以通过PreCreateWindow()函数来设置窗口样式\n12.  通过调用API函数SetScrollSizes()来设置初始化滚动条参数，该函数是在视图类的成员函数OnInitialUpdate（）中被调用的\n13.  如果选择CScrollView类作为视图类的基类，创建的窗口将自动带有滚动条\n\n*   语句解释题：\n\n    *   单文档界面程序：如果运行程序一次只能打开一个文档，那么这种程序称为单文档界面程序\n    *   多文档界面程序：如果运行程序一次能够打开多个文档，那么这种程序称为多文档界面程序\n    *   拆分窗口同步更新：在某个窗口改变了文档数据以后，其他拆分窗口都能立即显示修改过后的数据的变化\n第五章：\n\n1.  鼠标消息按照操作鼠标时在窗口中的位置可以分为两类。。\n2.  非用户区是指：窗口标题栏、菜单栏、工具栏、状态栏和边框等区域\n3.  键盘消息的数据根据所按键是否为字母键，分为3种（\n4.  在Windows应用程序中使用的虚拟码是与键盘无关的，每个键对应的虚拟码都是固定的\n5.  获得输入焦点的函数为OnSetFocus()，是WM_SETFOCUS对应的消息响应函数\n6.  键盘消息的类型由：WM_CHAR、WM_KEYDOWN、WM_KEYUP\n7.  鼠标消息分为用户区鼠标消息和非用户区鼠标消息\n8.  SetCapture是捕获鼠标的函数\n9.  ReleaseCapture是释放捕获鼠标的函数\n10.  Windows系统的按键消息可以分为3类。\n11.  具有输入焦点的窗口才能接受键盘的消息\n12.  通过在窗口中按下非字母键只能产生按键消息，不产生字符消息\n13.  调用_**SetCaputre**_函数可以安全地_**接受到应用程序窗口外的鼠标消息**_\n\n*   简答题\n\n    *   鼠标消息分为用户区鼠标消息和非用户去鼠标消息。鼠标在窗口的白色区域内部操作时，产生用户鼠标消息。鼠标在窗口的标题栏、菜单栏、工具栏状态栏或者边框上操作时，产生非用户区鼠标消息\n    *   只要用鼠标单击该窗口就能够变为输入焦点的窗口。如果让鼠标单击该窗口以外的任何位置，该窗口就会失去输入焦点\n    *   VC++没有像用户区鼠标消息那样为非用户区鼠标消息提供编程工具。如果必须使用非用户区鼠标消息，程序中添加非用户区鼠标消息的消息映射宏，并声明消息响应函数原型，最后定义消息响应函数的函数体。\n第六章：资源\n\n1.  可供Windows应用程序利用，可单独编辑，并可动态加载的数据就是资源\n2.  可以通过对资源视图中添加响应资源并对其进行保存的方法，自动对资源头文件和资源描述文件进行修改\n3.  程序所需的资源使用资源描述文件来说明，在资源头文件中用标识符唯一地进行标识定义\n4.  菜单命令选项可以通过类想到来添加对应的消息响应函数\n5.  在文档/视图结构的程序中，资源的加载是由应用程序类的InitInstance函数中通过构造CDocTemplate（包括其派生类）对象来完成的\n6.  菜单命令选项的使用与Windows的WM_COMMAND消息相关\n7.  菜单命令选项资源标识的前缀是 ID_\n8.  BitBlt 函数可以用来显示位图\n9.  使用SelectObject函数能把位图选入内存设备环境中。\n10.  菜单命令项的消息映射宏的格式是 ON_COMMAND（菜单命令选项ID，消息响应函数）\n11.  菜单命令 选项的加速键（快捷键）在资源描述文件中与所对应的菜单命令选项相关。用户按下它和控制键，就相当于单击 了菜单命令选项\n12.  在Windows应用程序中，位图用CBitmap类的对象类保存\n\n*   简答题：\n\n    *   简单描述在MFC中使用位图资源的步骤：\n\n            *   定义位图对象-&gt;把位图资源载入位图对象-&gt;获得位图信息-&gt;位图对象选入内存设备环境-&gt;显示位图\n\n        *   简单描述在MFC中使用图标资源的步骤：\n\n            *   首先，用图标编辑器制作图标-&gt;以扩展名为ico把图标文件存盘，在资源描述文件中用描述语句来说明图标文件所在的位置-&gt;保存资源描述文件\n第七章：控件\n\n1.  每个控件都是windows应用程序的子窗口，所有控件类都派生于窗口类CWnd\n2.  控件有各自特有的行为特点，，应该在各自的类中用相应的成员函数实现。\n3.  如果要改变控件的背景颜色则需要用宏 ON_WM_CTLCOLOR()来声明消息映射\n4.  控件的背景颜色默认值是灰色，控件文字的默认颜色是黑色，窗口默认颜色是白色\n5.  设置控件背景颜色的消息响应函数是 OnCtlColor\n6.  按钮控件资源标识的前缀是ID_\n7.  创建按钮控件的代码放在OnCreate中\n8.  设置按钮控件IDC_BUTTON单击事件的消息映射宏是ON_BN_CLICKED(IDB_BUTTON1，OnButtonClicked);\n9.  WS_CHILD,WS_VISIBLE 样式使空间称为窗口的子窗口并且在窗口中可见\n10.  按钮控件的三种不同形式：普通按钮，复选框按钮，单选按钮。\n\n*   简答题：\n\n    *   简单描述在应用程序的窗口中使用一个按钮控件的步骤：\n\n            *   资源头文件中定义按钮资源标识符-&gt;声明按钮对象名和消息响应函数原型-&gt;定义按钮单击的消息映射宏-&gt;创建按钮控件-&gt;定义按钮的消息响应函数\n\n        *   怎样才能使控件称为窗口的子窗口并且在窗口中可见：\n第八章：对话框\n\n1.  创建对话框是windows应用程序与用户交互的重要手段，对话框可以分为模态对话框和非模态对话框两种类型。\n2.  对话框模版资源可以使用VC++ 的资源编辑器来创建和编辑\n3.  对话框使用数据交换（DDX）机制实现控件与变量之间的数据交换，使用数据检验（DDV）机制检验通过控件录入的数据是否超过限制\n4.  创建模态对话框时，对话框类对象调用DoModal（）函数来显示并运行对话框\n5.  创建非模态对话框时，对话框类对象调用Create（）函数来创建非模态对话框\n6.  属性页是CpropertySheet类派生类的对象，它包含若干属性页面\n7.  属性页面是CpropertyPage类派生类的对象，它是一个对话框\n8.  MFC中对话框类的类名是CDialog\n9.  用MFC ClassWizard为对话框添加成员变量 并与相应的控件进行关联\n10.  用MFC ClassWizard为对话框添加_**成员变量与相应的控件**_进行关联。为对话框添加_**消息映射并与相应的控件消息**_进行关联\n11.  卷子分数分配\n\n    *   单选20分，1*20 = 20分\n    *   多选10分，2*5 = 10分\n    *   名词解释 2*5=10分\n    *   填空题 2*10=20分\n    *   判断题 20分 = 20分\n    *   编程 123个小题，20分","source":"_posts/windows-e5-ba-94-e7-94-a8-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e6-9c-9f-e6-9c-ab-e5-a4-8d-e4-b9-a0.md","raw":"---\ntitle: windows应用程序设计期末复习\ntags:\n  - 课程\nid: 175\ncategories:\n  - 课程小结\ndate: 2017-06-23 15:15:05\n---\n\n第一章：\n\n1.  在Windows操作系统上运行的应用程序叫做Windows应用程序\n2.  用户可以使用的、由操作系统提供的_**C语言**_函数称作应用编程接口\n3.  Windows应用程序都是基于消息驱动的\n4.  在窗口中按下鼠标左键的消息是WM_LBUTTONDOWN\n5.  在窗口下按下键盘中的任何一个键的消息是WM_KEYDO<!--more-->WN\n6.  在窗口中移动鼠标的消息是WN_MOUSEMOVE\n7.  工程项目名为My的MFC中的应用程序类是 CMyApp\n8.  窗口类CFrameWnd的派生类是CMainFrame\n9.  为了和程序的主函数名称相区别，Windows应用程序的主函数名称是 WinMain\n10.  应用程序的主函数的两个任务是：创建应用程序窗口 和 建立消息循环\n11.  在键盘上按任意一个键的消息是 WM_KEYDOWN，对应的消息响应函数名是 OnKeyDown\n12.  假设项目名为My，MFC AppWizard创建的4个类分别是：CMyView、CMyDoc、CMyApp、CMainFrame\n13.  按下鼠标右键的消息是WM_RBUTTONDOWN，对应的消息响应函数是OnRButtonDown（）\n&nbsp;\n\n*   名词解释：\n\n    *   API：应用程序接口。Windows提供了大量预定义的，用C语言编写的函数，这些函数被称为API函数。\n    *   消息：为了描述事件的各种信息，Windows定义了一个结构， 这个结构称为消息\n    *   消息映射：消息与消息响应函数之间一一对应的关系 称为消息映射\n第二章：\n\n1.  简单的说，DC是设备描述环境的简称\n2.  MFC中CDC类的派生类有4个，其中_**CPaintDC**_和**_CClientDC_**是最常用的\n3.  CClientDC类只能使用在OnDraw（）函数之外的其他消息响应函数中\n4.  MFC中TextOut()函数可以直接使用，不需要任何对象去调用该函数\n5.  MFC中的画笔类是CPen\n6.  MFC中的画刷类是CBrush\n7.  OnDraw（）函数中用来绘制图形的是CPaintDC 对象调用CDC类成员方法\n8.  在整个窗口（不仅是用户区）绘图的设备描述环境是 CWindowDC\n9.  图元文件的设备描述环境类是 CMetaFileDC\n10.  CDC类中用于显示文本的成员函数是 TextOut\n11.  CDC类中用于设置文本颜色的成员函数是SetTextColor\n12.  CDC类中用于设置文字字符间距的成员函数是SetTextCharacterExtra\n13.  CPaintDC类只能使用在OnDraw函数之中\n\n*   名词解释\n\n    *   CDC类：将DC和GDI函数封装到一起形成一个类，在MFC中称为CDC类\n    *   CClientDC类：CClientDC类是窗口客户区的设备描述环境，应用在WM_PAINT之外的其他消息的消息处理函数中\n    *   CPaintDC类：CPaintDC类是窗口客户区的设备描述环境，应用处理WM_PAINT消息的OnDraw（）函数中\n第三章：\n\n1.  在MFC中，仍然可以使用Windows和C语言的所有数据类型\n2.  为了把数据和对数据的操作封装到一起，MFC定义了一些通用的数据类。例如，点类CPoint、矩形类CRect和字符串CString等\n3.  在文档/视图结构程序中，文档对象和视图对象分工明确。文档类中保存变量，视图类中负责处理用户和窗口之间的交互\n4.  CSize类的对象表示窗口中一个矩形区域的大小。两个CSize类的对象只要矩形面积大小相同，两个CSize类的对象相等\n5.  MFC中点类的类名是CPoint\n6.  MFC中的矩形类名是CRect\n7.  MFC中数组类的类名是CArray\n8.  链表类的类名是CList\n9.  要使用数组类时，需要在StdAfx.h头文件中添加afxtempl.h的包含命令\n10.  MFC中点类的构造函数是：CPoint(int initX,int initY); CPoint(POINT initPt);\n11.  矩形类的构造函数是：CRect(int l,int t, int r, int b); CRect(const RECT&amp; srcRect);\n12.  尺寸类的构造函数是：CSize(int initCX, int initCY); CSize(SIZE initSize);\n\n*   语句解释题：\n\n    *   CString str:定义一个字符串类的对象str，其值为空串\n    *   CString str(\"hello\")：定义一个字符串的对象str，其值为“hello”\n    *   CString str(anotherString)：定义一个字符串对象str，其值为另一个字符串类对象。\n第四章：\n\n1.  在MFC APPWizard 中只有3种方式可以确定窗口的样式\n2.  单文档界面和多文档界面是MFC应用程序的两种类型\n3.  MFC APPWizard 设置完应用程序界面以后，在应用程序框架中还可以修改窗口的样式\n4.  使用UpdateAllViews(NULL)函数可以实现所有拆分窗口的同步更新\n5.  提高拆分窗口更新效率的方法由InvalidateRect()函数和OnUpdate()函数\n6.  双文档界面不是MFC应用程序类型，mfc应用程序类型只有两种\n7.  提供支持自动化滚动滑条的类是 CScrollView\n8.  UpdateAllViews(NULL)是让拆分窗口同步更新的函数\n9.  Update不是让视图更新的函数\n10.  拆分窗口最多可以将窗口分为4个\n11.  MFC中除了可以在应用程序向导中设置窗口样式外，还可以通过PreCreateWindow()函数来设置窗口样式\n12.  通过调用API函数SetScrollSizes()来设置初始化滚动条参数，该函数是在视图类的成员函数OnInitialUpdate（）中被调用的\n13.  如果选择CScrollView类作为视图类的基类，创建的窗口将自动带有滚动条\n\n*   语句解释题：\n\n    *   单文档界面程序：如果运行程序一次只能打开一个文档，那么这种程序称为单文档界面程序\n    *   多文档界面程序：如果运行程序一次能够打开多个文档，那么这种程序称为多文档界面程序\n    *   拆分窗口同步更新：在某个窗口改变了文档数据以后，其他拆分窗口都能立即显示修改过后的数据的变化\n第五章：\n\n1.  鼠标消息按照操作鼠标时在窗口中的位置可以分为两类。。\n2.  非用户区是指：窗口标题栏、菜单栏、工具栏、状态栏和边框等区域\n3.  键盘消息的数据根据所按键是否为字母键，分为3种（\n4.  在Windows应用程序中使用的虚拟码是与键盘无关的，每个键对应的虚拟码都是固定的\n5.  获得输入焦点的函数为OnSetFocus()，是WM_SETFOCUS对应的消息响应函数\n6.  键盘消息的类型由：WM_CHAR、WM_KEYDOWN、WM_KEYUP\n7.  鼠标消息分为用户区鼠标消息和非用户区鼠标消息\n8.  SetCapture是捕获鼠标的函数\n9.  ReleaseCapture是释放捕获鼠标的函数\n10.  Windows系统的按键消息可以分为3类。\n11.  具有输入焦点的窗口才能接受键盘的消息\n12.  通过在窗口中按下非字母键只能产生按键消息，不产生字符消息\n13.  调用_**SetCaputre**_函数可以安全地_**接受到应用程序窗口外的鼠标消息**_\n\n*   简答题\n\n    *   鼠标消息分为用户区鼠标消息和非用户去鼠标消息。鼠标在窗口的白色区域内部操作时，产生用户鼠标消息。鼠标在窗口的标题栏、菜单栏、工具栏状态栏或者边框上操作时，产生非用户区鼠标消息\n    *   只要用鼠标单击该窗口就能够变为输入焦点的窗口。如果让鼠标单击该窗口以外的任何位置，该窗口就会失去输入焦点\n    *   VC++没有像用户区鼠标消息那样为非用户区鼠标消息提供编程工具。如果必须使用非用户区鼠标消息，程序中添加非用户区鼠标消息的消息映射宏，并声明消息响应函数原型，最后定义消息响应函数的函数体。\n第六章：资源\n\n1.  可供Windows应用程序利用，可单独编辑，并可动态加载的数据就是资源\n2.  可以通过对资源视图中添加响应资源并对其进行保存的方法，自动对资源头文件和资源描述文件进行修改\n3.  程序所需的资源使用资源描述文件来说明，在资源头文件中用标识符唯一地进行标识定义\n4.  菜单命令选项可以通过类想到来添加对应的消息响应函数\n5.  在文档/视图结构的程序中，资源的加载是由应用程序类的InitInstance函数中通过构造CDocTemplate（包括其派生类）对象来完成的\n6.  菜单命令选项的使用与Windows的WM_COMMAND消息相关\n7.  菜单命令选项资源标识的前缀是 ID_\n8.  BitBlt 函数可以用来显示位图\n9.  使用SelectObject函数能把位图选入内存设备环境中。\n10.  菜单命令项的消息映射宏的格式是 ON_COMMAND（菜单命令选项ID，消息响应函数）\n11.  菜单命令 选项的加速键（快捷键）在资源描述文件中与所对应的菜单命令选项相关。用户按下它和控制键，就相当于单击 了菜单命令选项\n12.  在Windows应用程序中，位图用CBitmap类的对象类保存\n\n*   简答题：\n\n    *   简单描述在MFC中使用位图资源的步骤：\n\n            *   定义位图对象-&gt;把位图资源载入位图对象-&gt;获得位图信息-&gt;位图对象选入内存设备环境-&gt;显示位图\n\n        *   简单描述在MFC中使用图标资源的步骤：\n\n            *   首先，用图标编辑器制作图标-&gt;以扩展名为ico把图标文件存盘，在资源描述文件中用描述语句来说明图标文件所在的位置-&gt;保存资源描述文件\n第七章：控件\n\n1.  每个控件都是windows应用程序的子窗口，所有控件类都派生于窗口类CWnd\n2.  控件有各自特有的行为特点，，应该在各自的类中用相应的成员函数实现。\n3.  如果要改变控件的背景颜色则需要用宏 ON_WM_CTLCOLOR()来声明消息映射\n4.  控件的背景颜色默认值是灰色，控件文字的默认颜色是黑色，窗口默认颜色是白色\n5.  设置控件背景颜色的消息响应函数是 OnCtlColor\n6.  按钮控件资源标识的前缀是ID_\n7.  创建按钮控件的代码放在OnCreate中\n8.  设置按钮控件IDC_BUTTON单击事件的消息映射宏是ON_BN_CLICKED(IDB_BUTTON1，OnButtonClicked);\n9.  WS_CHILD,WS_VISIBLE 样式使空间称为窗口的子窗口并且在窗口中可见\n10.  按钮控件的三种不同形式：普通按钮，复选框按钮，单选按钮。\n\n*   简答题：\n\n    *   简单描述在应用程序的窗口中使用一个按钮控件的步骤：\n\n            *   资源头文件中定义按钮资源标识符-&gt;声明按钮对象名和消息响应函数原型-&gt;定义按钮单击的消息映射宏-&gt;创建按钮控件-&gt;定义按钮的消息响应函数\n\n        *   怎样才能使控件称为窗口的子窗口并且在窗口中可见：\n第八章：对话框\n\n1.  创建对话框是windows应用程序与用户交互的重要手段，对话框可以分为模态对话框和非模态对话框两种类型。\n2.  对话框模版资源可以使用VC++ 的资源编辑器来创建和编辑\n3.  对话框使用数据交换（DDX）机制实现控件与变量之间的数据交换，使用数据检验（DDV）机制检验通过控件录入的数据是否超过限制\n4.  创建模态对话框时，对话框类对象调用DoModal（）函数来显示并运行对话框\n5.  创建非模态对话框时，对话框类对象调用Create（）函数来创建非模态对话框\n6.  属性页是CpropertySheet类派生类的对象，它包含若干属性页面\n7.  属性页面是CpropertyPage类派生类的对象，它是一个对话框\n8.  MFC中对话框类的类名是CDialog\n9.  用MFC ClassWizard为对话框添加成员变量 并与相应的控件进行关联\n10.  用MFC ClassWizard为对话框添加_**成员变量与相应的控件**_进行关联。为对话框添加_**消息映射并与相应的控件消息**_进行关联\n11.  卷子分数分配\n\n    *   单选20分，1*20 = 20分\n    *   多选10分，2*5 = 10分\n    *   名词解释 2*5=10分\n    *   填空题 2*10=20分\n    *   判断题 20分 = 20分\n    *   编程 123个小题，20分","slug":"windows-e5-ba-94-e7-94-a8-e7-a8-8b-e5-ba-8f-e8-ae-be-e8-ae-a1-e6-9c-9f-e6-9c-ab-e5-a4-8d-e4-b9-a0","published":1,"updated":"2017-12-09T17:06:50.786Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbp5ec2w003siwtwmy5qd8ve","content":"<p>第一章：</p>\n<ol>\n<li>在Windows操作系统上运行的应用程序叫做Windows应用程序</li>\n<li>用户可以使用的、由操作系统提供的<em><strong>C语言</strong></em>函数称作应用编程接口</li>\n<li>Windows应用程序都是基于消息驱动的</li>\n<li>在窗口中按下鼠标左键的消息是WM_LBUTTONDOWN</li>\n<li>在窗口下按下键盘中的任何一个键的消息是WM_KEYDO<a id=\"more\"></a>WN</li>\n<li>在窗口中移动鼠标的消息是WN_MOUSEMOVE</li>\n<li>工程项目名为My的MFC中的应用程序类是 CMyApp</li>\n<li>窗口类CFrameWnd的派生类是CMainFrame</li>\n<li>为了和程序的主函数名称相区别，Windows应用程序的主函数名称是 WinMain</li>\n<li>应用程序的主函数的两个任务是：创建应用程序窗口 和 建立消息循环</li>\n<li>在键盘上按任意一个键的消息是 WM_KEYDOWN，对应的消息响应函数名是 OnKeyDown</li>\n<li>假设项目名为My，MFC AppWizard创建的4个类分别是：CMyView、CMyDoc、CMyApp、CMainFrame</li>\n<li>按下鼠标右键的消息是WM_RBUTTONDOWN，对应的消息响应函数是OnRButtonDown（）<br>&nbsp;</li>\n</ol>\n<ul>\n<li><p>名词解释：</p>\n<ul>\n<li>API：应用程序接口。Windows提供了大量预定义的，用C语言编写的函数，这些函数被称为API函数。</li>\n<li>消息：为了描述事件的各种信息，Windows定义了一个结构， 这个结构称为消息</li>\n<li>消息映射：消息与消息响应函数之间一一对应的关系 称为消息映射<br>第二章：</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>简单的说，DC是设备描述环境的简称</li>\n<li>MFC中CDC类的派生类有4个，其中<em><strong>CPaintDC</strong></em>和<strong><em>CClientDC</em></strong>是最常用的</li>\n<li>CClientDC类只能使用在OnDraw（）函数之外的其他消息响应函数中</li>\n<li>MFC中TextOut()函数可以直接使用，不需要任何对象去调用该函数</li>\n<li>MFC中的画笔类是CPen</li>\n<li>MFC中的画刷类是CBrush</li>\n<li>OnDraw（）函数中用来绘制图形的是CPaintDC 对象调用CDC类成员方法</li>\n<li>在整个窗口（不仅是用户区）绘图的设备描述环境是 CWindowDC</li>\n<li>图元文件的设备描述环境类是 CMetaFileDC</li>\n<li>CDC类中用于显示文本的成员函数是 TextOut</li>\n<li>CDC类中用于设置文本颜色的成员函数是SetTextColor</li>\n<li>CDC类中用于设置文字字符间距的成员函数是SetTextCharacterExtra</li>\n<li>CPaintDC类只能使用在OnDraw函数之中</li>\n</ol>\n<ul>\n<li><p>名词解释</p>\n<ul>\n<li>CDC类：将DC和GDI函数封装到一起形成一个类，在MFC中称为CDC类</li>\n<li>CClientDC类：CClientDC类是窗口客户区的设备描述环境，应用在WM_PAINT之外的其他消息的消息处理函数中</li>\n<li>CPaintDC类：CPaintDC类是窗口客户区的设备描述环境，应用处理WM_PAINT消息的OnDraw（）函数中<br>第三章：</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>在MFC中，仍然可以使用Windows和C语言的所有数据类型</li>\n<li>为了把数据和对数据的操作封装到一起，MFC定义了一些通用的数据类。例如，点类CPoint、矩形类CRect和字符串CString等</li>\n<li>在文档/视图结构程序中，文档对象和视图对象分工明确。文档类中保存变量，视图类中负责处理用户和窗口之间的交互</li>\n<li>CSize类的对象表示窗口中一个矩形区域的大小。两个CSize类的对象只要矩形面积大小相同，两个CSize类的对象相等</li>\n<li>MFC中点类的类名是CPoint</li>\n<li>MFC中的矩形类名是CRect</li>\n<li>MFC中数组类的类名是CArray</li>\n<li>链表类的类名是CList</li>\n<li>要使用数组类时，需要在StdAfx.h头文件中添加afxtempl.h的包含命令</li>\n<li>MFC中点类的构造函数是：CPoint(int initX,int initY); CPoint(POINT initPt);</li>\n<li>矩形类的构造函数是：CRect(int l,int t, int r, int b); CRect(const RECT&amp; srcRect);</li>\n<li>尺寸类的构造函数是：CSize(int initCX, int initCY); CSize(SIZE initSize);</li>\n</ol>\n<ul>\n<li><p>语句解释题：</p>\n<ul>\n<li>CString str:定义一个字符串类的对象str，其值为空串</li>\n<li>CString str(“hello”)：定义一个字符串的对象str，其值为“hello”</li>\n<li>CString str(anotherString)：定义一个字符串对象str，其值为另一个字符串类对象。<br>第四章：</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>在MFC APPWizard 中只有3种方式可以确定窗口的样式</li>\n<li>单文档界面和多文档界面是MFC应用程序的两种类型</li>\n<li>MFC APPWizard 设置完应用程序界面以后，在应用程序框架中还可以修改窗口的样式</li>\n<li>使用UpdateAllViews(NULL)函数可以实现所有拆分窗口的同步更新</li>\n<li>提高拆分窗口更新效率的方法由InvalidateRect()函数和OnUpdate()函数</li>\n<li>双文档界面不是MFC应用程序类型，mfc应用程序类型只有两种</li>\n<li>提供支持自动化滚动滑条的类是 CScrollView</li>\n<li>UpdateAllViews(NULL)是让拆分窗口同步更新的函数</li>\n<li>Update不是让视图更新的函数</li>\n<li>拆分窗口最多可以将窗口分为4个</li>\n<li>MFC中除了可以在应用程序向导中设置窗口样式外，还可以通过PreCreateWindow()函数来设置窗口样式</li>\n<li>通过调用API函数SetScrollSizes()来设置初始化滚动条参数，该函数是在视图类的成员函数OnInitialUpdate（）中被调用的</li>\n<li>如果选择CScrollView类作为视图类的基类，创建的窗口将自动带有滚动条</li>\n</ol>\n<ul>\n<li><p>语句解释题：</p>\n<ul>\n<li>单文档界面程序：如果运行程序一次只能打开一个文档，那么这种程序称为单文档界面程序</li>\n<li>多文档界面程序：如果运行程序一次能够打开多个文档，那么这种程序称为多文档界面程序</li>\n<li>拆分窗口同步更新：在某个窗口改变了文档数据以后，其他拆分窗口都能立即显示修改过后的数据的变化<br>第五章：</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>鼠标消息按照操作鼠标时在窗口中的位置可以分为两类。。</li>\n<li>非用户区是指：窗口标题栏、菜单栏、工具栏、状态栏和边框等区域</li>\n<li>键盘消息的数据根据所按键是否为字母键，分为3种（</li>\n<li>在Windows应用程序中使用的虚拟码是与键盘无关的，每个键对应的虚拟码都是固定的</li>\n<li>获得输入焦点的函数为OnSetFocus()，是WM_SETFOCUS对应的消息响应函数</li>\n<li>键盘消息的类型由：WM_CHAR、WM_KEYDOWN、WM_KEYUP</li>\n<li>鼠标消息分为用户区鼠标消息和非用户区鼠标消息</li>\n<li>SetCapture是捕获鼠标的函数</li>\n<li>ReleaseCapture是释放捕获鼠标的函数</li>\n<li>Windows系统的按键消息可以分为3类。</li>\n<li>具有输入焦点的窗口才能接受键盘的消息</li>\n<li>通过在窗口中按下非字母键只能产生按键消息，不产生字符消息</li>\n<li>调用<em><strong>SetCaputre</strong></em>函数可以安全地<em><strong>接受到应用程序窗口外的鼠标消息</strong></em></li>\n</ol>\n<ul>\n<li><p>简答题</p>\n<ul>\n<li>鼠标消息分为用户区鼠标消息和非用户去鼠标消息。鼠标在窗口的白色区域内部操作时，产生用户鼠标消息。鼠标在窗口的标题栏、菜单栏、工具栏状态栏或者边框上操作时，产生非用户区鼠标消息</li>\n<li>只要用鼠标单击该窗口就能够变为输入焦点的窗口。如果让鼠标单击该窗口以外的任何位置，该窗口就会失去输入焦点</li>\n<li>VC++没有像用户区鼠标消息那样为非用户区鼠标消息提供编程工具。如果必须使用非用户区鼠标消息，程序中添加非用户区鼠标消息的消息映射宏，并声明消息响应函数原型，最后定义消息响应函数的函数体。<br>第六章：资源</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>可供Windows应用程序利用，可单独编辑，并可动态加载的数据就是资源</li>\n<li>可以通过对资源视图中添加响应资源并对其进行保存的方法，自动对资源头文件和资源描述文件进行修改</li>\n<li>程序所需的资源使用资源描述文件来说明，在资源头文件中用标识符唯一地进行标识定义</li>\n<li>菜单命令选项可以通过类想到来添加对应的消息响应函数</li>\n<li>在文档/视图结构的程序中，资源的加载是由应用程序类的InitInstance函数中通过构造CDocTemplate（包括其派生类）对象来完成的</li>\n<li>菜单命令选项的使用与Windows的WM_COMMAND消息相关</li>\n<li>菜单命令选项资源标识的前缀是 ID_</li>\n<li>BitBlt 函数可以用来显示位图</li>\n<li>使用SelectObject函数能把位图选入内存设备环境中。</li>\n<li>菜单命令项的消息映射宏的格式是 ON_COMMAND（菜单命令选项ID，消息响应函数）</li>\n<li>菜单命令 选项的加速键（快捷键）在资源描述文件中与所对应的菜单命令选项相关。用户按下它和控制键，就相当于单击 了菜单命令选项</li>\n<li>在Windows应用程序中，位图用CBitmap类的对象类保存</li>\n</ol>\n<ul>\n<li><p>简答题：</p>\n<ul>\n<li><p>简单描述在MFC中使用位图资源的步骤：</p>\n<pre><code>*   定义位图对象-&amp;gt;把位图资源载入位图对象-&amp;gt;获得位图信息-&amp;gt;位图对象选入内存设备环境-&amp;gt;显示位图\n</code></pre><ul>\n<li><p>简单描述在MFC中使用图标资源的步骤：</p>\n<ul>\n<li>首先，用图标编辑器制作图标-&gt;以扩展名为ico把图标文件存盘，在资源描述文件中用描述语句来说明图标文件所在的位置-&gt;保存资源描述文件<br>第七章：控件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>每个控件都是windows应用程序的子窗口，所有控件类都派生于窗口类CWnd</li>\n<li>控件有各自特有的行为特点，，应该在各自的类中用相应的成员函数实现。</li>\n<li>如果要改变控件的背景颜色则需要用宏 ON_WM_CTLCOLOR()来声明消息映射</li>\n<li>控件的背景颜色默认值是灰色，控件文字的默认颜色是黑色，窗口默认颜色是白色</li>\n<li>设置控件背景颜色的消息响应函数是 OnCtlColor</li>\n<li>按钮控件资源标识的前缀是ID_</li>\n<li>创建按钮控件的代码放在OnCreate中</li>\n<li>设置按钮控件IDC_BUTTON单击事件的消息映射宏是ON_BN_CLICKED(IDB_BUTTON1，OnButtonClicked);</li>\n<li>WS_CHILD,WS_VISIBLE 样式使空间称为窗口的子窗口并且在窗口中可见</li>\n<li>按钮控件的三种不同形式：普通按钮，复选框按钮，单选按钮。</li>\n</ol>\n<ul>\n<li><p>简答题：</p>\n<ul>\n<li><p>简单描述在应用程序的窗口中使用一个按钮控件的步骤：</p>\n<pre><code>*   资源头文件中定义按钮资源标识符-&amp;gt;声明按钮对象名和消息响应函数原型-&amp;gt;定义按钮单击的消息映射宏-&amp;gt;创建按钮控件-&amp;gt;定义按钮的消息响应函数\n</code></pre><ul>\n<li>怎样才能使控件称为窗口的子窗口并且在窗口中可见：<br>第八章：对话框</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>创建对话框是windows应用程序与用户交互的重要手段，对话框可以分为模态对话框和非模态对话框两种类型。</li>\n<li>对话框模版资源可以使用VC++ 的资源编辑器来创建和编辑</li>\n<li>对话框使用数据交换（DDX）机制实现控件与变量之间的数据交换，使用数据检验（DDV）机制检验通过控件录入的数据是否超过限制</li>\n<li>创建模态对话框时，对话框类对象调用DoModal（）函数来显示并运行对话框</li>\n<li>创建非模态对话框时，对话框类对象调用Create（）函数来创建非模态对话框</li>\n<li>属性页是CpropertySheet类派生类的对象，它包含若干属性页面</li>\n<li>属性页面是CpropertyPage类派生类的对象，它是一个对话框</li>\n<li>MFC中对话框类的类名是CDialog</li>\n<li>用MFC ClassWizard为对话框添加成员变量 并与相应的控件进行关联</li>\n<li>用MFC ClassWizard为对话框添加<em><strong>成员变量与相应的控件</strong></em>进行关联。为对话框添加<em><strong>消息映射并与相应的控件消息</strong></em>进行关联</li>\n<li><p>卷子分数分配</p>\n<ul>\n<li>单选20分，1*20 = 20分</li>\n<li>多选10分，2*5 = 10分</li>\n<li>名词解释 2*5=10分</li>\n<li>填空题 2*10=20分</li>\n<li>判断题 20分 = 20分</li>\n<li>编程 123个小题，20分</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>第一章：</p>\n<ol>\n<li>在Windows操作系统上运行的应用程序叫做Windows应用程序</li>\n<li>用户可以使用的、由操作系统提供的<em><strong>C语言</strong></em>函数称作应用编程接口</li>\n<li>Windows应用程序都是基于消息驱动的</li>\n<li>在窗口中按下鼠标左键的消息是WM_LBUTTONDOWN</li>\n<li>在窗口下按下键盘中的任何一个键的消息是WM_KEYDO","more":"WN</li>\n<li>在窗口中移动鼠标的消息是WN_MOUSEMOVE</li>\n<li>工程项目名为My的MFC中的应用程序类是 CMyApp</li>\n<li>窗口类CFrameWnd的派生类是CMainFrame</li>\n<li>为了和程序的主函数名称相区别，Windows应用程序的主函数名称是 WinMain</li>\n<li>应用程序的主函数的两个任务是：创建应用程序窗口 和 建立消息循环</li>\n<li>在键盘上按任意一个键的消息是 WM_KEYDOWN，对应的消息响应函数名是 OnKeyDown</li>\n<li>假设项目名为My，MFC AppWizard创建的4个类分别是：CMyView、CMyDoc、CMyApp、CMainFrame</li>\n<li>按下鼠标右键的消息是WM_RBUTTONDOWN，对应的消息响应函数是OnRButtonDown（）<br>&nbsp;</li>\n</ol>\n<ul>\n<li><p>名词解释：</p>\n<ul>\n<li>API：应用程序接口。Windows提供了大量预定义的，用C语言编写的函数，这些函数被称为API函数。</li>\n<li>消息：为了描述事件的各种信息，Windows定义了一个结构， 这个结构称为消息</li>\n<li>消息映射：消息与消息响应函数之间一一对应的关系 称为消息映射<br>第二章：</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>简单的说，DC是设备描述环境的简称</li>\n<li>MFC中CDC类的派生类有4个，其中<em><strong>CPaintDC</strong></em>和<strong><em>CClientDC</em></strong>是最常用的</li>\n<li>CClientDC类只能使用在OnDraw（）函数之外的其他消息响应函数中</li>\n<li>MFC中TextOut()函数可以直接使用，不需要任何对象去调用该函数</li>\n<li>MFC中的画笔类是CPen</li>\n<li>MFC中的画刷类是CBrush</li>\n<li>OnDraw（）函数中用来绘制图形的是CPaintDC 对象调用CDC类成员方法</li>\n<li>在整个窗口（不仅是用户区）绘图的设备描述环境是 CWindowDC</li>\n<li>图元文件的设备描述环境类是 CMetaFileDC</li>\n<li>CDC类中用于显示文本的成员函数是 TextOut</li>\n<li>CDC类中用于设置文本颜色的成员函数是SetTextColor</li>\n<li>CDC类中用于设置文字字符间距的成员函数是SetTextCharacterExtra</li>\n<li>CPaintDC类只能使用在OnDraw函数之中</li>\n</ol>\n<ul>\n<li><p>名词解释</p>\n<ul>\n<li>CDC类：将DC和GDI函数封装到一起形成一个类，在MFC中称为CDC类</li>\n<li>CClientDC类：CClientDC类是窗口客户区的设备描述环境，应用在WM_PAINT之外的其他消息的消息处理函数中</li>\n<li>CPaintDC类：CPaintDC类是窗口客户区的设备描述环境，应用处理WM_PAINT消息的OnDraw（）函数中<br>第三章：</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>在MFC中，仍然可以使用Windows和C语言的所有数据类型</li>\n<li>为了把数据和对数据的操作封装到一起，MFC定义了一些通用的数据类。例如，点类CPoint、矩形类CRect和字符串CString等</li>\n<li>在文档/视图结构程序中，文档对象和视图对象分工明确。文档类中保存变量，视图类中负责处理用户和窗口之间的交互</li>\n<li>CSize类的对象表示窗口中一个矩形区域的大小。两个CSize类的对象只要矩形面积大小相同，两个CSize类的对象相等</li>\n<li>MFC中点类的类名是CPoint</li>\n<li>MFC中的矩形类名是CRect</li>\n<li>MFC中数组类的类名是CArray</li>\n<li>链表类的类名是CList</li>\n<li>要使用数组类时，需要在StdAfx.h头文件中添加afxtempl.h的包含命令</li>\n<li>MFC中点类的构造函数是：CPoint(int initX,int initY); CPoint(POINT initPt);</li>\n<li>矩形类的构造函数是：CRect(int l,int t, int r, int b); CRect(const RECT&amp; srcRect);</li>\n<li>尺寸类的构造函数是：CSize(int initCX, int initCY); CSize(SIZE initSize);</li>\n</ol>\n<ul>\n<li><p>语句解释题：</p>\n<ul>\n<li>CString str:定义一个字符串类的对象str，其值为空串</li>\n<li>CString str(“hello”)：定义一个字符串的对象str，其值为“hello”</li>\n<li>CString str(anotherString)：定义一个字符串对象str，其值为另一个字符串类对象。<br>第四章：</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>在MFC APPWizard 中只有3种方式可以确定窗口的样式</li>\n<li>单文档界面和多文档界面是MFC应用程序的两种类型</li>\n<li>MFC APPWizard 设置完应用程序界面以后，在应用程序框架中还可以修改窗口的样式</li>\n<li>使用UpdateAllViews(NULL)函数可以实现所有拆分窗口的同步更新</li>\n<li>提高拆分窗口更新效率的方法由InvalidateRect()函数和OnUpdate()函数</li>\n<li>双文档界面不是MFC应用程序类型，mfc应用程序类型只有两种</li>\n<li>提供支持自动化滚动滑条的类是 CScrollView</li>\n<li>UpdateAllViews(NULL)是让拆分窗口同步更新的函数</li>\n<li>Update不是让视图更新的函数</li>\n<li>拆分窗口最多可以将窗口分为4个</li>\n<li>MFC中除了可以在应用程序向导中设置窗口样式外，还可以通过PreCreateWindow()函数来设置窗口样式</li>\n<li>通过调用API函数SetScrollSizes()来设置初始化滚动条参数，该函数是在视图类的成员函数OnInitialUpdate（）中被调用的</li>\n<li>如果选择CScrollView类作为视图类的基类，创建的窗口将自动带有滚动条</li>\n</ol>\n<ul>\n<li><p>语句解释题：</p>\n<ul>\n<li>单文档界面程序：如果运行程序一次只能打开一个文档，那么这种程序称为单文档界面程序</li>\n<li>多文档界面程序：如果运行程序一次能够打开多个文档，那么这种程序称为多文档界面程序</li>\n<li>拆分窗口同步更新：在某个窗口改变了文档数据以后，其他拆分窗口都能立即显示修改过后的数据的变化<br>第五章：</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>鼠标消息按照操作鼠标时在窗口中的位置可以分为两类。。</li>\n<li>非用户区是指：窗口标题栏、菜单栏、工具栏、状态栏和边框等区域</li>\n<li>键盘消息的数据根据所按键是否为字母键，分为3种（</li>\n<li>在Windows应用程序中使用的虚拟码是与键盘无关的，每个键对应的虚拟码都是固定的</li>\n<li>获得输入焦点的函数为OnSetFocus()，是WM_SETFOCUS对应的消息响应函数</li>\n<li>键盘消息的类型由：WM_CHAR、WM_KEYDOWN、WM_KEYUP</li>\n<li>鼠标消息分为用户区鼠标消息和非用户区鼠标消息</li>\n<li>SetCapture是捕获鼠标的函数</li>\n<li>ReleaseCapture是释放捕获鼠标的函数</li>\n<li>Windows系统的按键消息可以分为3类。</li>\n<li>具有输入焦点的窗口才能接受键盘的消息</li>\n<li>通过在窗口中按下非字母键只能产生按键消息，不产生字符消息</li>\n<li>调用<em><strong>SetCaputre</strong></em>函数可以安全地<em><strong>接受到应用程序窗口外的鼠标消息</strong></em></li>\n</ol>\n<ul>\n<li><p>简答题</p>\n<ul>\n<li>鼠标消息分为用户区鼠标消息和非用户去鼠标消息。鼠标在窗口的白色区域内部操作时，产生用户鼠标消息。鼠标在窗口的标题栏、菜单栏、工具栏状态栏或者边框上操作时，产生非用户区鼠标消息</li>\n<li>只要用鼠标单击该窗口就能够变为输入焦点的窗口。如果让鼠标单击该窗口以外的任何位置，该窗口就会失去输入焦点</li>\n<li>VC++没有像用户区鼠标消息那样为非用户区鼠标消息提供编程工具。如果必须使用非用户区鼠标消息，程序中添加非用户区鼠标消息的消息映射宏，并声明消息响应函数原型，最后定义消息响应函数的函数体。<br>第六章：资源</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>可供Windows应用程序利用，可单独编辑，并可动态加载的数据就是资源</li>\n<li>可以通过对资源视图中添加响应资源并对其进行保存的方法，自动对资源头文件和资源描述文件进行修改</li>\n<li>程序所需的资源使用资源描述文件来说明，在资源头文件中用标识符唯一地进行标识定义</li>\n<li>菜单命令选项可以通过类想到来添加对应的消息响应函数</li>\n<li>在文档/视图结构的程序中，资源的加载是由应用程序类的InitInstance函数中通过构造CDocTemplate（包括其派生类）对象来完成的</li>\n<li>菜单命令选项的使用与Windows的WM_COMMAND消息相关</li>\n<li>菜单命令选项资源标识的前缀是 ID_</li>\n<li>BitBlt 函数可以用来显示位图</li>\n<li>使用SelectObject函数能把位图选入内存设备环境中。</li>\n<li>菜单命令项的消息映射宏的格式是 ON_COMMAND（菜单命令选项ID，消息响应函数）</li>\n<li>菜单命令 选项的加速键（快捷键）在资源描述文件中与所对应的菜单命令选项相关。用户按下它和控制键，就相当于单击 了菜单命令选项</li>\n<li>在Windows应用程序中，位图用CBitmap类的对象类保存</li>\n</ol>\n<ul>\n<li><p>简答题：</p>\n<ul>\n<li><p>简单描述在MFC中使用位图资源的步骤：</p>\n<pre><code>*   定义位图对象-&amp;gt;把位图资源载入位图对象-&amp;gt;获得位图信息-&amp;gt;位图对象选入内存设备环境-&amp;gt;显示位图\n</code></pre><ul>\n<li><p>简单描述在MFC中使用图标资源的步骤：</p>\n<ul>\n<li>首先，用图标编辑器制作图标-&gt;以扩展名为ico把图标文件存盘，在资源描述文件中用描述语句来说明图标文件所在的位置-&gt;保存资源描述文件<br>第七章：控件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>每个控件都是windows应用程序的子窗口，所有控件类都派生于窗口类CWnd</li>\n<li>控件有各自特有的行为特点，，应该在各自的类中用相应的成员函数实现。</li>\n<li>如果要改变控件的背景颜色则需要用宏 ON_WM_CTLCOLOR()来声明消息映射</li>\n<li>控件的背景颜色默认值是灰色，控件文字的默认颜色是黑色，窗口默认颜色是白色</li>\n<li>设置控件背景颜色的消息响应函数是 OnCtlColor</li>\n<li>按钮控件资源标识的前缀是ID_</li>\n<li>创建按钮控件的代码放在OnCreate中</li>\n<li>设置按钮控件IDC_BUTTON单击事件的消息映射宏是ON_BN_CLICKED(IDB_BUTTON1，OnButtonClicked);</li>\n<li>WS_CHILD,WS_VISIBLE 样式使空间称为窗口的子窗口并且在窗口中可见</li>\n<li>按钮控件的三种不同形式：普通按钮，复选框按钮，单选按钮。</li>\n</ol>\n<ul>\n<li><p>简答题：</p>\n<ul>\n<li><p>简单描述在应用程序的窗口中使用一个按钮控件的步骤：</p>\n<pre><code>*   资源头文件中定义按钮资源标识符-&amp;gt;声明按钮对象名和消息响应函数原型-&amp;gt;定义按钮单击的消息映射宏-&amp;gt;创建按钮控件-&amp;gt;定义按钮的消息响应函数\n</code></pre><ul>\n<li>怎样才能使控件称为窗口的子窗口并且在窗口中可见：<br>第八章：对话框</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>创建对话框是windows应用程序与用户交互的重要手段，对话框可以分为模态对话框和非模态对话框两种类型。</li>\n<li>对话框模版资源可以使用VC++ 的资源编辑器来创建和编辑</li>\n<li>对话框使用数据交换（DDX）机制实现控件与变量之间的数据交换，使用数据检验（DDV）机制检验通过控件录入的数据是否超过限制</li>\n<li>创建模态对话框时，对话框类对象调用DoModal（）函数来显示并运行对话框</li>\n<li>创建非模态对话框时，对话框类对象调用Create（）函数来创建非模态对话框</li>\n<li>属性页是CpropertySheet类派生类的对象，它包含若干属性页面</li>\n<li>属性页面是CpropertyPage类派生类的对象，它是一个对话框</li>\n<li>MFC中对话框类的类名是CDialog</li>\n<li>用MFC ClassWizard为对话框添加成员变量 并与相应的控件进行关联</li>\n<li>用MFC ClassWizard为对话框添加<em><strong>成员变量与相应的控件</strong></em>进行关联。为对话框添加<em><strong>消息映射并与相应的控件消息</strong></em>进行关联</li>\n<li><p>卷子分数分配</p>\n<ul>\n<li>单选20分，1*20 = 20分</li>\n<li>多选10分，2*5 = 10分</li>\n<li>名词解释 2*5=10分</li>\n<li>填空题 2*10=20分</li>\n<li>判断题 20分 = 20分</li>\n<li>编程 123个小题，20分</li>\n</ul>\n</li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjbp5ebzf0000iwtw4yvl535d","category_id":"cjbp5ebzp0004iwtwm4nxdm5z","_id":"cjbp5ec09000giwtwq6s971b3"},{"post_id":"cjbp5ebzz0009iwtw0s9677cf","category_id":"cjbp5ebzp0004iwtwm4nxdm5z","_id":"cjbp5ec09000jiwtwmpat8k28"},{"post_id":"cjbp5ebzp0002iwtwph9pejk8","category_id":"cjbp5ebzp0004iwtwm4nxdm5z","_id":"cjbp5ec09000niwtw1vaj19pe"},{"post_id":"cjbp5ec09000piwtw77r2w3qz","category_id":"cjbp5ec09000miwtw7v3u993o","_id":"cjbp5ec0j000yiwtwww3ere5c"},{"post_id":"cjbp5ebzp0007iwtwv7fptep2","category_id":"cjbp5ec09000miwtw7v3u993o","_id":"cjbp5ec0j0012iwtwi2n9h0c1"},{"post_id":"cjbp5ec0j000siwtwtmu1qaq2","category_id":"cjbp5ec09000miwtw7v3u993o","_id":"cjbp5ec0t0015iwtwgxcqm76i"},{"post_id":"cjbp5ec0j000viwtwrpestyc0","category_id":"cjbp5ec09000miwtw7v3u993o","_id":"cjbp5ec0t0019iwtwx7lefny5"},{"post_id":"cjbp5ebzz000diwtw3m2aclkx","category_id":"cjbp5ec09000miwtw7v3u993o","_id":"cjbp5ec13001ciwtwdlqfvf73"},{"post_id":"cjbp5ec0j000xiwtws7c8fbrv","category_id":"cjbp5ec09000miwtw7v3u993o","_id":"cjbp5ec13001giwtwqh4z0imx"},{"post_id":"cjbp5ec0j0011iwtwnmj6ik8p","category_id":"cjbp5ec09000miwtw7v3u993o","_id":"cjbp5ec13001iiwtwapvj9qs7"},{"post_id":"cjbp5ec09000hiwtwahc21luc","category_id":"cjbp5ec09000miwtw7v3u993o","_id":"cjbp5ec13001miwtweqz8pume"},{"post_id":"cjbp5ec0j0014iwtw2e2nv6qh","category_id":"cjbp5ec09000miwtw7v3u993o","_id":"cjbp5ec1d001piwtwrlo0jp4q"},{"post_id":"cjbp5ebzp0005iwtwar1ure2k","category_id":"cjbp5ebzp0004iwtwm4nxdm5z","_id":"cjbp5ec1d001tiwtwhzdj1iy3"},{"post_id":"cjbp5ebzp0005iwtwar1ure2k","category_id":"cjbp5ec0t0016iwtwlucvn1jv","_id":"cjbp5ec1d001wiwtw03p8ycnb"},{"post_id":"cjbp5ec09000liwtw8sz7p04x","category_id":"cjbp5ec09000miwtw7v3u993o","_id":"cjbp5ec1d001yiwtwt8qik389"},{"post_id":"cjbp5ec13001kiwtwsvitgy0v","category_id":"cjbp5ebzp0004iwtwm4nxdm5z","_id":"cjbp5ec1n0023iwtwz8ua3qob"},{"post_id":"cjbp5ec0t0018iwtwwj3grs5n","category_id":"cjbp5ec13001jiwtw3wsryk2j","_id":"cjbp5ec1n0025iwtw3st5p6i3"},{"post_id":"cjbp5ec1d001riwtwk0exbhf0","category_id":"cjbp5ec09000miwtw7v3u993o","_id":"cjbp5ec1n0029iwtwsd154nue"},{"post_id":"cjbp5ec0t001biwtwy70ier4z","category_id":"cjbp5ec1d001qiwtwpj6qfwvf","_id":"cjbp5ec1n002ciwtwtnsd2x7q"},{"post_id":"cjbp5ec1d001xiwtwk629fdhq","category_id":"cjbp5ec13001jiwtw3wsryk2j","_id":"cjbp5ec1x002hiwtw6rigsanp"},{"post_id":"cjbp5ec13001fiwtwj39qs3u8","category_id":"cjbp5ec13001jiwtw3wsryk2j","_id":"cjbp5ec1x002kiwtwbkqe1t1x"},{"post_id":"cjbp5ec1n0024iwtwaxq00s54","category_id":"cjbp5ec13001jiwtw3wsryk2j","_id":"cjbp5ec1x002piwtwq7lrr2l2"},{"post_id":"cjbp5ec13001hiwtwqmpnwe5c","category_id":"cjbp5ec13001jiwtw3wsryk2j","_id":"cjbp5ec1x002siwtw3b771ey8"},{"post_id":"cjbp5ec1n002biwtwpgzfkmop","category_id":"cjbp5ebzp0004iwtwm4nxdm5z","_id":"cjbp5ec27002xiwtwk34o40vt"},{"post_id":"cjbp5ec13001oiwtw6vqizit5","category_id":"cjbp5ec1n002diwtwh30bixfx","_id":"cjbp5ec27002ziwtwigjixsyw"},{"post_id":"cjbp5ec1x002jiwtwj30snu1g","category_id":"cjbp5ec13001jiwtw3wsryk2j","_id":"cjbp5ec270032iwtwjddwaifn"},{"post_id":"cjbp5ec27002viwtw23898t7u","category_id":"cjbp5ebzp0004iwtwm4nxdm5z","_id":"cjbp5ec270036iwtwd0qpqhal"},{"post_id":"cjbp5ec1d0021iwtwgqw8nyu6","category_id":"cjbp5ec27002uiwtw7gjhu8ow","_id":"cjbp5ec2i0039iwtwlqmdsvb9"},{"post_id":"cjbp5ec27002yiwtwqcfg13o4","category_id":"cjbp5ebzp0004iwtwm4nxdm5z","_id":"cjbp5ec2l003diwtwtdlm42rh"},{"post_id":"cjbp5ec270031iwtwsntzo8ge","category_id":"cjbp5ebzp0004iwtwm4nxdm5z","_id":"cjbp5ec2n003giwtwsrymin00"},{"post_id":"cjbp5ec270034iwtwkcgfu1pl","category_id":"cjbp5ec13001jiwtw3wsryk2j","_id":"cjbp5ec2q003kiwtwms26hb94"},{"post_id":"cjbp5ec1n0028iwtw6k16mknt","category_id":"cjbp5ebzp0004iwtwm4nxdm5z","_id":"cjbp5ec2s003niwtwflxnsjei"},{"post_id":"cjbp5ec1n0028iwtw6k16mknt","category_id":"cjbp5ec270030iwtwx4d397lo","_id":"cjbp5ec2v003riwtw1rvcc4us"},{"post_id":"cjbp5ec270037iwtw0hkfzlzo","category_id":"cjbp5ebzp0004iwtwm4nxdm5z","_id":"cjbp5ec2x003tiwtwb244hp7d"},{"post_id":"cjbp5ec2k003ciwtwns28efdn","category_id":"cjbp5ec09000miwtw7v3u993o","_id":"cjbp5ec2y003viwtw6scm66a9"},{"post_id":"cjbp5ec1x002giwtwc2x6uyb1","category_id":"cjbp5ec1x002liwtw97qksx8f","_id":"cjbp5ec30003yiwtw4qrhjb5w"},{"post_id":"cjbp5ec2m003fiwtw4cxvh4gi","category_id":"cjbp5ec1n002diwtwh30bixfx","_id":"cjbp5ec320041iwtwudyfmrup"},{"post_id":"cjbp5ec2r003miwtw0u6zhwsb","category_id":"cjbp5ec1x002liwtw97qksx8f","_id":"cjbp5ec330044iwtw3starayi"},{"post_id":"cjbp5ec1d001viwtw87aoy92u","category_id":"cjbp5ec1x002liwtw97qksx8f","_id":"cjbp5ec330047iwtwj5zt0pqu"},{"post_id":"cjbp5ec1d001viwtw87aoy92u","category_id":"cjbp5ec2t003oiwtwgkkxr90b","_id":"cjbp5ec33004aiwtwc49b0qbt"},{"post_id":"cjbp5ec1x002riwtwbf4hxcrx","category_id":"cjbp5ec2x003uiwtw2t76sgcm","_id":"cjbp5ec33004diwtwrirrthw4"},{"post_id":"cjbp5ec2p003jiwtwc94ddwek","category_id":"cjbp5ec1x002liwtw97qksx8f","_id":"cjbp5ec33004fiwtwxigeiq7h"},{"post_id":"cjbp5ec2p003jiwtwc94ddwek","category_id":"cjbp5ec2t003oiwtwgkkxr90b","_id":"cjbp5ec33004giwtwuag6tle7"},{"post_id":"cjbp5ec1x002niwtwb9wqmt5h","category_id":"cjbp5ec27002uiwtw7gjhu8ow","_id":"cjbp5ec33004iiwtwpurhvx9w"},{"post_id":"cjbp5ec1x002niwtwb9wqmt5h","category_id":"cjbp5ec330045iwtwj7a8rt8m","_id":"cjbp5ec33004kiwtwki10cckz"},{"post_id":"cjbp5ec2w003siwtwmy5qd8ve","category_id":"cjbp5ec33004biwtwl26cayt6","_id":"cjbp5ec3d004niwtwzxq3t6bp"},{"post_id":"cjbp5ec2u003piwtwr9pgyiej","category_id":"cjbp5ec13001jiwtw3wsryk2j","_id":"cjbp5xvci0001iktw1e1wfnaj"}],"PostTag":[{"post_id":"cjbp5ebzp0007iwtwv7fptep2","tag_id":"cjbp5ebzz000ciwtwssgalt2x","_id":"cjbp5ec09000kiwtw3pwnhuof"},{"post_id":"cjbp5ec09000hiwtwahc21luc","tag_id":"cjbp5ebzz000ciwtwssgalt2x","_id":"cjbp5ec09000oiwtw00k1gm0a"},{"post_id":"cjbp5ebzz000diwtw3m2aclkx","tag_id":"cjbp5ebzz000ciwtwssgalt2x","_id":"cjbp5ec0j000riwtw4s9qj5cv"},{"post_id":"cjbp5ec09000piwtw77r2w3qz","tag_id":"cjbp5ebzz000ciwtwssgalt2x","_id":"cjbp5ec0j000uiwtwh4z10vn6"},{"post_id":"cjbp5ec0j000siwtwtmu1qaq2","tag_id":"cjbp5ebzz000ciwtwssgalt2x","_id":"cjbp5ec0j000wiwtwm9ug1s0i"},{"post_id":"cjbp5ec09000eiwtwzu2ausls","tag_id":"cjbp5ec0j000qiwtwnqobi1l9","_id":"cjbp5ec0j0010iwtwmacv7gwk"},{"post_id":"cjbp5ec0j000viwtwrpestyc0","tag_id":"cjbp5ebzz000ciwtwssgalt2x","_id":"cjbp5ec0j0013iwtww7496q8p"},{"post_id":"cjbp5ec0j000xiwtws7c8fbrv","tag_id":"cjbp5ebzz000ciwtwssgalt2x","_id":"cjbp5ec0t0017iwtwu79ryoca"},{"post_id":"cjbp5ec0j0014iwtw2e2nv6qh","tag_id":"cjbp5ebzz000ciwtwssgalt2x","_id":"cjbp5ec0t001aiwtw7xorjjpu"},{"post_id":"cjbp5ec0t0018iwtwwj3grs5n","tag_id":"cjbp5ec13001eiwtw4tbyozhv","_id":"cjbp5ec13001niwtwgrvb7td9"},{"post_id":"cjbp5ec13001fiwtwj39qs3u8","tag_id":"cjbp5ec13001eiwtw4tbyozhv","_id":"cjbp5ec1d001uiwtwct88z0zs"},{"post_id":"cjbp5ec13001hiwtwqmpnwe5c","tag_id":"cjbp5ec1d001siwtwlnavj6qh","_id":"cjbp5ec1n0022iwtwy591bdkp"},{"post_id":"cjbp5ec13001kiwtwsvitgy0v","tag_id":"cjbp5ec0j000qiwtwnqobi1l9","_id":"cjbp5ec1n002aiwtwy11cnvmv"},{"post_id":"cjbp5ec13001kiwtwsvitgy0v","tag_id":"cjbp5ec1d0020iwtwms35eak4","_id":"cjbp5ec1x002eiwtwgrpoh1z5"},{"post_id":"cjbp5ec13001oiwtw6vqizit5","tag_id":"cjbp5ec1n0027iwtwc6ot6b2e","_id":"cjbp5ec1x002iiwtwdtcnrfca"},{"post_id":"cjbp5ec1n002biwtwpgzfkmop","tag_id":"cjbp5ec0j000qiwtwnqobi1l9","_id":"cjbp5ec1x002miwtwxfpa3sc4"},{"post_id":"cjbp5ec1n002biwtwpgzfkmop","tag_id":"cjbp5ec1d0020iwtwms35eak4","_id":"cjbp5ec1x002qiwtwcbwpeime"},{"post_id":"cjbp5ec1d001riwtwk0exbhf0","tag_id":"cjbp5ec1x002fiwtwzqnmk6sg","_id":"cjbp5ec1x002tiwtwin8973hr"},{"post_id":"cjbp5ec1d001xiwtwk629fdhq","tag_id":"cjbp5ec1x002fiwtwzqnmk6sg","_id":"cjbp5ec270035iwtwfge440n2"},{"post_id":"cjbp5ec1d001xiwtwk629fdhq","tag_id":"cjbp5ec27002wiwtwsylosltu","_id":"cjbp5ec2i0038iwtwppzy6jft"},{"post_id":"cjbp5ec1d0021iwtwgqw8nyu6","tag_id":"cjbp5ec270033iwtwat6f9de4","_id":"cjbp5ec2l003eiwtws7b7mo66"},{"post_id":"cjbp5ec1n0024iwtwaxq00s54","tag_id":"cjbp5ec2j003biwtwbui07wzn","_id":"cjbp5ec2q003liwtwm9eukms7"},{"post_id":"cjbp5ec1n0028iwtw6k16mknt","tag_id":"cjbp5ec2o003iiwtwvnykg5yn","_id":"cjbp5ec30003xiwtwojtgyodf"},{"post_id":"cjbp5ec1n0028iwtw6k16mknt","tag_id":"cjbp5ec2v003qiwtwlqwlv2so","_id":"cjbp5ec310040iwtwzgarfnqo"},{"post_id":"cjbp5ec1x002jiwtwj30snu1g","tag_id":"cjbp5ec1x002fiwtwzqnmk6sg","_id":"cjbp5ec330043iwtw6t7xvgrx"},{"post_id":"cjbp5ec1x002jiwtwj30snu1g","tag_id":"cjbp5ec27002wiwtwsylosltu","_id":"cjbp5ec330046iwtw5nkqmczh"},{"post_id":"cjbp5ec1x002riwtwbf4hxcrx","tag_id":"cjbp5ebzz000ciwtwssgalt2x","_id":"cjbp5ec330049iwtwa8dt203n"},{"post_id":"cjbp5ec1x002riwtwbf4hxcrx","tag_id":"cjbp5ec2v003qiwtwlqwlv2so","_id":"cjbp5ec33004ciwtwfeosj30r"},{"post_id":"cjbp5ec27002viwtw23898t7u","tag_id":"cjbp5ec2o003iiwtwvnykg5yn","_id":"cjbp5ec33004jiwtwx2gu6jpm"},{"post_id":"cjbp5ec27002viwtw23898t7u","tag_id":"cjbp5ec33004eiwtwobxb09zi","_id":"cjbp5ec33004liwtw7r00ilgb"},{"post_id":"cjbp5ec27002yiwtwqcfg13o4","tag_id":"cjbp5ec33004eiwtwobxb09zi","_id":"cjbp5ec3d004oiwtwj0vhfzns"},{"post_id":"cjbp5ec270031iwtwsntzo8ge","tag_id":"cjbp5ec2o003iiwtwvnykg5yn","_id":"cjbp5ec3d004qiwtw4p7gkxu0"},{"post_id":"cjbp5ec270034iwtwkcgfu1pl","tag_id":"cjbp5ec3d004piwtwqugtf5y7","_id":"cjbp5ec3d004siwtwz7iqri14"},{"post_id":"cjbp5ec270037iwtw0hkfzlzo","tag_id":"cjbp5ec2o003iiwtwvnykg5yn","_id":"cjbp5ec3d004uiwtwebpcq87z"},{"post_id":"cjbp5ec2m003fiwtw4cxvh4gi","tag_id":"cjbp5ec3d004tiwtwzb55x5qm","_id":"cjbp5ec3d004wiwtwmi1jht1o"},{"post_id":"cjbp5ec2r003miwtw0u6zhwsb","tag_id":"cjbp5ec3d004tiwtwzb55x5qm","_id":"cjbp5ec3d004yiwtwbsohinqr"},{"post_id":"cjbp5ec2w003siwtwmy5qd8ve","tag_id":"cjbp5ec3d004xiwtwrahtxhag","_id":"cjbp5ec3d004ziwtw2dmp5op9"},{"post_id":"cjbp5ec2u003piwtwr9pgyiej","tag_id":"cjbp5ec3d004piwtwqugtf5y7","_id":"cjbp5xvcf0000iktwpiugtshn"}],"Tag":[{"name":"c++","_id":"cjbp5ebzz000ciwtwssgalt2x"},{"name":"生活记录","_id":"cjbp5ec0j000qiwtwnqobi1l9"},{"name":"前端","_id":"cjbp5ec13001eiwtw4tbyozhv"},{"name":"图形学","_id":"cjbp5ec1d001siwtwlnavj6qh"},{"name":"瞎想","_id":"cjbp5ec1d0020iwtwms35eak4"},{"name":"操作系统","_id":"cjbp5ec1n0027iwtwc6ot6b2e"},{"name":"算法","_id":"cjbp5ec1x002fiwtwzqnmk6sg"},{"name":"算法学习","_id":"cjbp5ec27002wiwtwsylosltu"},{"name":"git","_id":"cjbp5ec270033iwtwat6f9de4"},{"name":"百科","_id":"cjbp5ec2j003biwtwbui07wzn"},{"name":"python学习","_id":"cjbp5ec2o003iiwtwvnykg5yn"},{"name":"机器学习","_id":"cjbp5ec2v003qiwtwlqwlv2so"},{"name":"python爬虫","_id":"cjbp5ec33004eiwtwobxb09zi"},{"name":"web学习整理","_id":"cjbp5ec3d004piwtwqugtf5y7"},{"name":"小问题","_id":"cjbp5ec3d004tiwtwzb55x5qm"},{"name":"课程","_id":"cjbp5ec3d004xiwtwrahtxhag"}]}}